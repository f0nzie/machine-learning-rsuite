[
["index.html", "Neural Networks Prerequisites", " Neural Networks Alfonso R. Reyes 2019-09-18 Prerequisites This is a sample book written in Markdown. You can use anything that Pandoc’s Markdown supports, e.g., a math equation \\(a^2 + b^2 = c^2\\). The bookdown package can be installed from CRAN or Github: install.packages(&quot;bookdown&quot;) # or the development version # devtools::install_github(&quot;rstudio/bookdown&quot;) "],
["building-deep-neural-nets-with-h2o-that-predict-arrhythmia-of-the-heart.html", "Chapter 1 Building deep neural nets with h2o that predict arrhythmia of the heart 1.1 Introduction 1.2 Arrhythmia data 1.3 Converting the dataframe to a h2o object 1.4 Training, test and validation data 1.5 Modeling 1.6 Model performance 1.7 Test data 1.8 Final conclusions: How useful is the model?", " Chapter 1 Building deep neural nets with h2o that predict arrhythmia of the heart 1.1 Introduction 27 February 2017 This week, I am showing how to build feed-forward deep neural networks or multilayer perceptrons. The models in this example are built to classify ECG data into being either from healthy hearts or from someone suffering from arrhythmia. I will show how to prepare a dataset for modeling, setting weights and other modeling parameters, and finally, how to evaluate model performance with the h2o package. 1.1.1 Deep learning with neural networks Deep learning with neural networks is arguably one of the most rapidly growing applications of machine learning and AI today. They allow building complex models that consist of multiple hidden layers within artificial networks and are able to find non-linear patterns in unstructured data. Deep neural networks are usually feed-forward, which means that each layer feeds its output to subsequent layers, but recurrent or feed-back neural networks can also be built. Feed-forward neural networks are also called multilayer perceptrons (MLPs). 1.1.2 H2O The R package h2o provides a convenient interface to H2O, which is an open-source machine learning and deep learning platform. H2O distributes a wide range of common machine learning algorithms for classification, regression and deep learning. 1.1.3 Preparing the R session First, we need to load the packages. library(dplyr) library(h2o) library(ggplot2) library(ggrepel) library(h2o) h2o.init() #&gt; #&gt; H2O is not running yet, starting it now... #&gt; #&gt; Note: In case of errors look at the following log files: #&gt; /tmp/Rtmp8KziyF/h2o_datascience_started_from_r.out #&gt; /tmp/Rtmp8KziyF/h2o_datascience_started_from_r.err #&gt; #&gt; #&gt; Starting H2O JVM and connecting: . Connection successful! #&gt; #&gt; R is connected to the H2O cluster: #&gt; H2O cluster uptime: 1 seconds 186 milliseconds #&gt; H2O cluster timezone: America/Chicago #&gt; H2O data parsing timezone: UTC #&gt; H2O cluster version: 3.22.1.1 #&gt; H2O cluster version age: 8 months and 21 days !!! #&gt; H2O cluster name: H2O_started_from_R_datascience_mwl453 #&gt; H2O cluster total nodes: 1 #&gt; H2O cluster total memory: 6.96 GB #&gt; H2O cluster total cores: 8 #&gt; H2O cluster allowed cores: 8 #&gt; H2O cluster healthy: TRUE #&gt; H2O Connection ip: localhost #&gt; H2O Connection port: 54321 #&gt; H2O Connection proxy: NA #&gt; H2O Internal Security: FALSE #&gt; H2O API Extensions: XGBoost, Algos, AutoML, Core V3, Core V4 #&gt; R Version: R version 3.6.0 (2019-04-26) #&gt; Warning in h2o.clusterInfo(): #&gt; Your H2O cluster version is too old (8 months and 21 days)! #&gt; Please download and install the latest version from http://h2o.ai/download/ my_theme &lt;- function(base_size = 12, base_family = &quot;sans&quot;){ theme_minimal(base_size = base_size, base_family = base_family) + theme( axis.text = element_text(size = 12), axis.title = element_text(size = 14), panel.grid.major = element_line(color = &quot;grey&quot;), panel.grid.minor = element_blank(), panel.background = element_rect(fill = &quot;aliceblue&quot;), strip.background = element_rect(fill = &quot;darkgrey&quot;, color = &quot;grey&quot;, size = 1), strip.text = element_text(face = &quot;bold&quot;, size = 12, color = &quot;white&quot;), legend.position = &quot;right&quot;, legend.justification = &quot;top&quot;, panel.border = element_rect(color = &quot;grey&quot;, fill = NA, size = 0.5) ) } 1.2 Arrhythmia data The data I am using to demonstrate the building of neural nets is the arrhythmia dataset from UC Irvine’s machine learning database. It contains 279 features from ECG heart rhythm diagnostics and one output column. I am not going to rename the feature columns because they are too many and the descriptions are too complex. Also, we don’t need to know specifically which features we are looking at for building the models. For a description of each feature, see https://archive.ics.uci.edu/ml/machine-learning-databases/arrhythmia/arrhythmia.names. The output column defines 16 classes: class 1 samples are from healthy ECGs, the remaining classes belong to different types of arrhythmia, with class 16 being all remaining arrhythmia cases that didn’t fit into distinct classes. arrhythmia &lt;- read.table(file.path(data_raw_dir, &quot;arrhythmia.data.txt&quot;), sep = &quot;,&quot;) arrhythmia[arrhythmia == &quot;?&quot;] &lt;- NA # making sure, that all feature columns are numeric arrhythmia[-280] &lt;- lapply(arrhythmia[-280], as.character) arrhythmia[-280] &lt;- lapply(arrhythmia[-280], as.numeric) # renaming output column and converting to factor colnames(arrhythmia)[280] &lt;- &quot;class&quot; arrhythmia$class &lt;- as.factor(arrhythmia$class) As usual, I want to get acquainted with the data and explore it’s properties before I am building any model. So, I am first going to look at the distribution of classes and of healthy and arrhythmia samples. p1 &lt;- ggplot(arrhythmia, aes(x = class)) + geom_bar(fill = &quot;navy&quot;, alpha = 0.7) + my_theme() Because I am interested in distinguishing healthy from arrhythmia ECGs, I am converting the output to binary format by combining all arrhythmia cases into one class. # all arrhythmia cases into one class arrhythmia$diagnosis &lt;- ifelse(arrhythmia$class == 1, &quot;healthy&quot;, &quot;arrhythmia&quot;) arrhythmia$diagnosis &lt;- as.factor(arrhythmia$diagnosis) p2 &lt;- ggplot(arrhythmia, aes(x = diagnosis)) + geom_bar(fill = &quot;navy&quot;, alpha = 0.7) + my_theme() library(gridExtra) #&gt; #&gt; Attaching package: &#39;gridExtra&#39; #&gt; The following object is masked from &#39;package:dplyr&#39;: #&gt; #&gt; combine library(grid) grid.arrange(p1, p2, ncol = 2) With binary classification, we have almost the same numbers of healthy and arrhythmia cases in our dataset. I am also interested in how much the normal and arrhythmia cases cluster in a Principal Component Analysis (PCA). I am first preparing the PCA plotting function and then run it on the feature data. library(pcaGoPromoter) #&gt; Warning: replacing previous import &#39;BiocGenerics::boxplot&#39; by #&gt; &#39;graphics::boxplot&#39; when loading &#39;Biostrings&#39; #&gt; Warning: replacing previous import &#39;BiocGenerics::image&#39; by #&gt; &#39;graphics::image&#39; when loading &#39;Biostrings&#39; #&gt; Warning: replacing previous import &#39;S4Vectors::na.exclude&#39; by #&gt; &#39;stats::na.exclude&#39; when loading &#39;Biostrings&#39; #&gt; Warning: replacing previous import &#39;IRanges::smoothEnds&#39; by #&gt; &#39;stats::smoothEnds&#39; when loading &#39;Biostrings&#39; #&gt; Warning: replacing previous import &#39;BiocGenerics::density&#39; by #&gt; &#39;stats::density&#39; when loading &#39;Biostrings&#39; #&gt; Warning: replacing previous import &#39;IRanges::mad&#39; by &#39;stats::mad&#39; when #&gt; loading &#39;Biostrings&#39; #&gt; Warning: replacing previous import &#39;S4Vectors::na.omit&#39; by &#39;stats::na.omit&#39; #&gt; when loading &#39;Biostrings&#39; #&gt; Warning: replacing previous import &#39;S4Vectors::complete.cases&#39; by #&gt; &#39;stats::complete.cases&#39; when loading &#39;Biostrings&#39; #&gt; Warning: replacing previous import &#39;IRanges::runmed&#39; by &#39;stats::runmed&#39; #&gt; when loading &#39;Biostrings&#39; #&gt; Warning: replacing previous import &#39;IRanges::start&#39; by &#39;stats::start&#39; when #&gt; loading &#39;Biostrings&#39; #&gt; Warning: replacing previous import &#39;IRanges::window&lt;-&#39; by &#39;stats::window&lt;-&#39; #&gt; when loading &#39;Biostrings&#39; #&gt; Warning: replacing previous import &#39;S4Vectors::window&#39; by &#39;stats::window&#39; #&gt; when loading &#39;Biostrings&#39; #&gt; Warning: replacing previous import &#39;S4Vectors::aggregate&#39; by #&gt; &#39;stats::aggregate&#39; when loading &#39;Biostrings&#39; #&gt; Warning: replacing previous import &#39;BiocGenerics::weights&#39; by #&gt; &#39;stats::weights&#39; when loading &#39;Biostrings&#39; #&gt; Warning: replacing previous import &#39;IRanges::cor&#39; by &#39;stats::cor&#39; when #&gt; loading &#39;Biostrings&#39; #&gt; Warning: replacing previous import &#39;IRanges::cov&#39; by &#39;stats::cov&#39; when #&gt; loading &#39;Biostrings&#39; #&gt; Warning: replacing previous import &#39;IRanges::quantile&#39; by &#39;stats::quantile&#39; #&gt; when loading &#39;Biostrings&#39; #&gt; Warning: replacing previous import &#39;IRanges::end&#39; by &#39;stats::end&#39; when #&gt; loading &#39;Biostrings&#39; #&gt; Warning: replacing previous import &#39;BiocGenerics::residuals&#39; by #&gt; &#39;stats::residuals&#39; when loading &#39;Biostrings&#39; #&gt; Warning: replacing previous import &#39;IRanges::median&#39; by &#39;stats::median&#39; #&gt; when loading &#39;Biostrings&#39; #&gt; Warning: replacing previous import &#39;IRanges::sd&#39; by &#39;stats::sd&#39; when #&gt; loading &#39;Biostrings&#39; #&gt; Warning: replacing previous import &#39;IRanges::var&#39; by &#39;stats::var&#39; when #&gt; loading &#39;Biostrings&#39; #&gt; Warning: replacing previous import &#39;S4Vectors::xtabs&#39; by &#39;stats::xtabs&#39; #&gt; when loading &#39;Biostrings&#39; #&gt; Warning: replacing previous import &#39;IRanges::IQR&#39; by &#39;stats::IQR&#39; when #&gt; loading &#39;Biostrings&#39; #&gt; Warning: replacing previous import &#39;S4Vectors::tail&#39; by &#39;utils::tail&#39; when #&gt; loading &#39;Biostrings&#39; #&gt; Warning: replacing previous import &#39;IRanges::stack&#39; by &#39;utils::stack&#39; when #&gt; loading &#39;Biostrings&#39; #&gt; Warning: replacing previous import &#39;XVector::relist&#39; by &#39;utils::relist&#39; #&gt; when loading &#39;Biostrings&#39; #&gt; Warning: replacing previous import &#39;S4Vectors::head&#39; by &#39;utils::head&#39; when #&gt; loading &#39;Biostrings&#39; pca_func &lt;- function(pcaOutput2, group_name){ centroids &lt;- aggregate(cbind(PC1, PC2) ~ groups, pcaOutput2, mean) conf.rgn &lt;- do.call(rbind, lapply(unique(pcaOutput2$groups), function(t) data.frame(groups = as.character(t), ellipse(cov(pcaOutput2[pcaOutput2$groups == t, 1:2]), centre = as.matrix(centroids[centroids$groups == t, 2:3]), level = 0.95), stringsAsFactors = FALSE))) plot &lt;- ggplot(data = pcaOutput2, aes(x = PC1, y = PC2, group = groups, color = groups)) + geom_polygon(data = conf.rgn, aes(fill = groups), alpha = 0.2) + geom_point(size = 2, alpha = 0.5) + labs(color = paste(group_name), fill = paste(group_name), x = paste0(&quot;PC1: &quot;, round(pcaOutput$pov[1], digits = 2) * 100, &quot;% variance&quot;), y = paste0(&quot;PC2: &quot;, round(pcaOutput$pov[2], digits = 2) * 100, &quot;% variance&quot;)) + my_theme() return(plot) } # Find what columns have NAs and the quantity for (col in names(arrhythmia)) { n_nas &lt;- length(which(is.na(arrhythmia[, col]))) if (n_nas &gt; 0) cat(col, n_nas, &quot;\\n&quot;) } #&gt; V11 8 #&gt; V12 22 #&gt; V13 1 #&gt; V14 376 #&gt; V15 1 # Replace NAs with zeros arrhythmia[is.na(arrhythmia)] &lt;- 0 Find and plot the PCAs. pcaOutput &lt;- pca(t(arrhythmia[-c(280, 281)]), printDropped=FALSE, scale=TRUE, center = TRUE) pcaOutput2 &lt;- as.data.frame(pcaOutput$scores) pcaOutput2$groups &lt;- arrhythmia$class p1 &lt;- pca_func(pcaOutput2, group_name = &quot;class&quot;) pcaOutput2$groups &lt;- arrhythmia$diagnosis p2 &lt;- pca_func(pcaOutput2, group_name = &quot;diagnosis&quot;) grid.arrange(p1, p2, ncol = 2) The PCA shows that there is a big overlap between healthy and arrhythmia samples, i.e. there does not seem to be major global differences in all features. The class that is most distinct from all others seems to be class 9. I want to give the arrhythmia cases that are very different from the rest a stronger weight in the neural network, so I define a weight column where every sample outside the central PCA cluster will get a “2”, they will in effect be used twice in the model. weights &lt;- ifelse(pcaOutput2$PC1 &lt; -5 &amp; abs(pcaOutput2$PC2) &gt; 10, 2, 1) I also want to know what the variance is within features. library(matrixStats) #&gt; #&gt; Attaching package: &#39;matrixStats&#39; #&gt; The following object is masked from &#39;package:dplyr&#39;: #&gt; #&gt; count colvars &lt;- data.frame(feature = colnames(arrhythmia[-c(280, 281)]), variance = colVars(as.matrix(arrhythmia[-c(280, 281)]))) subset(colvars, variance &gt; 50) %&gt;% mutate(feature = factor(feature, levels = colnames(arrhythmia[-c(280, 281)]))) %&gt;% ggplot(aes(x = feature, y = variance)) + geom_bar(stat = &quot;identity&quot;, fill = &quot;navy&quot;, alpha = 0.7) + my_theme() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) Features with low variance are less likely to strongly contribute to a differentiation between healthy and arrhythmia cases, so I am going to remove them. I am also concatenating the weights column: arrhythmia_subset &lt;- cbind(weights, arrhythmia[, c(281, 280, which(colvars$variance &gt; 50))]) 1.3 Converting the dataframe to a h2o object Now that I have my final data frame for modeling, for working with h2o functions, the data needs to be converted from a DataFrame to an H2O Frame. This is done with the as_h2o_frame() function. #as_h2o_frame(arrhythmia_subset) arrhythmia_hf &lt;- as.h2o(arrhythmia_subset, key=&quot;arrhtythmia.hex&quot;) #&gt; | | | 0% | |=================================================================| 100% We can now access all functions from the h2o package that are built to work on h2o Frames. A useful such function is h2o.describe(). It is similar to base R’s summary() function but outputs many more descriptive measures for our data. To get a good overview about these measures, I am going to plot them. library(tidyr) # for gathering #&gt; #&gt; Attaching package: &#39;tidyr&#39; #&gt; The following object is masked from &#39;package:S4Vectors&#39;: #&gt; #&gt; expand h2o.describe(arrhythmia_hf[, -1]) %&gt;% # excluding the weights column gather(x, y, Zeros:Sigma) %&gt;% mutate(group = ifelse( x %in% c(&quot;Min&quot;, &quot;Max&quot;, &quot;Mean&quot;), &quot;min, mean, max&quot;, ifelse(x %in% c(&quot;NegInf&quot;, &quot;PosInf&quot;), &quot;Inf&quot;, &quot;sigma, zeros&quot;))) %&gt;% # separating them into facets makes them easier to see mutate(Label = factor(Label, levels = colnames(arrhythmia_hf[, -1]))) %&gt;% ggplot(aes(x = Label, y = as.numeric(y), color = x)) + geom_point(size = 4, alpha = 0.6) + scale_color_brewer(palette = &quot;Set1&quot;) + my_theme() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) + facet_grid(group ~ ., scales = &quot;free&quot;) + labs(x = &quot;Feature&quot;, y = &quot;Value&quot;, color = &quot;&quot;) #&gt; Warning: Removed 2 rows containing missing values (geom_point). I am also interested in the correlation between features and the output. We can use the h2o.cor() function to calculate the correlation matrix. It is again much easier to understand the data when we visualize it, so I am going to create another plot. library(reshape2) # for melting #&gt; #&gt; Attaching package: &#39;reshape2&#39; #&gt; The following object is masked from &#39;package:tidyr&#39;: #&gt; #&gt; smiths # diagnosis is now a characer column and we need to convert it again arrhythmia_hf[, 2] &lt;- h2o.asfactor(arrhythmia_hf[, 2]) arrhythmia_hf[, 3] &lt;- h2o.asfactor(arrhythmia_hf[, 3]) # same for class cor &lt;- h2o.cor(arrhythmia_hf[, -c(1, 3)]) rownames(cor) &lt;- colnames(cor) melt(cor) %&gt;% mutate(Var2 = rep(rownames(cor), nrow(cor))) %&gt;% mutate(Var2 = factor(Var2, levels = colnames(cor))) %&gt;% mutate(variable = factor(variable, levels = colnames(cor))) %&gt;% ggplot(aes(x = variable, y = Var2, fill = value)) + geom_tile(width = 0.9, height = 0.9) + scale_fill_gradient2(low = &quot;white&quot;, high = &quot;red&quot;, name = &quot;Cor.&quot;) + my_theme() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) + labs(x = &quot;&quot;, y = &quot;&quot;) #&gt; No id variables; using all as measure variables 1.4 Training, test and validation data Now we can use the h2o.splitFrame() function to split the data into training, validation and test data. Here, I am using 70% for training and 15% each for validation and testing. We could also just split the data into two sections, a training and test set but when we have sufficient samples, it is a good idea to evaluate model performance on an independent test set on top of training with a validation set. Because we can easily overfit a model, we want to get an idea about how generalizable it is - this we can only assess by looking at how well it works on previously unknown data. I am also defining response, features and weights column names now. splits &lt;- h2o.splitFrame(arrhythmia_hf, ratios = c(0.7, 0.15), seed = 1) train &lt;- splits[[1]] valid &lt;- splits[[2]] test &lt;- splits[[3]] response &lt;- &quot;diagnosis&quot; weights &lt;- &quot;weights&quot; features &lt;- setdiff(colnames(train), c(response, weights, &quot;class&quot;)) summary(train$diagnosis, exact_quantiles = TRUE) #&gt; diagnosis #&gt; healthy :163 #&gt; arrhythmia:155 summary(valid$diagnosis, exact_quantiles = TRUE) #&gt; diagnosis #&gt; healthy :43 #&gt; arrhythmia:25 summary(test$diagnosis, exact_quantiles = TRUE) #&gt; diagnosis #&gt; healthy :39 #&gt; arrhythmia:27 If we had more categorical features, we could use the h2o.interaction() function to define interaction terms, but since we only have numeric features here, we don’t need this. We can also run a PCA on the training data, using the h2o.prcomp() function to calculate the singular value decomposition of the Gram matrix with the power method. pca &lt;- h2o.prcomp(training_frame = train, x = features, validation_frame = valid, transform = &quot;NORMALIZE&quot;, k = 3, seed = 42) #&gt; | | | 0% | |============= | 20% | |=================================================================| 100% #&gt; Warning in doTryCatch(return(expr), name, parentenv, handler): _train: #&gt; Dataset used may contain fewer number of rows due to removal of rows with #&gt; NA/missing values. If this is not desirable, set impute_missing argument in #&gt; pca call to TRUE/True/true/... depending on the client language. pca #&gt; Model Details: #&gt; ============== #&gt; #&gt; H2ODimReductionModel: pca #&gt; Model ID: PCA_model_R_1568839636484_1 #&gt; Importance of components: #&gt; pc1 pc2 pc3 #&gt; Standard deviation 0.582620 0.507796 0.421869 #&gt; Proportion of Variance 0.164697 0.125110 0.086351 #&gt; Cumulative Proportion 0.164697 0.289808 0.376159 #&gt; #&gt; #&gt; H2ODimReductionMetrics: pca #&gt; #&gt; No model metrics available for PCA #&gt; H2ODimReductionMetrics: pca #&gt; #&gt; No model metrics available for PCA eigenvec &lt;- as.data.frame(pca@model$eigenvectors) eigenvec$label &lt;- features ggplot(eigenvec, aes(x = pc1, y = pc2, label = label)) + geom_point(color = &quot;navy&quot;, alpha = 0.7) + geom_text_repel() + my_theme() 1.5 Modeling Now, we can build a deep neural network model. We can specify quite a few parameters, like Cross-validation: Cross validation can tell us the training and validation errors for each model. The final model will be overwritten with the best model, if we don’t specify otherwise. Adaptive learning rate: For deep learning with h2o, we by default use stochastic gradient descent optimization with an an adaptive learning rate. The two corresponding parameters rho and epsilon help us find global (or near enough) optima. Activation function: The activation function defines the node output relative to a given set of inputs. We want our activation function to be non-linear and continuously differentiable. Hidden nodes: Defines the number of hidden layers and the number of nodes per layer. Epochs: Increasing the number of epochs (one full training cycle on all training samples) can increase model performance, but we also run the risk of overfitting. To determine the optimal number of epochs, we need to use early stopping. Early stopping: By default, early stopping is enabled. This means that training will be stopped when we reach a certain validation error to prevent overfitting. Of course, you need quite a bit of experience and intuition to hit on a good combination of parameters. That’s why it usually makes sense to do a grid search for hyper-parameter tuning. Here, I want to focus on building and evaluating deep learning models, though. I will cover grid search in next week’s post. # this will take some time and all CPUs dl_model &lt;- h2o.deeplearning(x = features, y = response, weights_column = weights, model_id = &quot;dl_model&quot;, training_frame = train, validation_frame = valid, nfolds = 15, # 10x cross validation keep_cross_validation_fold_assignment = TRUE, fold_assignment = &quot;Stratified&quot;, activation = &quot;RectifierWithDropout&quot;, score_each_iteration = TRUE, hidden = c(200, 200, 200, 200, 200), # 5 hidden layers, each of 200 neurons epochs = 100, variable_importances = TRUE, export_weights_and_biases = TRUE, seed = 42) #&gt; | | | 0% | |====== | 9% | |====== | 10% | |======= | 11% | |======== | 12% | |========== | 16% | |=========== | 16% | |=========== | 17% | |============= | 19% | |============= | 20% | |============== | 21% | |=============== | 22% | |=============== | 24% | |================ | 25% | |================= | 26% | |================= | 27% | |================== | 28% | |=================== | 29% | |==================== | 30% | |==================== | 31% | |===================== | 32% | |====================== | 34% | |======================== | 38% | |========================= | 39% | |========================== | 41% | |=========================== | 41% | |============================ | 44% | |============================== | 46% | |=============================== | 48% | |================================ | 49% | |================================= | 51% | |=================================== | 54% | |==================================== | 56% | |===================================== | 57% | |======================================= | 59% | |======================================= | 61% | |======================================== | 62% | |========================================= | 62% | |========================================= | 64% | |========================================== | 65% | |=========================================== | 66% | |=========================================== | 67% | |============================================= | 69% | |============================================== | 70% | |=============================================== | 72% | |================================================ | 74% | |================================================= | 76% | |================================================== | 78% | |==================================================== | 79% | |==================================================== | 80% | |===================================================== | 81% | |===================================================== | 82% | |=============================================================== | 96% | |=================================================================| 100% Because training can take a while, depending on how many samples, features, nodes and hidden layers you are training on, it is a good idea to save your model. # if file exists, overwrite it h2o.saveModel(dl_model, path = file.path(data_out_dir, &quot;dl_model&quot;), force = TRUE) #&gt; [1] &quot;/home/datascience/repos/machine-learning-rsuite/export/dl_model/dl_model&quot; We can then re-load the model again any time to check the model quality and make predictions on new data. dl_model &lt;- h2o.loadModel(file.path(data_out_dir, &quot;dl_model/dl_model&quot;)) 1.6 Model performance We now want to know how our model performed on the validation data. The summary() function will give us a detailed overview of our model. I am not showing the output here, because it is quite extensive. sum_model &lt;- summary(dl_model) #&gt; Model Details: #&gt; ============== #&gt; #&gt; H2OBinomialModel: deeplearning #&gt; Model Key: dl_model #&gt; Status of Neuron Layers: predicting diagnosis, 2-class classification, bernoulli distribution, CrossEntropy loss, 179,402 weights/biases, 2.1 MB, 34,090 training samples, mini-batch size 1 #&gt; layer units type dropout l1 l2 mean_rate #&gt; 1 1 90 Input 0.00 % NA NA NA #&gt; 2 2 200 RectifierDropout 50.00 % 0.000000 0.000000 0.004689 #&gt; 3 3 200 RectifierDropout 50.00 % 0.000000 0.000000 0.006862 #&gt; 4 4 200 RectifierDropout 50.00 % 0.000000 0.000000 0.009357 #&gt; 5 5 200 RectifierDropout 50.00 % 0.000000 0.000000 0.008938 #&gt; 6 6 200 RectifierDropout 50.00 % 0.000000 0.000000 0.018340 #&gt; 7 7 2 Softmax NA 0.000000 0.000000 0.002258 #&gt; rate_rms momentum mean_weight weight_rms mean_bias bias_rms #&gt; 1 NA NA NA NA NA NA #&gt; 2 0.003811 0.000000 0.002890 0.095821 0.425685 0.059096 #&gt; 3 0.003942 0.000000 -0.008652 0.075005 0.947659 0.058449 #&gt; 4 0.004836 0.000000 -0.007448 0.072550 0.971064 0.030675 #&gt; 5 0.004677 0.000000 -0.005646 0.071422 0.973825 0.034928 #&gt; 6 0.040604 0.000000 -0.010724 0.071647 0.956291 0.034673 #&gt; 7 0.000958 0.000000 -0.041075 0.379310 0.000832 0.089558 #&gt; #&gt; H2OBinomialMetrics: deeplearning #&gt; ** Reported on training data. ** #&gt; ** Metrics reported on full training frame ** #&gt; #&gt; MSE: 0.0202 #&gt; RMSE: 0.142 #&gt; LogLoss: 0.0835 #&gt; Mean Per-Class Error: 0.0214 #&gt; AUC: 0.99 #&gt; pr_auc: 0.979 #&gt; Gini: 0.979 #&gt; #&gt; Confusion Matrix (vertical: actual; across: predicted) for F1-optimal threshold: #&gt; arrhythmia healthy Error Rate #&gt; arrhythmia 160 4 0.024390 =4/164 #&gt; healthy 3 160 0.018405 =3/163 #&gt; Totals 163 164 0.021407 =7/327 #&gt; #&gt; Maximum Metrics: Maximum metrics at their respective thresholds #&gt; metric threshold value idx #&gt; 1 max f1 0.688492 0.978593 163 #&gt; 2 max f2 0.235153 0.989078 171 #&gt; 3 max f0point5 0.776991 0.978934 160 #&gt; 4 max accuracy 0.688492 0.978593 163 #&gt; 5 max precision 0.996164 1.000000 0 #&gt; 6 max recall 0.235153 1.000000 171 #&gt; 7 max specificity 0.996164 1.000000 0 #&gt; 8 max absolute_mcc 0.688492 0.957205 163 #&gt; 9 max min_per_class_accuracy 0.688492 0.975610 163 #&gt; 10 max mean_per_class_accuracy 0.688492 0.978602 163 #&gt; #&gt; Gains/Lift Table: Extract with `h2o.gainsLift(&lt;model&gt;, &lt;data&gt;)` or `h2o.gainsLift(&lt;model&gt;, valid=&lt;T/F&gt;, xval=&lt;T/F&gt;)` #&gt; H2OBinomialMetrics: deeplearning #&gt; ** Reported on validation data. ** #&gt; ** Metrics reported on full validation frame ** #&gt; #&gt; MSE: 0.205 #&gt; RMSE: 0.453 #&gt; LogLoss: 1.12 #&gt; Mean Per-Class Error: 0.223 #&gt; AUC: 0.849 #&gt; pr_auc: 0.874 #&gt; Gini: 0.699 #&gt; #&gt; Confusion Matrix (vertical: actual; across: predicted) for F1-optimal threshold: #&gt; arrhythmia healthy Error Rate #&gt; arrhythmia 15 10 0.400000 =10/25 #&gt; healthy 2 41 0.046512 =2/43 #&gt; Totals 17 51 0.176471 =12/68 #&gt; #&gt; Maximum Metrics: Maximum metrics at their respective thresholds #&gt; metric threshold value idx #&gt; 1 max f1 0.000569 0.872340 50 #&gt; 2 max f2 0.000044 0.929204 53 #&gt; 3 max f0point5 0.957343 0.847953 31 #&gt; 4 max accuracy 0.000569 0.823529 50 #&gt; 5 max precision 0.995778 1.000000 0 #&gt; 6 max recall 0.000002 1.000000 61 #&gt; 7 max specificity 0.995778 1.000000 0 #&gt; 8 max absolute_mcc 0.000569 0.616316 50 #&gt; 9 max min_per_class_accuracy 0.678418 0.760000 38 #&gt; 10 max mean_per_class_accuracy 0.877647 0.780465 34 #&gt; #&gt; Gains/Lift Table: Extract with `h2o.gainsLift(&lt;model&gt;, &lt;data&gt;)` or `h2o.gainsLift(&lt;model&gt;, valid=&lt;T/F&gt;, xval=&lt;T/F&gt;)` #&gt; H2OBinomialMetrics: deeplearning #&gt; ** Reported on cross-validation data. ** #&gt; ** 15-fold cross-validation on training data (Metrics computed for combined holdout predictions) ** #&gt; #&gt; MSE: 0.164 #&gt; RMSE: 0.405 #&gt; LogLoss: 0.562 #&gt; Mean Per-Class Error: 0.198 #&gt; AUC: 0.849 #&gt; pr_auc: 0.785 #&gt; Gini: 0.699 #&gt; #&gt; Confusion Matrix (vertical: actual; across: predicted) for F1-optimal threshold: #&gt; arrhythmia healthy Error Rate #&gt; arrhythmia 114 50 0.304878 =50/164 #&gt; healthy 15 148 0.092025 =15/163 #&gt; Totals 129 198 0.198777 =65/327 #&gt; #&gt; Maximum Metrics: Maximum metrics at their respective thresholds #&gt; metric threshold value idx #&gt; 1 max f1 0.336530 0.819945 197 #&gt; 2 max f2 0.047572 0.891648 233 #&gt; 3 max f0point5 0.890278 0.788618 112 #&gt; 4 max accuracy 0.408737 0.801223 191 #&gt; 5 max precision 0.998156 1.000000 0 #&gt; 6 max recall 0.001116 1.000000 282 #&gt; 7 max specificity 0.998156 1.000000 0 #&gt; 8 max absolute_mcc 0.336530 0.616987 197 #&gt; 9 max min_per_class_accuracy 0.711692 0.762195 163 #&gt; 10 max mean_per_class_accuracy 0.336530 0.801549 197 #&gt; #&gt; Gains/Lift Table: Extract with `h2o.gainsLift(&lt;model&gt;, &lt;data&gt;)` or `h2o.gainsLift(&lt;model&gt;, valid=&lt;T/F&gt;, xval=&lt;T/F&gt;)` #&gt; Cross-Validation Metrics Summary: #&gt; mean sd cv_1_valid cv_2_valid #&gt; accuracy 0.85373646 0.05400193 0.71428573 0.8235294 #&gt; auc 0.8691958 0.065484196 0.7058824 0.75 #&gt; err 0.14626352 0.05400193 0.2857143 0.1764706 #&gt; err_count 3.5333333 1.6505891 8.0 3.0 #&gt; f0point5 0.8223122 0.070520826 0.6321839 0.6896552 #&gt; f1 0.8629413 0.052716263 0.73333335 0.72727275 #&gt; f2 0.91222143 0.040253464 0.8730159 0.7692308 #&gt; lift_top_group 1.7390026 0.54450756 2.5454545 0.0 #&gt; logloss 0.5395633 0.15415654 0.7992615 0.99601847 #&gt; max_per_class_error 0.26397356 0.10788167 0.47058824 0.2 #&gt; mcc 0.72290695 0.09514731 0.5536258 0.60385966 #&gt; mean_per_class_accuracy 0.8497826 0.054571785 0.7647059 0.81666666 #&gt; mean_per_class_error 0.1502174 0.054571785 0.23529412 0.18333334 #&gt; mse 0.1554209 0.041107234 0.2719348 0.24296726 #&gt; precision 0.798864 0.08186284 0.57894737 0.6666667 #&gt; r2 0.34576175 0.18322283 -0.14009029 -0.17029229 #&gt; recall 0.9516845 0.04603761 1.0 0.8 #&gt; rmse 0.38718337 0.052487846 0.5214737 0.4929171 #&gt; specificity 0.7478807 0.11689204 0.5294118 0.8333333 #&gt; cv_3_valid cv_4_valid cv_5_valid cv_6_valid #&gt; accuracy 0.8666667 0.82608694 0.9444444 0.9375 #&gt; auc 0.9444444 0.8333333 0.97402596 0.96875 #&gt; err 0.13333334 0.17391305 0.055555556 0.0625 #&gt; err_count 2.0 4.0 1.0 1.0 #&gt; f0point5 0.8490566 0.81395346 0.98039216 0.90909094 #&gt; f1 0.9 0.875 0.95238096 0.9411765 #&gt; f2 0.9574468 0.9459459 0.9259259 0.9756098 #&gt; lift_top_group 1.6666666 1.6428572 1.6363636 2.0 #&gt; logloss 0.27121913 0.70881706 0.3820218 0.22684355 #&gt; max_per_class_error 0.33333334 0.44444445 0.09090909 0.125 #&gt; mcc 0.73854893 0.6573422 0.8918826 0.8819171 #&gt; mean_per_class_accuracy 0.8333333 0.7777778 0.95454544 0.9375 #&gt; mean_per_class_error 0.16666667 0.22222222 0.045454547 0.0625 #&gt; mse 0.0891015 0.18082269 0.07822435 0.07436488 #&gt; precision 0.8181818 0.7777778 1.0 0.8888889 #&gt; r2 0.62874377 0.24083172 0.6708482 0.70254046 #&gt; recall 1.0 1.0 0.90909094 1.0 #&gt; rmse 0.29849875 0.4252325 0.27968618 0.27269924 #&gt; specificity 0.6666667 0.5555556 1.0 0.875 #&gt; cv_7_valid cv_8_valid cv_9_valid cv_10_valid #&gt; accuracy 0.90909094 1.0 0.8076923 0.76666665 #&gt; auc 0.9375 1.0 0.79738563 0.82589287 #&gt; err 0.09090909 0.0 0.1923077 0.23333333 #&gt; err_count 2.0 0.0 5.0 7.0 #&gt; f0point5 0.875 1.0 0.82474226 0.71428573 #&gt; f1 0.875 1.0 0.8648649 0.8 #&gt; f2 0.875 1.0 0.90909094 0.90909094 #&gt; lift_top_group 2.75 1.5714285 1.5294118 2.142857 #&gt; logloss 0.50669134 0.3446363 0.5279358 0.55482465 #&gt; max_per_class_error 0.125 0.0 0.44444445 0.4375 #&gt; mcc 0.8035714 1.0 0.5608894 0.61237246 #&gt; mean_per_class_accuracy 0.90178573 1.0 0.748366 0.78125 #&gt; mean_per_class_error 0.09821428 0.0 0.251634 0.21875 #&gt; mse 0.10769239 0.11712868 0.17545187 0.19161887 #&gt; precision 0.875 1.0 0.8 0.6666667 #&gt; r2 0.53461504 0.4938368 0.22480085 0.23010276 #&gt; recall 0.875 1.0 0.9411765 1.0 #&gt; rmse 0.3281652 0.34224066 0.41886976 0.43774292 #&gt; specificity 0.9285714 1.0 0.5555556 0.5625 #&gt; cv_11_valid cv_12_valid cv_13_valid cv_14_valid #&gt; accuracy 0.8636364 0.7619048 0.8125 0.83870965 #&gt; auc 0.92561984 0.72727275 0.82421875 0.87916666 #&gt; err 0.13636364 0.23809524 0.1875 0.16129032 #&gt; err_count 3.0 5.0 6.0 5.0 #&gt; f0point5 0.8208955 0.71428573 0.79545456 0.8333333 #&gt; f1 0.88 0.8 0.8235294 0.8484849 #&gt; f2 0.94827586 0.90909094 0.85365856 0.86419755 #&gt; lift_top_group 2.0 2.1 2.0 0.0 #&gt; logloss 0.43224233 0.8551434 0.68788403 0.43409038 #&gt; max_per_class_error 0.27272728 0.45454547 0.25 0.2 #&gt; mcc 0.75592893 0.6030227 0.6299408 0.6778302 #&gt; mean_per_class_accuracy 0.8636364 0.77272725 0.8125 0.8375 #&gt; mean_per_class_error 0.13636364 0.22727273 0.1875 0.1625 #&gt; mse 0.15442659 0.21357358 0.18530901 0.13480169 #&gt; precision 0.78571427 0.6666667 0.7777778 0.8235294 #&gt; r2 0.3822936 0.14376412 0.25876397 0.4602316 #&gt; recall 1.0 1.0 0.875 0.875 #&gt; rmse 0.3929715 0.4621402 0.43047532 0.3671535 #&gt; specificity 0.72727275 0.54545456 0.75 0.8 #&gt; cv_15_valid #&gt; accuracy 0.93333334 #&gt; auc 0.9444444 #&gt; err 0.06666667 #&gt; err_count 1.0 #&gt; f0point5 0.88235295 #&gt; f1 0.9230769 #&gt; f2 0.9677419 #&gt; lift_top_group 2.5 #&gt; logloss 0.36581942 #&gt; max_per_class_error 0.11111111 #&gt; mcc 0.8728716 #&gt; mean_per_class_accuracy 0.9444444 #&gt; mean_per_class_error 0.055555556 #&gt; mse 0.11389533 #&gt; precision 0.85714287 #&gt; r2 0.52543616 #&gt; recall 1.0 #&gt; rmse 0.33748382 #&gt; specificity 0.8888889 #&gt; #&gt; Scoring History: #&gt; timestamp duration training_speed epochs #&gt; 1 2019-09-18 15:49:02 0.000 sec NA 0.00000 #&gt; 2 2019-09-18 15:49:03 1 min 31.882 sec 5301 obs/sec 10.72013 #&gt; 3 2019-09-18 15:49:04 1 min 32.558 sec 5360 obs/sec 21.44025 #&gt; 4 2019-09-18 15:49:04 1 min 33.204 sec 5463 obs/sec 32.16038 #&gt; 5 2019-09-18 15:49:05 1 min 33.803 sec 5620 obs/sec 42.88050 #&gt; 6 2019-09-18 15:49:06 1 min 34.438 sec 5664 obs/sec 53.60063 #&gt; 7 2019-09-18 15:49:06 1 min 35.033 sec 5751 obs/sec 64.32075 #&gt; 8 2019-09-18 15:49:07 1 min 35.675 sec 5831 obs/sec 75.04088 #&gt; 9 2019-09-18 15:49:08 1 min 36.270 sec 5889 obs/sec 85.76101 #&gt; 10 2019-09-18 15:49:08 1 min 36.854 sec 5943 obs/sec 96.48113 #&gt; 11 2019-09-18 15:49:09 1 min 37.448 sec 5972 obs/sec 107.20126 #&gt; iterations samples training_rmse training_logloss training_r2 #&gt; 1 0 0.000000 NA NA NA #&gt; 2 1 3409.000000 0.40207 0.52240 0.35334 #&gt; 3 2 6818.000000 0.34953 0.40192 0.51131 #&gt; 4 3 10227.000000 0.32639 0.36193 0.57388 #&gt; 5 4 13636.000000 0.30180 0.29725 0.63566 #&gt; 6 5 17045.000000 0.27525 0.26047 0.69696 #&gt; 7 6 20454.000000 0.24268 0.21183 0.76443 #&gt; 8 7 23863.000000 0.22391 0.17388 0.79946 #&gt; 9 8 27272.000000 0.17923 0.12306 0.87151 #&gt; 10 9 30681.000000 0.15818 0.09538 0.89992 #&gt; 11 10 34090.000000 0.14201 0.08348 0.91934 #&gt; training_auc training_pr_auc training_lift #&gt; 1 NA NA NA #&gt; 2 0.87105 0.83312 1.50460 #&gt; 3 0.91029 0.88251 2.00613 #&gt; 4 0.93094 0.90739 2.00613 #&gt; 5 0.94883 0.92703 2.00613 #&gt; 6 0.95739 0.93714 2.00613 #&gt; 7 0.96858 0.94734 2.00613 #&gt; 8 0.97737 0.96088 2.00613 #&gt; 9 0.98694 0.97583 2.00613 #&gt; 10 0.98904 0.97836 2.00613 #&gt; 11 0.98960 0.97926 2.00613 #&gt; training_classification_error validation_rmse validation_logloss #&gt; 1 NA NA NA #&gt; 2 0.19266 0.44247 0.66010 #&gt; 3 0.15902 0.39886 0.49621 #&gt; 4 0.12844 0.40879 0.63136 #&gt; 5 0.10092 0.41332 0.59634 #&gt; 6 0.08869 0.45115 0.79907 #&gt; 7 0.06728 0.42157 0.80771 #&gt; 8 0.05810 0.43678 0.93822 #&gt; 9 0.03364 0.42026 0.84031 #&gt; 10 0.02752 0.47363 1.25664 #&gt; 11 0.02141 0.45286 1.11964 #&gt; validation_r2 validation_auc validation_pr_auc validation_lift #&gt; 1 NA NA NA NA #&gt; 2 0.15786 0.84093 0.86342 1.58140 #&gt; 3 0.31568 0.88930 0.90496 1.58140 #&gt; 4 0.28120 0.85581 0.87668 1.58140 #&gt; 5 0.26518 0.86326 0.88004 1.58140 #&gt; 6 0.12449 0.83070 0.85694 1.58140 #&gt; 7 0.23554 0.86326 0.88658 1.58140 #&gt; 8 0.17938 0.84744 0.87158 1.58140 #&gt; 9 0.24028 0.84000 0.85294 1.58140 #&gt; 10 0.03510 0.83907 0.86368 1.58140 #&gt; 11 0.11786 0.84930 0.87436 1.58140 #&gt; validation_classification_error #&gt; 1 NA #&gt; 2 0.22059 #&gt; 3 0.16176 #&gt; 4 0.17647 #&gt; 5 0.16176 #&gt; 6 0.17647 #&gt; 7 0.16176 #&gt; 8 0.17647 #&gt; 9 0.17647 #&gt; 10 0.16176 #&gt; 11 0.17647 #&gt; #&gt; Variable Importances: (Extract with `h2o.varimp`) #&gt; ================================================= #&gt; #&gt; Variable Importances: #&gt; variable relative_importance scaled_importance percentage #&gt; 1 V169 1.000000 1.000000 0.014789 #&gt; 2 V239 0.909679 0.909679 0.013454 #&gt; 3 V5 0.895259 0.895259 0.013240 #&gt; 4 V15 0.857806 0.857806 0.012686 #&gt; 5 V103 0.843830 0.843830 0.012480 #&gt; #&gt; --- #&gt; variable relative_importance scaled_importance percentage #&gt; 85 V10 0.672980 0.672980 0.009953 #&gt; 86 V219 0.672928 0.672928 0.009952 #&gt; 87 V218 0.672750 0.672750 0.009950 #&gt; 88 V45 0.671611 0.671611 0.009933 #&gt; 89 V88 0.670450 0.670450 0.009916 #&gt; 90 V33 0.662410 0.662410 0.009797 One performance metric we are usually interested in is the mean per class error for training and validation data. h2o.mean_per_class_error(dl_model, train = TRUE, valid = TRUE, xval = TRUE) #&gt; train valid xval #&gt; 0.0214 0.2233 0.1985 The confusion matrix tells us, how many classes have been predicted correctly and how many predictions were accurate. Here, we see the errors in predictions on validation data. h2o.confusionMatrix(dl_model, valid = TRUE) #&gt; Confusion Matrix (vertical: actual; across: predicted) for max f1 @ threshold = 0.000569401470899311: #&gt; arrhythmia healthy Error Rate #&gt; arrhythmia 15 10 0.400000 =10/25 #&gt; healthy 2 41 0.046512 =2/43 #&gt; Totals 17 51 0.176471 =12/68 We can also plot the classification error over all epochs or samples. plot(dl_model, timestep = &quot;epochs&quot;, metric = &quot;classification_error&quot;) plot(dl_model, timestep = &quot;samples&quot;, metric = &quot;classification_error&quot;) Next to the classification error, we are usually interested in the logistic loss (negative log-likelihood or log loss). It describes the sum of errors for each sample in the training or validation data or the negative logarithm of the likelihood of error for a given prediction/ classification. Simply put, the lower the loss, the better the model (if we ignore potential overfitting). plot(dl_model, timestep = &quot;epochs&quot;, metric = &quot;logloss&quot;) We can also plot the mean squared error (MSE). The MSE tells us the average of the prediction errors squared, i.e. the estimator’s variance and bias. The closer to zero, the better a model. plot(dl_model, timestep = &quot;epochs&quot;, metric = &quot;rmse&quot;) Next, we want to know the area under the curve (AUC). AUC is an important metric for measuring binary classification model performances. It gives the area under the curve, i.e. the integral, of true positive vs false positive rates. The closer to 1, the better a model. h2o.auc(dl_model, train = TRUE) #&gt; [1] 0.99 h2o.auc(dl_model, valid = TRUE) #&gt; [1] 0.849 h2o.auc(dl_model, xval = TRUE) #&gt; [1] 0.849 The weights for connecting two adjacent layers and per-neuron biases that we specified the model to save, can be accessed with: w &lt;- h2o.weights(dl_model, matrix_id = 1) b &lt;- h2o.biases(dl_model, vector_id = 1) Variable importance can be extracted as well (but keep in mind, that variable importance in deep neural networks is difficult to assess and should be considered only as rough estimates). h2o.varimp(dl_model) #&gt; Variable Importances: #&gt; variable relative_importance scaled_importance percentage #&gt; 1 V169 1.000000 1.000000 0.014789 #&gt; 2 V239 0.909679 0.909679 0.013454 #&gt; 3 V5 0.895259 0.895259 0.013240 #&gt; 4 V15 0.857806 0.857806 0.012686 #&gt; 5 V103 0.843830 0.843830 0.012480 #&gt; #&gt; --- #&gt; variable relative_importance scaled_importance percentage #&gt; 85 V10 0.672980 0.672980 0.009953 #&gt; 86 V219 0.672928 0.672928 0.009952 #&gt; 87 V218 0.672750 0.672750 0.009950 #&gt; 88 V45 0.671611 0.671611 0.009933 #&gt; 89 V88 0.670450 0.670450 0.009916 #&gt; 90 V33 0.662410 0.662410 0.009797 h2o.varimp_plot(dl_model) 1.7 Test data Now that we have a good idea about model performance on validation data, we want to know how it performed on unseen test data. A good model should find an optimal balance between accuracy on training and test data. A model that has 0% error on the training data but 40% error on the test data is in effect useless. It overfit on the training data and is thus not able to generalize to unknown data. perf &lt;- h2o.performance(dl_model, test) perf #&gt; H2OBinomialMetrics: deeplearning #&gt; #&gt; MSE: 0.26 #&gt; RMSE: 0.51 #&gt; LogLoss: 1.77 #&gt; Mean Per-Class Error: 0.37 #&gt; AUC: 0.783 #&gt; pr_auc: 0.793 #&gt; Gini: 0.567 #&gt; #&gt; Confusion Matrix (vertical: actual; across: predicted) for F1-optimal threshold: #&gt; arrhythmia healthy Error Rate #&gt; arrhythmia 7 20 0.740741 =20/27 #&gt; healthy 0 39 0.000000 =0/39 #&gt; Totals 7 59 0.303030 =20/66 #&gt; #&gt; Maximum Metrics: Maximum metrics at their respective thresholds #&gt; metric threshold value idx #&gt; 1 max f1 0.000001 0.795918 58 #&gt; 2 max f2 0.000001 0.906977 58 #&gt; 3 max f0point5 0.968673 0.808383 31 #&gt; 4 max accuracy 0.968673 0.742424 31 #&gt; 5 max precision 0.995365 1.000000 0 #&gt; 6 max recall 0.000001 1.000000 58 #&gt; 7 max specificity 0.995365 1.000000 0 #&gt; 8 max absolute_mcc 0.968673 0.498899 31 #&gt; 9 max min_per_class_accuracy 0.747400 0.717949 34 #&gt; 10 max mean_per_class_accuracy 0.968673 0.753561 31 #&gt; #&gt; Gains/Lift Table: Extract with `h2o.gainsLift(&lt;model&gt;, &lt;data&gt;)` or `h2o.gainsLift(&lt;model&gt;, valid=&lt;T/F&gt;, xval=&lt;T/F&gt;)` Plotting the test performance’s AUC plot shows us approximately how good the predictions are. plot(perf) We also want to know the log loss, MSE and AUC values, as well as other model metrics for the test data: h2o.logloss(perf) #&gt; [1] 1.77 h2o.mse(perf) #&gt; [1] 0.26 h2o.auc(perf) #&gt; [1] 0.783 head(h2o.metric(perf)) #&gt; Metrics for Thresholds: Binomial metrics as a function of classification thresholds #&gt; threshold f1 f2 f0point5 accuracy precision recall #&gt; 1 0.995365 0.050000 0.031847 0.116279 0.424242 1.000000 0.025641 #&gt; 2 0.994709 0.097561 0.063291 0.212766 0.439394 1.000000 0.051282 #&gt; 3 0.994527 0.142857 0.094340 0.294118 0.454545 1.000000 0.076923 #&gt; 4 0.994181 0.139535 0.093750 0.272727 0.439394 0.750000 0.076923 #&gt; 5 0.993952 0.181818 0.124224 0.338983 0.454545 0.800000 0.102564 #&gt; 6 0.993846 0.222222 0.154321 0.396825 0.469697 0.833333 0.128205 #&gt; specificity absolute_mcc min_per_class_accuracy mean_per_class_accuracy #&gt; 1 1.000000 0.103203 0.025641 0.512821 #&gt; 2 1.000000 0.147087 0.051282 0.525641 #&gt; 3 1.000000 0.181568 0.076923 0.538462 #&gt; 4 0.962963 0.082188 0.076923 0.519943 #&gt; 5 0.962963 0.121754 0.102564 0.532764 #&gt; 6 0.962963 0.155921 0.128205 0.545584 #&gt; tns fns fps tps tnr fnr fpr tpr idx #&gt; 1 27 38 0 1 1.000000 0.974359 0.000000 0.025641 0 #&gt; 2 27 37 0 2 1.000000 0.948718 0.000000 0.051282 1 #&gt; 3 27 36 0 3 1.000000 0.923077 0.000000 0.076923 2 #&gt; 4 26 36 1 3 0.962963 0.923077 0.037037 0.076923 3 #&gt; 5 26 35 1 4 0.962963 0.897436 0.037037 0.102564 4 #&gt; 6 26 34 1 5 0.962963 0.871795 0.037037 0.128205 5 The confusion matrix alone can be seen with the h2o.confusionMatrix() function, but is is also part of the performance summary. h2o.confusionMatrix(dl_model, test) #&gt; Confusion Matrix (vertical: actual; across: predicted) for max f1 @ threshold = 1.28042584465602e-06: #&gt; arrhythmia healthy Error Rate #&gt; arrhythmia 7 20 0.740741 =20/27 #&gt; healthy 0 39 0.000000 =0/39 #&gt; Totals 7 59 0.303030 =20/66 The final predictions with probabilities can be extracted with the h2o.predict() function. Beware though, that the number of correct and wrong classifications can be slightly different from the confusion matrix above. Here, I combine the predictions with the actual test diagnoses and classes into a data frame. For plotting I also want to have a column, that tells me whether the predictions were correct. By default, a prediction probability above 0.5 will get scored as a prediction for the respective category. I find it often makes sense to be more stringent with this, though and set a higher threshold. Therefore, I am creating another column with stringent predictions, where I only count predictions that were made with more than 80% probability. Everything that does not fall within this range gets scored as “uncertain”. For these stringent predictions, I am also creating a column that tells me whether they were accurate. finalRf_predictions &lt;- data.frame(class = as.vector(test$class), actual = as.vector(test$diagnosis), as.data.frame(h2o.predict(object = dl_model, newdata = test))) #&gt; | | | 0% | |=================================================================| 100% finalRf_predictions$accurate &lt;- ifelse( finalRf_predictions$actual == finalRf_predictions$predict, &quot;yes&quot;, &quot;no&quot;) finalRf_predictions$predict_stringent &lt;- ifelse( finalRf_predictions$arrhythmia &gt; 0.8, &quot;arrhythmia&quot;, ifelse(finalRf_predictions$healthy &gt; 0.8, &quot;healthy&quot;, &quot;uncertain&quot;)) finalRf_predictions$accurate_stringent &lt;- ifelse( finalRf_predictions$actual == finalRf_predictions$predict_stringent, &quot;yes&quot;, ifelse(finalRf_predictions$predict_stringent == &quot;uncertain&quot;, &quot;na&quot;, &quot;no&quot;)) finalRf_predictions %&gt;% group_by(actual, predict) %&gt;% summarise(n = n()) #&gt; # A tibble: 4 x 3 #&gt; # Groups: actual [2] #&gt; actual predict n #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; #&gt; 1 arrhythmia arrhythmia 14 #&gt; 2 arrhythmia healthy 13 #&gt; 3 healthy arrhythmia 6 #&gt; 4 healthy healthy 33 finalRf_predictions %&gt;% group_by(actual, predict_stringent) %&gt;% summarise(n = n()) #&gt; # A tibble: 6 x 3 #&gt; # Groups: actual [2] #&gt; actual predict_stringent n #&gt; &lt;fct&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 arrhythmia arrhythmia 17 #&gt; 2 arrhythmia healthy 6 #&gt; 3 arrhythmia uncertain 4 #&gt; 4 healthy arrhythmia 9 #&gt; 5 healthy healthy 27 #&gt; 6 healthy uncertain 3 To get a better overview, I am going to plot the predictions (default and stringent): p1 &lt;- finalRf_predictions %&gt;% ggplot(aes(x = actual, fill = accurate)) + geom_bar(position = &quot;dodge&quot;) + scale_fill_brewer(palette = &quot;Set1&quot;) + my_theme() + labs(fill = &quot;Were\\npredictions\\naccurate?&quot;, title = &quot;Default predictions&quot;) p2 &lt;- finalRf_predictions %&gt;% subset(accurate_stringent != &quot;na&quot;) %&gt;% ggplot(aes(x = actual, fill = accurate_stringent)) + geom_bar(position = &quot;dodge&quot;) + scale_fill_brewer(palette = &quot;Set1&quot;) + my_theme() + labs(fill = &quot;Were\\npredictions\\naccurate?&quot;, title = &quot;Stringent predictions&quot;) grid.arrange(p1, p2, ncol = 2) Being more stringent with the prediction threshold slightly reduced the number of errors but not by much. I also want to know whether there are certain classes of arrhythmia that are especially prone to being misclassified: p1 &lt;- subset(finalRf_predictions, actual == &quot;arrhythmia&quot;) %&gt;% ggplot(aes(x = predict, fill = class)) + geom_bar(position = &quot;dodge&quot;) + my_theme() + labs(title = &quot;Prediction accuracy of arrhythmia cases&quot;, subtitle = &quot;Default predictions&quot;, x = &quot;predicted to be&quot;) p2 &lt;- subset(finalRf_predictions, actual == &quot;arrhythmia&quot;) %&gt;% ggplot(aes(x = predict_stringent, fill = class)) + geom_bar(position = &quot;dodge&quot;) + my_theme() + labs(title = &quot;Prediction accuracy of arrhythmia cases&quot;, subtitle = &quot;Stringent predictions&quot;, x = &quot;predicted to be&quot;) grid.arrange(p1, p2, ncol = 2) There are no obvious biases towards some classes but with the small number of samples for most classes, this is difficult to assess. 1.8 Final conclusions: How useful is the model? Most samples were classified correctly, but the total error was not particularly good. Moreover, when evaluating the usefulness of a specific model, we need to keep in mind what we want to achieve with it and which questions we want to answer. If we wanted to deploy this model in a clinical setting, it should assist with diagnosing patients. So, we need to think about what the consequences of wrong classifications would be. Would it be better to optimize for high sensitivity, in this example as many arrhythmia cases as possible get detected - with the drawback that we probably also diagnose a few healthy people? Or do we want to maximize precision, meaning that we could be confident that a patient who got predicted to have arrhythmia does indeed have it, while accepting that a few arrhythmia cases would remain undiagnosed? When we consider stringent predictions, this model correctly classified 19 out of 27 arrhythmia cases, but 6 were misdiagnosed. This would mean that some patients who were actually sick, wouldn’t have gotten the correct treatment (if decided solely based on this model). For real-life application, this is obviously not sufficient! Next week, I’ll be trying to improve the model by doing a grid search for hyper-parameter tuning. So, stay tuned… (sorry, couldn’t resist ;-)) sessionInfo() #&gt; R version 3.6.0 (2019-04-26) #&gt; Platform: x86_64-pc-linux-gnu (64-bit) #&gt; Running under: Ubuntu 18.04.3 LTS #&gt; #&gt; Matrix products: default #&gt; BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/libopenblasp-r0.2.20.so #&gt; #&gt; locale: #&gt; [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C #&gt; [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 #&gt; [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 #&gt; [7] LC_PAPER=en_US.UTF-8 LC_NAME=C #&gt; [9] LC_ADDRESS=C LC_TELEPHONE=C #&gt; [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C #&gt; #&gt; attached base packages: #&gt; [1] stats4 parallel grid stats graphics grDevices utils #&gt; [8] datasets methods base #&gt; #&gt; other attached packages: #&gt; [1] reshape2_1.4.3 tidyr_0.8.3 matrixStats_0.54.0 #&gt; [4] pcaGoPromoter_1.28.0 Biostrings_2.52.0 XVector_0.24.0 #&gt; [7] IRanges_2.18.0 S4Vectors_0.22.0 BiocGenerics_0.30.0 #&gt; [10] ellipse_0.4.1 gridExtra_2.3 ggrepel_0.8.1 #&gt; [13] ggplot2_3.1.1 h2o_3.22.1.1 dplyr_0.8.0.1 #&gt; [16] logging_0.9-107 #&gt; #&gt; loaded via a namespace (and not attached): #&gt; [1] Rcpp_1.0.1 assertthat_0.2.1 zeallot_0.1.0 #&gt; [4] rprojroot_1.3-2 digest_0.6.18 utf8_1.1.4 #&gt; [7] R6_2.4.0 plyr_1.8.4 backports_1.1.4 #&gt; [10] RSQLite_2.1.1 evaluate_0.13 pillar_1.4.0 #&gt; [13] zlibbioc_1.30.0 rlang_0.3.4 lazyeval_0.2.2 #&gt; [16] rstudioapi_0.10 blob_1.1.1 rmarkdown_1.12 #&gt; [19] labeling_0.3 stringr_1.4.0 RCurl_1.95-4.12 #&gt; [22] bit_1.1-14 munsell_0.5.0 compiler_3.6.0 #&gt; [25] xfun_0.6 pkgconfig_2.0.2 htmltools_0.3.6 #&gt; [28] tidyselect_0.2.5 tibble_2.1.1 bookdown_0.10 #&gt; [31] fansi_0.4.0 crayon_1.3.4 withr_2.1.2 #&gt; [34] bitops_1.0-6 jsonlite_1.6 gtable_0.3.0 #&gt; [37] DBI_1.0.0 magrittr_1.5 scales_1.0.0 #&gt; [40] cli_1.1.0 stringi_1.4.3 vctrs_0.1.0 #&gt; [43] RColorBrewer_1.1-2 tools_3.6.0 bit64_0.9-7 #&gt; [46] Biobase_2.44.0 glue_1.3.1 purrr_0.3.2 #&gt; [49] yaml_2.2.0 AnnotationDbi_1.46.0 colorspace_1.4-1 #&gt; [52] memoise_1.1.0 knitr_1.22 "],
["credit-scoring.html", "Chapter 2 Credit Scoring 2.1 Introduction 2.2 Motivation 2.3 load the data 2.4 Objective 2.5 Steps 2.6 Test the neural network", " Chapter 2 Credit Scoring 2.1 Introduction Source: https://www.r-bloggers.com/using-neural-networks-for-credit-scoring-a-simple-example/ 2.2 Motivation Credit scoring is the practice of analysing a persons background and credit application in order to assess the creditworthiness of the person. One can take numerous approaches on analysing this creditworthiness. In the end it basically comes down to first selecting the correct independent variables (e.g. income, age, gender) that lead to a given level of creditworthiness. In other words: creditworthiness = f(income, age, gender, …). A creditscoring system can be represented by linear regression, logistic regression, machine learning or a combination of these. Neural networks are situated in the domain of machine learning. The following is an strongly simplified example. The actual procedure of building a credit scoring system is much more complex and the resulting model will most likely not consist of solely or even a neural network. If you’re unsure on what a neural network exactly is, I find this a good place to start. For this example the R package neuralnet is used, for a more in-depth view on the exact workings of the package see neuralnet: Training of Neural Networks by F. Günther and S. Fritsch. 2.3 load the data Dataset downloaded: https://gist.github.com/Bart6114/8675941#file-creditset-csv set.seed(1234567890) library(neuralnet) dataset &lt;- read.csv(file.path(data_raw_dir, &quot;creditset.csv&quot;)) head(dataset) #&gt; clientid income age loan LTI default10yr #&gt; 1 1 66156 59.0 8106.5 0.122537 0 #&gt; 2 2 34415 48.1 6564.7 0.190752 0 #&gt; 3 3 57317 63.1 8021.0 0.139940 0 #&gt; 4 4 42710 45.8 6103.6 0.142911 0 #&gt; 5 5 66953 18.6 8770.1 0.130989 1 #&gt; 6 6 24904 57.5 15.5 0.000622 0 names(dataset) #&gt; [1] &quot;clientid&quot; &quot;income&quot; &quot;age&quot; &quot;loan&quot; &quot;LTI&quot; #&gt; [6] &quot;default10yr&quot; summary(dataset) #&gt; clientid income age loan #&gt; Min. : 1 Min. :20014 Min. :18.1 Min. : 1 #&gt; 1st Qu.: 501 1st Qu.:32796 1st Qu.:29.1 1st Qu.: 1940 #&gt; Median :1000 Median :45789 Median :41.4 Median : 3975 #&gt; Mean :1000 Mean :45332 Mean :40.9 Mean : 4444 #&gt; 3rd Qu.:1500 3rd Qu.:57791 3rd Qu.:52.6 3rd Qu.: 6432 #&gt; Max. :2000 Max. :69996 Max. :64.0 Max. :13766 #&gt; LTI default10yr #&gt; Min. :0.0000 Min. :0.000 #&gt; 1st Qu.:0.0479 1st Qu.:0.000 #&gt; Median :0.0994 Median :0.000 #&gt; Mean :0.0984 Mean :0.142 #&gt; 3rd Qu.:0.1476 3rd Qu.:0.000 #&gt; Max. :0.1999 Max. :1.000 # distribution of defaults table(dataset$default10yr) #&gt; #&gt; 0 1 #&gt; 1717 283 min(dataset$LTI) #&gt; [1] 4.91e-05 plot(jitter(dataset$default10yr, 1) ~ jitter(dataset$LTI, 2)) # convert LTI continuous variable to categorical dataset$LTIrng &lt;- cut(dataset$LTI, breaks = 10) unique(dataset$LTIrng) #&gt; [1] (0.12,0.14] (0.18,0.2] (0.14,0.16] (-0.000151,0.02] #&gt; [5] (0.1,0.12] (0.04,0.06] (0.06,0.08] (0.08,0.1] #&gt; [9] (0.16,0.18] (0.02,0.04] #&gt; 10 Levels: (-0.000151,0.02] (0.02,0.04] (0.04,0.06] ... (0.18,0.2] plot(dataset$LTIrng, dataset$default10yr) # what age and LTI is more likely to default library(ggplot2) #&gt; Registered S3 methods overwritten by &#39;ggplot2&#39;: #&gt; method from #&gt; [.quosures rlang #&gt; c.quosures rlang #&gt; print.quosures rlang ggplot(dataset, aes(x = age, y = LTI, col = default10yr)) + geom_point() # what age and loan size is more likely to default library(ggplot2) ggplot(dataset, aes(x = age, y = loan, col = default10yr)) + geom_point() 2.4 Objective The dataset contains information on different clients who received a loan at least 10 years ago. The variables income (yearly), age, loan (size in euros) and LTI (the loan to yearly income ratio) are available. Our goal is to devise a model which predicts, based on the input variables LTI and age, whether or not a default will occur within 10 years. 2.5 Steps The dataset will be split up in a subset used for training the neural network and another set used for testing. As the ordering of the dataset is completely random, we do not have to extract random rows and can just take the first x rows. ## extract a set to train the NN trainset &lt;- dataset[1:800, ] ## select the test set testset &lt;- dataset[801:2000, ] 2.5.1 Build the neural network Now we’ll build a neural network with 4 hidden nodes (a neural network is comprised of an input, hidden and output nodes). The number of nodes is chosen here without a clear method, however there are some rules of thumb. The lifesign option refers to the verbosity. The ouput is not linear and we will use a threshold value of 10%. The neuralnet package uses resilient backpropagation with weight backtracking as its standard algorithm. ## build the neural network (NN) creditnet &lt;- neuralnet(default10yr ~ LTI + age, trainset, hidden = 4, lifesign = &quot;minimal&quot;, linear.output = FALSE, threshold = 0.1) #&gt; hidden: 4 thresh: 0.1 rep: 1/1 steps: 44487 error: 0.20554 time: 10.75 secs The neuralnet package also has the possibility to visualize the generated model and show the found weights. ## plot the NN plot(creditnet, rep = &quot;best&quot;) 2.6 Test the neural network Once we’ve trained the neural network we are ready to test it. We use the testset subset for this. The compute function is applied for computing the outputs based on the LTI and age inputs from the testset. ## test the resulting output temp_test &lt;- subset(testset, select = c(&quot;LTI&quot;, &quot;age&quot;)) creditnet.results &lt;- compute(creditnet, temp_test) The temp dataset contains only the columns LTI and age of the train set. Only these variables are used for input. The set looks as follows: head(temp_test) #&gt; LTI age #&gt; 801 0.0231 25.9 #&gt; 802 0.1373 40.8 #&gt; 803 0.1046 32.5 #&gt; 804 0.1599 53.2 #&gt; 805 0.1116 46.5 #&gt; 806 0.1149 47.1 Let’s have a look at what the neural network produced: results &lt;- data.frame(actual = testset$default10yr, prediction = creditnet.results$net.result) results[100:115, ] #&gt; actual prediction #&gt; 900 0 7.29e-32 #&gt; 901 0 8.17e-11 #&gt; 902 0 4.33e-45 #&gt; 903 1 1.00e+00 #&gt; 904 0 8.06e-04 #&gt; 905 0 3.54e-40 #&gt; 906 0 1.48e-24 #&gt; 907 1 1.00e+00 #&gt; 908 0 1.11e-02 #&gt; 909 0 8.05e-44 #&gt; 910 0 6.72e-07 #&gt; 911 1 1.00e+00 #&gt; 912 0 9.97e-59 #&gt; 913 1 1.00e+00 #&gt; 914 0 3.39e-37 #&gt; 915 0 1.18e-07 We can round to the nearest integer to improve readability: results$prediction &lt;- round(results$prediction) results[100:115, ] #&gt; actual prediction #&gt; 900 0 0 #&gt; 901 0 0 #&gt; 902 0 0 #&gt; 903 1 1 #&gt; 904 0 0 #&gt; 905 0 0 #&gt; 906 0 0 #&gt; 907 1 1 #&gt; 908 0 0 #&gt; 909 0 0 #&gt; 910 0 0 #&gt; 911 1 1 #&gt; 912 0 0 #&gt; 913 1 1 #&gt; 914 0 0 #&gt; 915 0 0 As you can see it is pretty close! As already stated, this is a strongly simplified example. But it might serve as a basis for you to play around with your first neural network. # how many predictions were wrong indices &lt;- which(results$actual != results$prediction) indices #&gt; [1] 330 1008 # what are the predictions that failed results[indices,] #&gt; actual prediction #&gt; 1130 0 1 #&gt; 1808 1 0 "],
["wine-with-neuralnet.html", "Chapter 3 Wine with neuralnet 3.1 The dataset 3.2 Preprocessing 3.3 Fitting the model with neuralnet 3.4 Cross validating the classifier", " Chapter 3 Wine with neuralnet Source: https://www.r-bloggers.com/multilabel-classification-with-neuralnet-package/ The neuralnet package is perhaps not the best option in R for using neural networks. If you ask why, for starters it does not recognize the typical formula y~., it does not support factors, it does not provide a lot of models other than a standard MLP, and it has great competitors in the nnet package that seems to be better integrated in R and can be used with the caret package, and in the MXnet package that is a high level deep learning library which provides a wide variety of neural networks. But still, I think there is some value in the ease of use of the neuralnet package, especially for a beginner, therefore I’ll be using it. I’m going to be using both the neuralnet and, curiously enough, the nnet package. Let’s load them: # load libs require(neuralnet) #&gt; Loading required package: neuralnet require(nnet) #&gt; Loading required package: nnet require(ggplot2) #&gt; Loading required package: ggplot2 #&gt; Registered S3 methods overwritten by &#39;ggplot2&#39;: #&gt; method from #&gt; [.quosures rlang #&gt; c.quosures rlang #&gt; print.quosures rlang set.seed(10) 3.1 The dataset I looked in the UCI Machine Learning Repository1 and found the wine dataset. This dataset contains the results of a chemical analysis on 3 different kind of wines. The target variable is the label of the wine which is a factor with 3 (unordered) levels. The predictors are all continuous and represent 13 variables obtained as a result of chemical measurements. # get the data file from the package location wine_dataset_path &lt;- file.path(data_raw_dir, &quot;wine.data&quot;) wine_dataset_path #&gt; [1] &quot;/home/datascience/repos/machine-learning-rsuite/import/wine.data&quot; wines &lt;- read.csv(wine_dataset_path) wines #&gt; X1 X14.23 X1.71 X2.43 X15.6 X127 X2.8 X3.06 X.28 X2.29 X5.64 X1.04 #&gt; 1 1 13.2 1.78 2.14 11.2 100 2.65 2.76 0.26 1.28 4.38 1.050 #&gt; 2 1 13.2 2.36 2.67 18.6 101 2.80 3.24 0.30 2.81 5.68 1.030 #&gt; 3 1 14.4 1.95 2.50 16.8 113 3.85 3.49 0.24 2.18 7.80 0.860 #&gt; 4 1 13.2 2.59 2.87 21.0 118 2.80 2.69 0.39 1.82 4.32 1.040 #&gt; 5 1 14.2 1.76 2.45 15.2 112 3.27 3.39 0.34 1.97 6.75 1.050 #&gt; 6 1 14.4 1.87 2.45 14.6 96 2.50 2.52 0.30 1.98 5.25 1.020 #&gt; 7 1 14.1 2.15 2.61 17.6 121 2.60 2.51 0.31 1.25 5.05 1.060 #&gt; 8 1 14.8 1.64 2.17 14.0 97 2.80 2.98 0.29 1.98 5.20 1.080 #&gt; 9 1 13.9 1.35 2.27 16.0 98 2.98 3.15 0.22 1.85 7.22 1.010 #&gt; 10 1 14.1 2.16 2.30 18.0 105 2.95 3.32 0.22 2.38 5.75 1.250 #&gt; 11 1 14.1 1.48 2.32 16.8 95 2.20 2.43 0.26 1.57 5.00 1.170 #&gt; 12 1 13.8 1.73 2.41 16.0 89 2.60 2.76 0.29 1.81 5.60 1.150 #&gt; 13 1 14.8 1.73 2.39 11.4 91 3.10 3.69 0.43 2.81 5.40 1.250 #&gt; 14 1 14.4 1.87 2.38 12.0 102 3.30 3.64 0.29 2.96 7.50 1.200 #&gt; 15 1 13.6 1.81 2.70 17.2 112 2.85 2.91 0.30 1.46 7.30 1.280 #&gt; 16 1 14.3 1.92 2.72 20.0 120 2.80 3.14 0.33 1.97 6.20 1.070 #&gt; 17 1 13.8 1.57 2.62 20.0 115 2.95 3.40 0.40 1.72 6.60 1.130 #&gt; 18 1 14.2 1.59 2.48 16.5 108 3.30 3.93 0.32 1.86 8.70 1.230 #&gt; 19 1 13.6 3.10 2.56 15.2 116 2.70 3.03 0.17 1.66 5.10 0.960 #&gt; 20 1 14.1 1.63 2.28 16.0 126 3.00 3.17 0.24 2.10 5.65 1.090 #&gt; 21 1 12.9 3.80 2.65 18.6 102 2.41 2.41 0.25 1.98 4.50 1.030 #&gt; 22 1 13.7 1.86 2.36 16.6 101 2.61 2.88 0.27 1.69 3.80 1.110 #&gt; 23 1 12.8 1.60 2.52 17.8 95 2.48 2.37 0.26 1.46 3.93 1.090 #&gt; 24 1 13.5 1.81 2.61 20.0 96 2.53 2.61 0.28 1.66 3.52 1.120 #&gt; 25 1 13.1 2.05 3.22 25.0 124 2.63 2.68 0.47 1.92 3.58 1.130 #&gt; 26 1 13.4 1.77 2.62 16.1 93 2.85 2.94 0.34 1.45 4.80 0.920 #&gt; 27 1 13.3 1.72 2.14 17.0 94 2.40 2.19 0.27 1.35 3.95 1.020 #&gt; 28 1 13.9 1.90 2.80 19.4 107 2.95 2.97 0.37 1.76 4.50 1.250 #&gt; 29 1 14.0 1.68 2.21 16.0 96 2.65 2.33 0.26 1.98 4.70 1.040 #&gt; 30 1 13.7 1.50 2.70 22.5 101 3.00 3.25 0.29 2.38 5.70 1.190 #&gt; 31 1 13.6 1.66 2.36 19.1 106 2.86 3.19 0.22 1.95 6.90 1.090 #&gt; 32 1 13.7 1.83 2.36 17.2 104 2.42 2.69 0.42 1.97 3.84 1.230 #&gt; 33 1 13.8 1.53 2.70 19.5 132 2.95 2.74 0.50 1.35 5.40 1.250 #&gt; 34 1 13.5 1.80 2.65 19.0 110 2.35 2.53 0.29 1.54 4.20 1.100 #&gt; 35 1 13.5 1.81 2.41 20.5 100 2.70 2.98 0.26 1.86 5.10 1.040 #&gt; 36 1 13.3 1.64 2.84 15.5 110 2.60 2.68 0.34 1.36 4.60 1.090 #&gt; 37 1 13.1 1.65 2.55 18.0 98 2.45 2.43 0.29 1.44 4.25 1.120 #&gt; 38 1 13.1 1.50 2.10 15.5 98 2.40 2.64 0.28 1.37 3.70 1.180 #&gt; 39 1 14.2 3.99 2.51 13.2 128 3.00 3.04 0.20 2.08 5.10 0.890 #&gt; 40 1 13.6 1.71 2.31 16.2 117 3.15 3.29 0.34 2.34 6.13 0.950 #&gt; 41 1 13.4 3.84 2.12 18.8 90 2.45 2.68 0.27 1.48 4.28 0.910 #&gt; 42 1 13.9 1.89 2.59 15.0 101 3.25 3.56 0.17 1.70 5.43 0.880 #&gt; 43 1 13.2 3.98 2.29 17.5 103 2.64 2.63 0.32 1.66 4.36 0.820 #&gt; 44 1 13.1 1.77 2.10 17.0 107 3.00 3.00 0.28 2.03 5.04 0.880 #&gt; 45 1 14.2 4.04 2.44 18.9 111 2.85 2.65 0.30 1.25 5.24 0.870 #&gt; 46 1 14.4 3.59 2.28 16.0 102 3.25 3.17 0.27 2.19 4.90 1.040 #&gt; 47 1 13.9 1.68 2.12 16.0 101 3.10 3.39 0.21 2.14 6.10 0.910 #&gt; 48 1 14.1 2.02 2.40 18.8 103 2.75 2.92 0.32 2.38 6.20 1.070 #&gt; 49 1 13.9 1.73 2.27 17.4 108 2.88 3.54 0.32 2.08 8.90 1.120 #&gt; 50 1 13.1 1.73 2.04 12.4 92 2.72 3.27 0.17 2.91 7.20 1.120 #&gt; 51 1 13.8 1.65 2.60 17.2 94 2.45 2.99 0.22 2.29 5.60 1.240 #&gt; 52 1 13.8 1.75 2.42 14.0 111 3.88 3.74 0.32 1.87 7.05 1.010 #&gt; 53 1 13.8 1.90 2.68 17.1 115 3.00 2.79 0.39 1.68 6.30 1.130 #&gt; 54 1 13.7 1.67 2.25 16.4 118 2.60 2.90 0.21 1.62 5.85 0.920 #&gt; 55 1 13.6 1.73 2.46 20.5 116 2.96 2.78 0.20 2.45 6.25 0.980 #&gt; 56 1 14.2 1.70 2.30 16.3 118 3.20 3.00 0.26 2.03 6.38 0.940 #&gt; 57 1 13.3 1.97 2.68 16.8 102 3.00 3.23 0.31 1.66 6.00 1.070 #&gt; 58 1 13.7 1.43 2.50 16.7 108 3.40 3.67 0.19 2.04 6.80 0.890 #&gt; 59 2 12.4 0.94 1.36 10.6 88 1.98 0.57 0.28 0.42 1.95 1.050 #&gt; 60 2 12.3 1.10 2.28 16.0 101 2.05 1.09 0.63 0.41 3.27 1.250 #&gt; 61 2 12.6 1.36 2.02 16.8 100 2.02 1.41 0.53 0.62 5.75 0.980 #&gt; 62 2 13.7 1.25 1.92 18.0 94 2.10 1.79 0.32 0.73 3.80 1.230 #&gt; 63 2 12.4 1.13 2.16 19.0 87 3.50 3.10 0.19 1.87 4.45 1.220 #&gt; 64 2 12.2 1.45 2.53 19.0 104 1.89 1.75 0.45 1.03 2.95 1.450 #&gt; 65 2 12.4 1.21 2.56 18.1 98 2.42 2.65 0.37 2.08 4.60 1.190 #&gt; 66 2 13.1 1.01 1.70 15.0 78 2.98 3.18 0.26 2.28 5.30 1.120 #&gt; 67 2 12.4 1.17 1.92 19.6 78 2.11 2.00 0.27 1.04 4.68 1.120 #&gt; 68 2 13.3 0.94 2.36 17.0 110 2.53 1.30 0.55 0.42 3.17 1.020 #&gt; 69 2 12.2 1.19 1.75 16.8 151 1.85 1.28 0.14 2.50 2.85 1.280 #&gt; 70 2 12.3 1.61 2.21 20.4 103 1.10 1.02 0.37 1.46 3.05 0.906 #&gt; 71 2 13.9 1.51 2.67 25.0 86 2.95 2.86 0.21 1.87 3.38 1.360 #&gt; 72 2 13.5 1.66 2.24 24.0 87 1.88 1.84 0.27 1.03 3.74 0.980 #&gt; 73 2 13.0 1.67 2.60 30.0 139 3.30 2.89 0.21 1.96 3.35 1.310 #&gt; 74 2 12.0 1.09 2.30 21.0 101 3.38 2.14 0.13 1.65 3.21 0.990 #&gt; 75 2 11.7 1.88 1.92 16.0 97 1.61 1.57 0.34 1.15 3.80 1.230 #&gt; 76 2 13.0 0.90 1.71 16.0 86 1.95 2.03 0.24 1.46 4.60 1.190 #&gt; 77 2 11.8 2.89 2.23 18.0 112 1.72 1.32 0.43 0.95 2.65 0.960 #&gt; 78 2 12.3 0.99 1.95 14.8 136 1.90 1.85 0.35 2.76 3.40 1.060 #&gt; 79 2 12.7 3.87 2.40 23.0 101 2.83 2.55 0.43 1.95 2.57 1.190 #&gt; 80 2 12.0 0.92 2.00 19.0 86 2.42 2.26 0.30 1.43 2.50 1.380 #&gt; 81 2 12.7 1.81 2.20 18.8 86 2.20 2.53 0.26 1.77 3.90 1.160 #&gt; 82 2 12.1 1.13 2.51 24.0 78 2.00 1.58 0.40 1.40 2.20 1.310 #&gt; 83 2 13.1 3.86 2.32 22.5 85 1.65 1.59 0.61 1.62 4.80 0.840 #&gt; 84 2 11.8 0.89 2.58 18.0 94 2.20 2.21 0.22 2.35 3.05 0.790 #&gt; 85 2 12.7 0.98 2.24 18.0 99 2.20 1.94 0.30 1.46 2.62 1.230 #&gt; 86 2 12.2 1.61 2.31 22.8 90 1.78 1.69 0.43 1.56 2.45 1.330 #&gt; 87 2 11.7 1.67 2.62 26.0 88 1.92 1.61 0.40 1.34 2.60 1.360 #&gt; 88 2 11.6 2.06 2.46 21.6 84 1.95 1.69 0.48 1.35 2.80 1.000 #&gt; 89 2 12.1 1.33 2.30 23.6 70 2.20 1.59 0.42 1.38 1.74 1.070 #&gt; 90 2 12.1 1.83 2.32 18.5 81 1.60 1.50 0.52 1.64 2.40 1.080 #&gt; 91 2 12.0 1.51 2.42 22.0 86 1.45 1.25 0.50 1.63 3.60 1.050 #&gt; 92 2 12.7 1.53 2.26 20.7 80 1.38 1.46 0.58 1.62 3.05 0.960 #&gt; 93 2 12.3 2.83 2.22 18.0 88 2.45 2.25 0.25 1.99 2.15 1.150 #&gt; 94 2 11.6 1.99 2.28 18.0 98 3.02 2.26 0.17 1.35 3.25 1.160 #&gt; 95 2 12.5 1.52 2.20 19.0 162 2.50 2.27 0.32 3.28 2.60 1.160 #&gt; 96 2 11.8 2.12 2.74 21.5 134 1.60 0.99 0.14 1.56 2.50 0.950 #&gt; 97 2 12.3 1.41 1.98 16.0 85 2.55 2.50 0.29 1.77 2.90 1.230 #&gt; 98 2 12.4 1.07 2.10 18.5 88 3.52 3.75 0.24 1.95 4.50 1.040 #&gt; 99 2 12.3 3.17 2.21 18.0 88 2.85 2.99 0.45 2.81 2.30 1.420 #&gt; 100 2 12.1 2.08 1.70 17.5 97 2.23 2.17 0.26 1.40 3.30 1.270 #&gt; 101 2 12.6 1.34 1.90 18.5 88 1.45 1.36 0.29 1.35 2.45 1.040 #&gt; 102 2 12.3 2.45 2.46 21.0 98 2.56 2.11 0.34 1.31 2.80 0.800 #&gt; 103 2 11.8 1.72 1.88 19.5 86 2.50 1.64 0.37 1.42 2.06 0.940 #&gt; 104 2 12.5 1.73 1.98 20.5 85 2.20 1.92 0.32 1.48 2.94 1.040 #&gt; 105 2 12.4 2.55 2.27 22.0 90 1.68 1.84 0.66 1.42 2.70 0.860 #&gt; 106 2 12.2 1.73 2.12 19.0 80 1.65 2.03 0.37 1.63 3.40 1.000 #&gt; 107 2 12.7 1.75 2.28 22.5 84 1.38 1.76 0.48 1.63 3.30 0.880 #&gt; 108 2 12.2 1.29 1.94 19.0 92 2.36 2.04 0.39 2.08 2.70 0.860 #&gt; 109 2 11.6 1.35 2.70 20.0 94 2.74 2.92 0.29 2.49 2.65 0.960 #&gt; 110 2 11.5 3.74 1.82 19.5 107 3.18 2.58 0.24 3.58 2.90 0.750 #&gt; 111 2 12.5 2.43 2.17 21.0 88 2.55 2.27 0.26 1.22 2.00 0.900 #&gt; 112 2 11.8 2.68 2.92 20.0 103 1.75 2.03 0.60 1.05 3.80 1.230 #&gt; 113 2 11.4 0.74 2.50 21.0 88 2.48 2.01 0.42 1.44 3.08 1.100 #&gt; 114 2 12.1 1.39 2.50 22.5 84 2.56 2.29 0.43 1.04 2.90 0.930 #&gt; 115 2 11.0 1.51 2.20 21.5 85 2.46 2.17 0.52 2.01 1.90 1.710 #&gt; 116 2 11.8 1.47 1.99 20.8 86 1.98 1.60 0.30 1.53 1.95 0.950 #&gt; 117 2 12.4 1.61 2.19 22.5 108 2.00 2.09 0.34 1.61 2.06 1.060 #&gt; 118 2 12.8 3.43 1.98 16.0 80 1.63 1.25 0.43 0.83 3.40 0.700 #&gt; 119 2 12.0 3.43 2.00 19.0 87 2.00 1.64 0.37 1.87 1.28 0.930 #&gt; 120 2 11.4 2.40 2.42 20.0 96 2.90 2.79 0.32 1.83 3.25 0.800 #&gt; 121 2 11.6 2.05 3.23 28.5 119 3.18 5.08 0.47 1.87 6.00 0.930 #&gt; 122 2 12.4 4.43 2.73 26.5 102 2.20 2.13 0.43 1.71 2.08 0.920 #&gt; 123 2 13.1 5.80 2.13 21.5 86 2.62 2.65 0.30 2.01 2.60 0.730 #&gt; 124 2 11.9 4.31 2.39 21.0 82 2.86 3.03 0.21 2.91 2.80 0.750 #&gt; 125 2 12.1 2.16 2.17 21.0 85 2.60 2.65 0.37 1.35 2.76 0.860 #&gt; 126 2 12.4 1.53 2.29 21.5 86 2.74 3.15 0.39 1.77 3.94 0.690 #&gt; 127 2 11.8 2.13 2.78 28.5 92 2.13 2.24 0.58 1.76 3.00 0.970 #&gt; 128 2 12.4 1.63 2.30 24.5 88 2.22 2.45 0.40 1.90 2.12 0.890 #&gt; 129 2 12.0 4.30 2.38 22.0 80 2.10 1.75 0.42 1.35 2.60 0.790 #&gt; 130 3 12.9 1.35 2.32 18.0 122 1.51 1.25 0.21 0.94 4.10 0.760 #&gt; 131 3 12.9 2.99 2.40 20.0 104 1.30 1.22 0.24 0.83 5.40 0.740 #&gt; 132 3 12.8 2.31 2.40 24.0 98 1.15 1.09 0.27 0.83 5.70 0.660 #&gt; 133 3 12.7 3.55 2.36 21.5 106 1.70 1.20 0.17 0.84 5.00 0.780 #&gt; 134 3 12.5 1.24 2.25 17.5 85 2.00 0.58 0.60 1.25 5.45 0.750 #&gt; 135 3 12.6 2.46 2.20 18.5 94 1.62 0.66 0.63 0.94 7.10 0.730 #&gt; 136 3 12.2 4.72 2.54 21.0 89 1.38 0.47 0.53 0.80 3.85 0.750 #&gt; 137 3 12.5 5.51 2.64 25.0 96 1.79 0.60 0.63 1.10 5.00 0.820 #&gt; 138 3 13.5 3.59 2.19 19.5 88 1.62 0.48 0.58 0.88 5.70 0.810 #&gt; 139 3 12.8 2.96 2.61 24.0 101 2.32 0.60 0.53 0.81 4.92 0.890 #&gt; 140 3 12.9 2.81 2.70 21.0 96 1.54 0.50 0.53 0.75 4.60 0.770 #&gt; 141 3 13.4 2.56 2.35 20.0 89 1.40 0.50 0.37 0.64 5.60 0.700 #&gt; 142 3 13.5 3.17 2.72 23.5 97 1.55 0.52 0.50 0.55 4.35 0.890 #&gt; 143 3 13.6 4.95 2.35 20.0 92 2.00 0.80 0.47 1.02 4.40 0.910 #&gt; 144 3 12.2 3.88 2.20 18.5 112 1.38 0.78 0.29 1.14 8.21 0.650 #&gt; 145 3 13.2 3.57 2.15 21.0 102 1.50 0.55 0.43 1.30 4.00 0.600 #&gt; 146 3 13.9 5.04 2.23 20.0 80 0.98 0.34 0.40 0.68 4.90 0.580 #&gt; 147 3 12.9 4.61 2.48 21.5 86 1.70 0.65 0.47 0.86 7.65 0.540 #&gt; 148 3 13.3 3.24 2.38 21.5 92 1.93 0.76 0.45 1.25 8.42 0.550 #&gt; 149 3 13.1 3.90 2.36 21.5 113 1.41 1.39 0.34 1.14 9.40 0.570 #&gt; 150 3 13.5 3.12 2.62 24.0 123 1.40 1.57 0.22 1.25 8.60 0.590 #&gt; 151 3 12.8 2.67 2.48 22.0 112 1.48 1.36 0.24 1.26 10.80 0.480 #&gt; 152 3 13.1 1.90 2.75 25.5 116 2.20 1.28 0.26 1.56 7.10 0.610 #&gt; 153 3 13.2 3.30 2.28 18.5 98 1.80 0.83 0.61 1.87 10.52 0.560 #&gt; 154 3 12.6 1.29 2.10 20.0 103 1.48 0.58 0.53 1.40 7.60 0.580 #&gt; 155 3 13.2 5.19 2.32 22.0 93 1.74 0.63 0.61 1.55 7.90 0.600 #&gt; 156 3 13.8 4.12 2.38 19.5 89 1.80 0.83 0.48 1.56 9.01 0.570 #&gt; 157 3 12.4 3.03 2.64 27.0 97 1.90 0.58 0.63 1.14 7.50 0.670 #&gt; 158 3 14.3 1.68 2.70 25.0 98 2.80 1.31 0.53 2.70 13.00 0.570 #&gt; 159 3 13.5 1.67 2.64 22.5 89 2.60 1.10 0.52 2.29 11.75 0.570 #&gt; 160 3 12.4 3.83 2.38 21.0 88 2.30 0.92 0.50 1.04 7.65 0.560 #&gt; 161 3 13.7 3.26 2.54 20.0 107 1.83 0.56 0.50 0.80 5.88 0.960 #&gt; 162 3 12.8 3.27 2.58 22.0 106 1.65 0.60 0.60 0.96 5.58 0.870 #&gt; 163 3 13.0 3.45 2.35 18.5 106 1.39 0.70 0.40 0.94 5.28 0.680 #&gt; 164 3 13.8 2.76 2.30 22.0 90 1.35 0.68 0.41 1.03 9.58 0.700 #&gt; 165 3 13.7 4.36 2.26 22.5 88 1.28 0.47 0.52 1.15 6.62 0.780 #&gt; 166 3 13.4 3.70 2.60 23.0 111 1.70 0.92 0.43 1.46 10.68 0.850 #&gt; 167 3 12.8 3.37 2.30 19.5 88 1.48 0.66 0.40 0.97 10.26 0.720 #&gt; 168 3 13.6 2.58 2.69 24.5 105 1.55 0.84 0.39 1.54 8.66 0.740 #&gt; 169 3 13.4 4.60 2.86 25.0 112 1.98 0.96 0.27 1.11 8.50 0.670 #&gt; 170 3 12.2 3.03 2.32 19.0 96 1.25 0.49 0.40 0.73 5.50 0.660 #&gt; 171 3 12.8 2.39 2.28 19.5 86 1.39 0.51 0.48 0.64 9.90 0.570 #&gt; 172 3 14.2 2.51 2.48 20.0 91 1.68 0.70 0.44 1.24 9.70 0.620 #&gt; 173 3 13.7 5.65 2.45 20.5 95 1.68 0.61 0.52 1.06 7.70 0.640 #&gt; 174 3 13.4 3.91 2.48 23.0 102 1.80 0.75 0.43 1.41 7.30 0.700 #&gt; 175 3 13.3 4.28 2.26 20.0 120 1.59 0.69 0.43 1.35 10.20 0.590 #&gt; 176 3 13.2 2.59 2.37 20.0 120 1.65 0.68 0.53 1.46 9.30 0.600 #&gt; 177 3 14.1 4.10 2.74 24.5 96 2.05 0.76 0.56 1.35 9.20 0.610 #&gt; X3.92 X1065 #&gt; 1 3.40 1050 #&gt; 2 3.17 1185 #&gt; 3 3.45 1480 #&gt; 4 2.93 735 #&gt; 5 2.85 1450 #&gt; 6 3.58 1290 #&gt; 7 3.58 1295 #&gt; 8 2.85 1045 #&gt; 9 3.55 1045 #&gt; 10 3.17 1510 #&gt; 11 2.82 1280 #&gt; 12 2.90 1320 #&gt; 13 2.73 1150 #&gt; 14 3.00 1547 #&gt; 15 2.88 1310 #&gt; 16 2.65 1280 #&gt; 17 2.57 1130 #&gt; 18 2.82 1680 #&gt; 19 3.36 845 #&gt; 20 3.71 780 #&gt; 21 3.52 770 #&gt; 22 4.00 1035 #&gt; 23 3.63 1015 #&gt; 24 3.82 845 #&gt; 25 3.20 830 #&gt; 26 3.22 1195 #&gt; 27 2.77 1285 #&gt; 28 3.40 915 #&gt; 29 3.59 1035 #&gt; 30 2.71 1285 #&gt; 31 2.88 1515 #&gt; 32 2.87 990 #&gt; 33 3.00 1235 #&gt; 34 2.87 1095 #&gt; 35 3.47 920 #&gt; 36 2.78 880 #&gt; 37 2.51 1105 #&gt; 38 2.69 1020 #&gt; 39 3.53 760 #&gt; 40 3.38 795 #&gt; 41 3.00 1035 #&gt; 42 3.56 1095 #&gt; 43 3.00 680 #&gt; 44 3.35 885 #&gt; 45 3.33 1080 #&gt; 46 3.44 1065 #&gt; 47 3.33 985 #&gt; 48 2.75 1060 #&gt; 49 3.10 1260 #&gt; 50 2.91 1150 #&gt; 51 3.37 1265 #&gt; 52 3.26 1190 #&gt; 53 2.93 1375 #&gt; 54 3.20 1060 #&gt; 55 3.03 1120 #&gt; 56 3.31 970 #&gt; 57 2.84 1270 #&gt; 58 2.87 1285 #&gt; 59 1.82 520 #&gt; 60 1.67 680 #&gt; 61 1.59 450 #&gt; 62 2.46 630 #&gt; 63 2.87 420 #&gt; 64 2.23 355 #&gt; 65 2.30 678 #&gt; 66 3.18 502 #&gt; 67 3.48 510 #&gt; 68 1.93 750 #&gt; 69 3.07 718 #&gt; 70 1.82 870 #&gt; 71 3.16 410 #&gt; 72 2.78 472 #&gt; 73 3.50 985 #&gt; 74 3.13 886 #&gt; 75 2.14 428 #&gt; 76 2.48 392 #&gt; 77 2.52 500 #&gt; 78 2.31 750 #&gt; 79 3.13 463 #&gt; 80 3.12 278 #&gt; 81 3.14 714 #&gt; 82 2.72 630 #&gt; 83 2.01 515 #&gt; 84 3.08 520 #&gt; 85 3.16 450 #&gt; 86 2.26 495 #&gt; 87 3.21 562 #&gt; 88 2.75 680 #&gt; 89 3.21 625 #&gt; 90 2.27 480 #&gt; 91 2.65 450 #&gt; 92 2.06 495 #&gt; 93 3.30 290 #&gt; 94 2.96 345 #&gt; 95 2.63 937 #&gt; 96 2.26 625 #&gt; 97 2.74 428 #&gt; 98 2.77 660 #&gt; 99 2.83 406 #&gt; 100 2.96 710 #&gt; 101 2.77 562 #&gt; 102 3.38 438 #&gt; 103 2.44 415 #&gt; 104 3.57 672 #&gt; 105 3.30 315 #&gt; 106 3.17 510 #&gt; 107 2.42 488 #&gt; 108 3.02 312 #&gt; 109 3.26 680 #&gt; 110 2.81 562 #&gt; 111 2.78 325 #&gt; 112 2.50 607 #&gt; 113 2.31 434 #&gt; 114 3.19 385 #&gt; 115 2.87 407 #&gt; 116 3.33 495 #&gt; 117 2.96 345 #&gt; 118 2.12 372 #&gt; 119 3.05 564 #&gt; 120 3.39 625 #&gt; 121 3.69 465 #&gt; 122 3.12 365 #&gt; 123 3.10 380 #&gt; 124 3.64 380 #&gt; 125 3.28 378 #&gt; 126 2.84 352 #&gt; 127 2.44 466 #&gt; 128 2.78 342 #&gt; 129 2.57 580 #&gt; 130 1.29 630 #&gt; 131 1.42 530 #&gt; 132 1.36 560 #&gt; 133 1.29 600 #&gt; 134 1.51 650 #&gt; 135 1.58 695 #&gt; 136 1.27 720 #&gt; 137 1.69 515 #&gt; 138 1.82 580 #&gt; 139 2.15 590 #&gt; 140 2.31 600 #&gt; 141 2.47 780 #&gt; 142 2.06 520 #&gt; 143 2.05 550 #&gt; 144 2.00 855 #&gt; 145 1.68 830 #&gt; 146 1.33 415 #&gt; 147 1.86 625 #&gt; 148 1.62 650 #&gt; 149 1.33 550 #&gt; 150 1.30 500 #&gt; 151 1.47 480 #&gt; 152 1.33 425 #&gt; 153 1.51 675 #&gt; 154 1.55 640 #&gt; 155 1.48 725 #&gt; 156 1.64 480 #&gt; 157 1.73 880 #&gt; 158 1.96 660 #&gt; 159 1.78 620 #&gt; 160 1.58 520 #&gt; 161 1.82 680 #&gt; 162 2.11 570 #&gt; 163 1.75 675 #&gt; 164 1.68 615 #&gt; 165 1.75 520 #&gt; 166 1.56 695 #&gt; 167 1.75 685 #&gt; 168 1.80 750 #&gt; 169 1.92 630 #&gt; 170 1.83 510 #&gt; 171 1.63 470 #&gt; 172 1.71 660 #&gt; 173 1.74 740 #&gt; 174 1.56 750 #&gt; 175 1.56 835 #&gt; 176 1.62 840 #&gt; 177 1.60 560 names(wines) &lt;- c(&quot;label&quot;, &quot;Alcohol&quot;, &quot;Malic_acid&quot;, &quot;Ash&quot;, &quot;Alcalinity_of_ash&quot;, &quot;Magnesium&quot;, &quot;Total_phenols&quot;, &quot;Flavanoids&quot;, &quot;Nonflavanoid_phenols&quot;, &quot;Proanthocyanins&quot;, &quot;Color_intensity&quot;, &quot;Hue&quot;, &quot;OD280_OD315_of_diluted_wines&quot;, &quot;Proline&quot;) head(wines) #&gt; label Alcohol Malic_acid Ash Alcalinity_of_ash Magnesium Total_phenols #&gt; 1 1 13.2 1.78 2.14 11.2 100 2.65 #&gt; 2 1 13.2 2.36 2.67 18.6 101 2.80 #&gt; 3 1 14.4 1.95 2.50 16.8 113 3.85 #&gt; 4 1 13.2 2.59 2.87 21.0 118 2.80 #&gt; 5 1 14.2 1.76 2.45 15.2 112 3.27 #&gt; 6 1 14.4 1.87 2.45 14.6 96 2.50 #&gt; Flavanoids Nonflavanoid_phenols Proanthocyanins Color_intensity Hue #&gt; 1 2.76 0.26 1.28 4.38 1.05 #&gt; 2 3.24 0.30 2.81 5.68 1.03 #&gt; 3 3.49 0.24 2.18 7.80 0.86 #&gt; 4 2.69 0.39 1.82 4.32 1.04 #&gt; 5 3.39 0.34 1.97 6.75 1.05 #&gt; 6 2.52 0.30 1.98 5.25 1.02 #&gt; OD280_OD315_of_diluted_wines Proline #&gt; 1 3.40 1050 #&gt; 2 3.17 1185 #&gt; 3 3.45 1480 #&gt; 4 2.93 735 #&gt; 5 2.85 1450 #&gt; 6 3.58 1290 plt1 &lt;- ggplot(wines, aes(x = Alcohol, y = Magnesium, colour = as.factor(label))) + geom_point(size=3) + ggtitle(&quot;Wines&quot;) plt1 plt2 &lt;- ggplot(wines, aes(x = Alcohol, y = Proline, colour = as.factor(label))) + geom_point(size=3) + ggtitle(&quot;Wines&quot;) plt2 3.2 Preprocessing During the preprocessing phase, I have to do at least the following two things: Encode the categorical variables. Standardize the predictors. First of all, let’s encode our target variable. The encoding of the categorical variables is needed when using neuralnet since it does not like factors at all. It will shout at you if you try to feed in a factor (I am told nnet likes factors though). In the wine dataset the variable label contains three different labels: 1,2 and 3. The usual practice, as far as I know, is to encode categorical variables as a “one hot” vector. For instance, if I had three classes, like in this case, I’d need to replace the label variable with three variables like these: # l1,l2,l3 # 1,0,0 # 0,0,1 # ... In this case the first observation would be labelled as a 1, the second would be labelled as a 2, and so on. Ironically, the nnet package provides a function to perform this encoding in a painless way: # Encode as a one hot vector multilabel data train &lt;- cbind(wines[, 2:14], class.ind(as.factor(wines$label))) # Set labels name names(train) &lt;- c(names(wines)[2:14],&quot;l1&quot;,&quot;l2&quot;,&quot;l3&quot;) By the way, since the predictors are all continuous, you do not need to encode any of them, however, in case you needed to, you could apply the same strategy applied above to all the categorical predictors. Unless of course you’d like to try some other kind of custom encoding. Now let’s standardize the predictors in the [0−1]&quot;&gt;[0−1] interval by leveraging the lapply function: # Scale data scl &lt;- function(x) { (x - min(x))/(max(x) - min(x)) } train[, 1:13] &lt;- data.frame(lapply(train[, 1:13], scl)) head(train) #&gt; Alcohol Malic_acid Ash Alcalinity_of_ash Magnesium Total_phenols #&gt; 1 0.571 0.206 0.417 0.0309 0.326 0.576 #&gt; 2 0.561 0.320 0.701 0.4124 0.337 0.628 #&gt; 3 0.879 0.239 0.610 0.3196 0.467 0.990 #&gt; 4 0.582 0.366 0.807 0.5361 0.522 0.628 #&gt; 5 0.834 0.202 0.583 0.2371 0.457 0.790 #&gt; 6 0.884 0.223 0.583 0.2062 0.283 0.524 #&gt; Flavanoids Nonflavanoid_phenols Proanthocyanins Color_intensity Hue #&gt; 1 0.511 0.245 0.274 0.265 0.463 #&gt; 2 0.612 0.321 0.757 0.375 0.447 #&gt; 3 0.665 0.208 0.558 0.556 0.309 #&gt; 4 0.496 0.491 0.445 0.259 0.455 #&gt; 5 0.643 0.396 0.492 0.467 0.463 #&gt; 6 0.460 0.321 0.495 0.339 0.439 #&gt; OD280_OD315_of_diluted_wines Proline l1 l2 l3 #&gt; 1 0.780 0.551 1 0 0 #&gt; 2 0.696 0.647 1 0 0 #&gt; 3 0.799 0.857 1 0 0 #&gt; 4 0.608 0.326 1 0 0 #&gt; 5 0.579 0.836 1 0 0 #&gt; 6 0.846 0.722 1 0 0 3.3 Fitting the model with neuralnet Now it is finally time to fit the model. As you might remember from the old post I wrote, neuralnet does not like the formula y~.. Fear not, you can build the formula to be used in a simple step: # Set up formula n &lt;- names(train) f &lt;- as.formula(paste(&quot;l1 + l2 + l3 ~&quot;, paste(n[!n %in% c(&quot;l1&quot;,&quot;l2&quot;,&quot;l3&quot;)], collapse = &quot; + &quot;))) f #&gt; l1 + l2 + l3 ~ Alcohol + Malic_acid + Ash + Alcalinity_of_ash + #&gt; Magnesium + Total_phenols + Flavanoids + Nonflavanoid_phenols + #&gt; Proanthocyanins + Color_intensity + Hue + OD280_OD315_of_diluted_wines + #&gt; Proline Note that the characters in the vector are not pasted to the right of the “~” symbol. Just remember to check that the formula is indeed correct and then you are good to go. Let’s train the neural network with the full dataset. It should take very little time to converge. If you did not standardize the predictors it could take a lot more though. nn &lt;- neuralnet(f, data = train, hidden = c(13, 10, 3), act.fct = &quot;logistic&quot;, linear.output = FALSE, lifesign = &quot;minimal&quot;) #&gt; hidden: 13, 10, 3 thresh: 0.01 rep: 1/1 steps: 88 error: 0.03039 time: 0.06 secs Note that I set the argument linear.output to FALSE in order to tell the model that I want to apply the activation function act.fct and that I am not doing a regression task. Then I set the activation function to logistic (which by the way is the default option) in order to apply the logistic function. The other available option is tanh but the model seems to perform a little worse with it so I opted for the default option. As far as I know these two are the only two available options, there is no “relu” function available although it seems to be a common activation function in other packages. As far as the number of hidden neurons, I tried some combination and the one used seems to perform slightly better than the others (around 1% of accuracy difference in cross validation score). By using the in-built plot method you can get a visual take on what is actually happening inside the model, however the plot is not that helpful I think plot(nn) Let’s have a look at the accuracy on the training set: # Compute predictions pr.nn &lt;- compute(nn, train[, 1:13]) # Extract results pr.nn_ &lt;- pr.nn$net.result head(pr.nn_) #&gt; [,1] [,2] [,3] #&gt; [1,] 0.990 0.00317 6.99e-06 #&gt; [2,] 0.991 0.00233 8.69e-06 #&gt; [3,] 0.991 0.00210 8.65e-06 #&gt; [4,] 0.986 0.00442 8.74e-06 #&gt; [5,] 0.992 0.00212 8.32e-06 #&gt; [6,] 0.992 0.00214 8.34e-06 # Accuracy (training set) original_values &lt;- max.col(train[, 14:16]) pr.nn_2 &lt;- max.col(pr.nn_) mean(pr.nn_2 == original_values) #&gt; [1] 1 100% not bad! But wait, this may be because our model over fitted the data, furthermore evaluating accuracy on the training set is kind of cheating since the model already “knows” (or should know) the answers. In order to assess the “true accuracy” of the model you need to perform some kind of cross validation. 3.4 Cross validating the classifier Let’s crossvalidate the model using the evergreen 10 fold cross validation with the following train and test split: 95% of the dataset will be used as training set while the remaining 5% as test set. Just out of curiosity I decided to run a LOOCV round too. In case you’d like to run this cross validation technique, just set the proportion variable to 0.995: this will select just one observation for as test set and leave all the other observations as training set. Running LOOCV you should get similar results to the 10 fold cross validation. # Set seed for reproducibility purposes set.seed(500) # 10 fold cross validation k &lt;- 10 # Results from cv outs &lt;- NULL # Train test split proportions proportion &lt;- 0.95 # Set to 0.995 for LOOCV # Crossvalidate, go! for(i in 1:k) { index &lt;- sample(1:nrow(train), round(proportion*nrow(train))) train_cv &lt;- train[index, ] test_cv &lt;- train[-index, ] nn_cv &lt;- neuralnet(f, data = train_cv, hidden = c(13, 10, 3), act.fct = &quot;logistic&quot;, linear.output = FALSE) # Compute predictions pr.nn &lt;- compute(nn_cv, test_cv[, 1:13]) # Extract results pr.nn_ &lt;- pr.nn$net.result # Accuracy (test set) original_values &lt;- max.col(test_cv[, 14:16]) pr.nn_2 &lt;- max.col(pr.nn_) outs[i] &lt;- mean(pr.nn_2 == original_values) } mean(outs) #&gt; [1] 0.978 98.8%, awesome! Next time when you are invited to a relaxing evening that includes a wine tasting competition I think you should definitely bring your laptop as a contestant! Aside from that poor taste joke, (I made it again!), indeed this dataset is not the most challenging, I think with some more tweaking a better cross validation score could be achieved. Nevertheless I hope you found this tutorial useful. A gist with the entire code for this tutorial can be found here. Thank you for reading this article, please feel free to leave a comment if you have any questions or suggestions and share the post with others if you find it useful. Notes: "],
["build-a-fully-connected-neural-network-from-scratch.html", "Chapter 4 Build a fully connected neural network from scratch 4.1 Introduction", " Chapter 4 Build a fully connected neural network from scratch 4.1 Introduction http://www.parallelr.com/r-deep-neural-network-from-scratch/ library(neuralnet) # Copyright 2016: www.ParallelR.com # Parallel Blog : R For Deep Learning (I): Build Fully Connected Neural Network From Scratch # Classification by 2-layers DNN and tested by iris dataset # Author: Peng Zhao, patric.zhao@gmail.com # Prediction predict.dnn &lt;- function(model, data = X.test) { # new data, transfer to matrix new.data &lt;- data.matrix(data) # Feed Forwad hidden.layer &lt;- sweep(new.data %*% model$W1 ,2, model$b1, &#39;+&#39;) # neurons : Rectified Linear hidden.layer &lt;- pmax(hidden.layer, 0) score &lt;- sweep(hidden.layer %*% model$W2, 2, model$b2, &#39;+&#39;) # Loss Function: softmax score.exp &lt;- exp(score) probs &lt;-sweep(score.exp, 1, rowSums(score.exp), &#39;/&#39;) # select max possiblity labels.predicted &lt;- max.col(probs) return(labels.predicted) } # Train: build and train a 2-layers neural network train.dnn &lt;- function(x, y, traindata=data, testdata=NULL, model = NULL, # set hidden layers and neurons # currently, only support 1 hidden layer hidden=c(6), # max iteration steps maxit=2000, # delta loss abstol=1e-2, # learning rate lr = 1e-2, # regularization rate reg = 1e-3, # show results every &#39;display&#39; step display = 100, random.seed = 1) { # to make the case reproducible. set.seed(random.seed) # total number of training set N &lt;- nrow(traindata) # extract the data and label # don&#39;t need atribute X &lt;- unname(data.matrix(traindata[,x])) # correct categories represented by integer Y &lt;- traindata[,y] if(is.factor(Y)) { Y &lt;- as.integer(Y) } # create index for both row and col # create index for both row and col Y.len &lt;- length(unique(Y)) Y.set &lt;- sort(unique(Y)) Y.index &lt;- cbind(1:N, match(Y, Y.set)) # create model or get model from parameter if(is.null(model)) { # number of input features D &lt;- ncol(X) # number of categories for classification K &lt;- length(unique(Y)) H &lt;- hidden # create and init weights and bias W1 &lt;- 0.01*matrix(rnorm(D*H), nrow=D, ncol=H) b1 &lt;- matrix(0, nrow=1, ncol=H) W2 &lt;- 0.01*matrix(rnorm(H*K), nrow=H, ncol=K) b2 &lt;- matrix(0, nrow=1, ncol=K) } else { D &lt;- model$D K &lt;- model$K H &lt;- model$H W1 &lt;- model$W1 b1 &lt;- model$b1 W2 &lt;- model$W2 b2 &lt;- model$b2 } # use all train data to update weights since it&#39;s a small dataset batchsize &lt;- N # init loss to a very big value loss &lt;- 100000 # Training the network i &lt;- 0 while(i &lt; maxit &amp;&amp; loss &gt; abstol ) { # iteration index i &lt;- i +1 # forward .... # 1 indicate row, 2 indicate col hidden.layer &lt;- sweep(X %*% W1 ,2, b1, &#39;+&#39;) # neurons : ReLU hidden.layer &lt;- pmax(hidden.layer, 0) score &lt;- sweep(hidden.layer %*% W2, 2, b2, &#39;+&#39;) # softmax score.exp &lt;- exp(score) # debug probs &lt;- score.exp/rowSums(score.exp) # compute the loss corect.logprobs &lt;- -log(probs[Y.index]) data.loss &lt;- sum(corect.logprobs)/batchsize reg.loss &lt;- 0.5*reg* (sum(W1*W1) + sum(W2*W2)) loss &lt;- data.loss + reg.loss # display results and update model if( i %% display == 0) { if(!is.null(testdata)) { model &lt;- list( D = D, H = H, K = K, # weights and bias W1 = W1, b1 = b1, W2 = W2, b2 = b2) labs &lt;- predict.dnn(model, testdata[,-y]) accuracy &lt;- mean(as.integer(testdata[,y]) == Y.set[labs]) cat(i, loss, accuracy, &quot;\\n&quot;) } else { cat(i, loss, &quot;\\n&quot;) } } # backward .... dscores &lt;- probs dscores[Y.index] &lt;- dscores[Y.index] -1 dscores &lt;- dscores / batchsize dW2 &lt;- t(hidden.layer) %*% dscores db2 &lt;- colSums(dscores) dhidden &lt;- dscores %*% t(W2) dhidden[hidden.layer &lt;= 0] &lt;- 0 dW1 &lt;- t(X) %*% dhidden db1 &lt;- colSums(dhidden) # update .... dW2 &lt;- dW2 + reg*W2 dW1 &lt;- dW1 + reg*W1 W1 &lt;- W1 - lr * dW1 b1 &lt;- b1 - lr * db1 W2 &lt;- W2 - lr * dW2 b2 &lt;- b2 - lr * db2 } # final results # creat list to store learned parameters # you can add more parameters for debug and visualization # such as residuals, fitted.values ... model &lt;- list( D = D, H = H, K = K, # weights and bias W1= W1, b1= b1, W2= W2, b2= b2) return(model) } ######################################################################## # testing ####################################################################### set.seed(1) # 0. EDA summary(iris) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; Min. :4.30 Min. :2.00 Min. :1.00 Min. :0.1 #&gt; 1st Qu.:5.10 1st Qu.:2.80 1st Qu.:1.60 1st Qu.:0.3 #&gt; Median :5.80 Median :3.00 Median :4.35 Median :1.3 #&gt; Mean :5.84 Mean :3.06 Mean :3.76 Mean :1.2 #&gt; 3rd Qu.:6.40 3rd Qu.:3.30 3rd Qu.:5.10 3rd Qu.:1.8 #&gt; Max. :7.90 Max. :4.40 Max. :6.90 Max. :2.5 #&gt; Species #&gt; setosa :50 #&gt; versicolor:50 #&gt; virginica :50 #&gt; #&gt; #&gt; plot(iris) # 1. split data into test/train samp &lt;- c(sample(1:50,25), sample(51:100,25), sample(101:150,25)) # 2. train model ir.model &lt;- train.dnn(x=1:4, y=5, traindata=iris[samp,], testdata=iris[-samp,], hidden=10, maxit=2000, display=50) #&gt; 50 1.1 0.333 #&gt; 100 1.1 0.333 #&gt; 150 1.09 0.333 #&gt; 200 1.08 0.333 #&gt; 250 1.05 0.333 #&gt; 300 1 0.333 #&gt; 350 0.933 0.667 #&gt; 400 0.855 0.667 #&gt; 450 0.775 0.667 #&gt; 500 0.689 0.667 #&gt; 550 0.611 0.68 #&gt; 600 0.552 0.693 #&gt; 650 0.507 0.747 #&gt; 700 0.473 0.84 #&gt; 750 0.445 0.88 #&gt; 800 0.421 0.92 #&gt; 850 0.399 0.947 #&gt; 900 0.379 0.96 #&gt; 950 0.36 0.96 #&gt; 1000 0.341 0.973 #&gt; 1050 0.324 0.973 #&gt; 1100 0.307 0.973 #&gt; 1150 0.292 0.973 #&gt; 1200 0.277 0.973 #&gt; 1250 0.263 0.973 #&gt; 1300 0.25 0.973 #&gt; 1350 0.238 0.973 #&gt; 1400 0.227 0.973 #&gt; 1450 0.216 0.973 #&gt; 1500 0.207 0.973 #&gt; 1550 0.198 0.973 #&gt; 1600 0.19 0.973 #&gt; 1650 0.183 0.973 #&gt; 1700 0.176 0.973 #&gt; 1750 0.17 0.973 #&gt; 1800 0.164 0.973 #&gt; 1850 0.158 0.973 #&gt; 1900 0.153 0.973 #&gt; 1950 0.149 0.973 #&gt; 2000 0.144 0.973 # ir.model &lt;- train.dnn(x=1:4, y=5, traindata=iris[samp,], hidden=6, maxit=2000, display=50) # 3. prediction # NOTE: if the predict is factor, we need to transfer the number into class manually. # To make the code clear, I don&#39;t write this change into predict.dnn function. labels.dnn &lt;- predict.dnn(ir.model, iris[-samp, -5]) # 4. verify the results table(iris[-samp,5], labels.dnn) #&gt; labels.dnn #&gt; 1 2 3 #&gt; setosa 25 0 0 #&gt; versicolor 0 23 2 #&gt; virginica 0 0 25 # labels.dnn # 1 2 3 #setosa 25 0 0 #versicolor 0 24 1 #virginica 0 0 25 #accuracy mean(as.integer(iris[-samp, 5]) == labels.dnn) #&gt; [1] 0.973 # 0.98 # 5. compare with nnet library(nnet) ird &lt;- data.frame(rbind(iris3[,,1], iris3[,,2], iris3[,,3]), species = factor(c(rep(&quot;s&quot;,50), rep(&quot;c&quot;, 50), rep(&quot;v&quot;, 50)))) ir.nn2 &lt;- nnet(species ~ ., data = ird, subset = samp, size = 6, rang = 0.1, decay = 1e-2, maxit = 2000) #&gt; # weights: 51 #&gt; initial value 82.293110 #&gt; iter 10 value 29.196376 #&gt; iter 20 value 5.446284 #&gt; iter 30 value 4.782022 #&gt; iter 40 value 4.379729 #&gt; iter 50 value 4.188725 #&gt; iter 60 value 4.120587 #&gt; iter 70 value 4.091706 #&gt; iter 80 value 4.086017 #&gt; iter 90 value 4.081664 #&gt; iter 100 value 4.074111 #&gt; iter 110 value 4.072894 #&gt; iter 120 value 4.069011 #&gt; iter 130 value 4.067690 #&gt; iter 140 value 4.067633 #&gt; final value 4.067633 #&gt; converged labels.nnet &lt;- predict(ir.nn2, ird[-samp,], type=&quot;class&quot;) table(ird$species[-samp], labels.nnet) #&gt; labels.nnet #&gt; c s v #&gt; c 23 0 2 #&gt; s 0 25 0 #&gt; v 0 0 25 # labels.nnet # c s v #c 22 0 3 #s 0 25 0 #v 3 0 22 # accuracy mean(ird$species[-samp] == labels.nnet) #&gt; [1] 0.973 # 0.96 # Visualization # the output from screen, copy and paste here. data1 &lt;- (&quot;i loss accuracy 50 1.098421 0.3333333 100 1.098021 0.3333333 150 1.096843 0.3333333 200 1.093393 0.3333333 250 1.084069 0.3333333 300 1.063278 0.3333333 350 1.027273 0.3333333 400 0.9707605 0.64 450 0.8996356 0.6666667 500 0.8335469 0.6666667 550 0.7662386 0.6666667 600 0.6914156 0.6666667 650 0.6195753 0.68 700 0.5620381 0.68 750 0.5184008 0.7333333 800 0.4844815 0.84 850 0.4568258 0.8933333 900 0.4331083 0.92 950 0.4118948 0.9333333 1000 0.392368 0.96 1050 0.3740457 0.96 1100 0.3566594 0.96 1150 0.3400993 0.9866667 1200 0.3243276 0.9866667 1250 0.3093422 0.9866667 1300 0.2951787 0.9866667 1350 0.2818472 0.9866667 1400 0.2693641 0.9866667 1450 0.2577245 0.9866667 1500 0.2469068 0.9866667 1550 0.2368819 0.9866667 1600 0.2276124 0.9866667 1650 0.2190535 0.9866667 1700 0.2111565 0.9866667 1750 0.2038719 0.9866667 1800 0.1971507 0.9866667 1850 0.1909452 0.9866667 1900 0.1852105 0.9866667 1950 0.1799045 0.9866667 2000 0.1749881 0.9866667 &quot;) data.v &lt;- read.table(text=data1, header=T) par(mar=c(5.1, 4.1, 4.1, 4.1)) plot(x=data.v$i, y=data.v$loss, type=&quot;o&quot;, col=&quot;blue&quot;, pch=16, main=&quot;IRIS loss and accuracy by 2-layers DNN&quot;, ylim=c(0, 1.2), xlab=&quot;&quot;, ylab=&quot;&quot;, axe =F) lines(x=data.v$i, y=data.v$accuracy, type=&quot;o&quot;, col=&quot;red&quot;, pch=1) box() axis(1, at=seq(0,2000,by=200)) axis(4, at=seq(0,1.0,by=0.1)) axis(2, at=seq(0,1.2,by=0.1)) mtext(&quot;training step&quot;, 1, line=3) mtext(&quot;loss of training set&quot;, 2, line=2.5) mtext(&quot;accuracy of testing set&quot;, 4, line=2) legend(&quot;bottomleft&quot;, legend = c(&quot;loss&quot;, &quot;accuracy&quot;), pch = c(16,1), col = c(&quot;blue&quot;,&quot;red&quot;), lwd=c(1,1) ) "],
["classification-and-regression-with-h2o-deep-learning.html", "Chapter 5 Classification and Regression with H2O Deep Learning 5.1 Introduction 5.2 H2O R Package 5.3 Start H2O 5.4 Let’s have some fun first: Decision Boundaries 5.5 Cover Type Dataset 5.6 Regression and Binary Classification 5.7 Unsupervised Anomaly detection 5.8 H2O Deep Learning Tips &amp; Tricks 5.9 All done, shutdown H2O", " Chapter 5 Classification and Regression with H2O Deep Learning 5.1 Introduction Source: http://docs.h2o.ai/h2o-tutorials/latest-stable/tutorials/deeplearning/index.html Repo: https://github.com/h2oai/h2o-tutorials This tutorial shows how a H2O Deep Learning model can be used to do supervised classification and regression. A great tutorial about Deep Learning is given by Quoc Le here and here. This tutorial covers usage of H2O from R. A python version of this tutorial will be available as well in a separate document. This file is available in plain R, R markdown and regular markdown formats, and the plots are available as PDF files. All documents are available on Github. If run from plain R, execute R in the directory of this script. If run from RStudio, be sure to setwd() to the location of this script.h2o.init() starts H2O in R’s current working directory. h2o.importFile() looks for files from the perspective of where H2O was started. More examples and explanations can be found in our H2O Deep Learning booklet and on our H2O Github Repository. The PDF slide deck can be found on Github. 5.2 H2O R Package Load the H2O R package: Source: http://docs.h2o.ai/h2o-tutorials/latest-stable/tutorials/deeplearning/index.html ## R installation instructions are at http://h2o.ai/download library(h2o) #&gt; #&gt; ---------------------------------------------------------------------- #&gt; #&gt; Your next step is to start H2O: #&gt; &gt; h2o.init() #&gt; #&gt; For H2O package documentation, ask for help: #&gt; &gt; ??h2o #&gt; #&gt; After starting H2O, you can use the Web UI at http://localhost:54321 #&gt; For more information visit http://docs.h2o.ai #&gt; #&gt; ---------------------------------------------------------------------- #&gt; #&gt; Attaching package: &#39;h2o&#39; #&gt; The following objects are masked from &#39;package:stats&#39;: #&gt; #&gt; cor, sd, var #&gt; The following objects are masked from &#39;package:base&#39;: #&gt; #&gt; &amp;&amp;, %*%, %in%, ||, apply, as.factor, as.numeric, colnames, #&gt; colnames&lt;-, ifelse, is.character, is.factor, is.numeric, log, #&gt; log10, log1p, log2, round, signif, trunc 5.3 Start H2O Start up a 1-node H2O server on your local machine, and allow it to use all CPU cores and up to 2GB of memory: h2o.init(nthreads=-1, max_mem_size=&quot;2G&quot;) #&gt; #&gt; H2O is not running yet, starting it now... #&gt; #&gt; Note: In case of errors look at the following log files: #&gt; /tmp/RtmpPNYLxd/h2o_datascience_started_from_r.out #&gt; /tmp/RtmpPNYLxd/h2o_datascience_started_from_r.err #&gt; #&gt; #&gt; Starting H2O JVM and connecting: . Connection successful! #&gt; #&gt; R is connected to the H2O cluster: #&gt; H2O cluster uptime: 1 seconds 239 milliseconds #&gt; H2O cluster timezone: America/Chicago #&gt; H2O data parsing timezone: UTC #&gt; H2O cluster version: 3.22.1.1 #&gt; H2O cluster version age: 8 months and 21 days !!! #&gt; H2O cluster name: H2O_started_from_R_datascience_mwl453 #&gt; H2O cluster total nodes: 1 #&gt; H2O cluster total memory: 1.78 GB #&gt; H2O cluster total cores: 8 #&gt; H2O cluster allowed cores: 8 #&gt; H2O cluster healthy: TRUE #&gt; H2O Connection ip: localhost #&gt; H2O Connection port: 54321 #&gt; H2O Connection proxy: NA #&gt; H2O Internal Security: FALSE #&gt; H2O API Extensions: XGBoost, Algos, AutoML, Core V3, Core V4 #&gt; R Version: R version 3.6.0 (2019-04-26) #&gt; Warning in h2o.clusterInfo(): #&gt; Your H2O cluster version is too old (8 months and 21 days)! #&gt; Please download and install the latest version from http://h2o.ai/download/ h2o.removeAll() ## clean slate - just in case the cluster was already running #&gt; [1] 0 The h2o.deeplearning function fits H2O’s Deep Learning models from within R. We can run the example from the man page using the example function, or run a longer demonstration from the h2o package using the demo function:: args(h2o.deeplearning) #&gt; function (x, y, training_frame, model_id = NULL, validation_frame = NULL, #&gt; nfolds = 0, keep_cross_validation_models = TRUE, keep_cross_validation_predictions = FALSE, #&gt; keep_cross_validation_fold_assignment = FALSE, fold_assignment = c(&quot;AUTO&quot;, #&gt; &quot;Random&quot;, &quot;Modulo&quot;, &quot;Stratified&quot;), fold_column = NULL, #&gt; ignore_const_cols = TRUE, score_each_iteration = FALSE, weights_column = NULL, #&gt; offset_column = NULL, balance_classes = FALSE, class_sampling_factors = NULL, #&gt; max_after_balance_size = 5, max_hit_ratio_k = 0, checkpoint = NULL, #&gt; pretrained_autoencoder = NULL, overwrite_with_best_model = TRUE, #&gt; use_all_factor_levels = TRUE, standardize = TRUE, activation = c(&quot;Tanh&quot;, #&gt; &quot;TanhWithDropout&quot;, &quot;Rectifier&quot;, &quot;RectifierWithDropout&quot;, #&gt; &quot;Maxout&quot;, &quot;MaxoutWithDropout&quot;), hidden = c(200, 200), #&gt; epochs = 10, train_samples_per_iteration = -2, target_ratio_comm_to_comp = 0.05, #&gt; seed = -1, adaptive_rate = TRUE, rho = 0.99, epsilon = 1e-08, #&gt; rate = 0.005, rate_annealing = 1e-06, rate_decay = 1, momentum_start = 0, #&gt; momentum_ramp = 1e+06, momentum_stable = 0, nesterov_accelerated_gradient = TRUE, #&gt; input_dropout_ratio = 0, hidden_dropout_ratios = NULL, l1 = 0, #&gt; l2 = 0, max_w2 = 3.4028235e+38, initial_weight_distribution = c(&quot;UniformAdaptive&quot;, #&gt; &quot;Uniform&quot;, &quot;Normal&quot;), initial_weight_scale = 1, initial_weights = NULL, #&gt; initial_biases = NULL, loss = c(&quot;Automatic&quot;, &quot;CrossEntropy&quot;, #&gt; &quot;Quadratic&quot;, &quot;Huber&quot;, &quot;Absolute&quot;, &quot;Quantile&quot;), distribution = c(&quot;AUTO&quot;, #&gt; &quot;bernoulli&quot;, &quot;multinomial&quot;, &quot;gaussian&quot;, &quot;poisson&quot;, &quot;gamma&quot;, #&gt; &quot;tweedie&quot;, &quot;laplace&quot;, &quot;quantile&quot;, &quot;huber&quot;), quantile_alpha = 0.5, #&gt; tweedie_power = 1.5, huber_alpha = 0.9, score_interval = 5, #&gt; score_training_samples = 10000, score_validation_samples = 0, #&gt; score_duty_cycle = 0.1, classification_stop = 0, regression_stop = 1e-06, #&gt; stopping_rounds = 5, stopping_metric = c(&quot;AUTO&quot;, &quot;deviance&quot;, #&gt; &quot;logloss&quot;, &quot;MSE&quot;, &quot;RMSE&quot;, &quot;MAE&quot;, &quot;RMSLE&quot;, &quot;AUC&quot;, &quot;lift_top_group&quot;, #&gt; &quot;misclassification&quot;, &quot;mean_per_class_error&quot;, &quot;custom&quot;, #&gt; &quot;custom_increasing&quot;), stopping_tolerance = 0, max_runtime_secs = 0, #&gt; score_validation_sampling = c(&quot;Uniform&quot;, &quot;Stratified&quot;), diagnostics = TRUE, #&gt; fast_mode = TRUE, force_load_balance = TRUE, variable_importances = TRUE, #&gt; replicate_training_data = TRUE, single_node_mode = FALSE, #&gt; shuffle_training_data = FALSE, missing_values_handling = c(&quot;MeanImputation&quot;, #&gt; &quot;Skip&quot;), quiet_mode = FALSE, autoencoder = FALSE, sparse = FALSE, #&gt; col_major = FALSE, average_activation = 0, sparsity_beta = 0, #&gt; max_categorical_features = 2147483647, reproducible = FALSE, #&gt; export_weights_and_biases = FALSE, mini_batch_size = 1, categorical_encoding = c(&quot;AUTO&quot;, #&gt; &quot;Enum&quot;, &quot;OneHotInternal&quot;, &quot;OneHotExplicit&quot;, &quot;Binary&quot;, #&gt; &quot;Eigen&quot;, &quot;LabelEncoder&quot;, &quot;SortByResponse&quot;, &quot;EnumLimited&quot;), #&gt; elastic_averaging = FALSE, elastic_averaging_moving_rate = 0.9, #&gt; elastic_averaging_regularization = 0.001, export_checkpoints_dir = NULL, #&gt; verbose = FALSE) #&gt; NULL if (interactive()) help(h2o.deeplearning) example(h2o.deeplearning) #&gt; #&gt; h2.dpl&gt; ## No test: #&gt; h2.dpl&gt; ##D library(h2o) #&gt; h2.dpl&gt; ##D h2o.init() #&gt; h2.dpl&gt; ##D iris_hf &lt;- as.h2o(iris) #&gt; h2.dpl&gt; ##D iris_dl &lt;- h2o.deeplearning(x = 1:4, y = 5, training_frame = iris_hf, seed=123456) #&gt; h2.dpl&gt; ##D #&gt; h2.dpl&gt; ##D # now make a prediction #&gt; h2.dpl&gt; ##D predictions &lt;- h2o.predict(iris_dl, iris_hf) #&gt; h2.dpl&gt; ## End(No test) #&gt; h2.dpl&gt; #&gt; h2.dpl&gt; #&gt; h2.dpl&gt; if (interactive()) demo(h2o.deeplearning) #requires user interaction While H2O Deep Learning has many parameters, it was designed to be just as easy to use as the other supervised training methods in H2O. Early stopping, automatic data standardization and handling of categorical variables and missing values and adaptive learning rates (per weight) reduce the amount of parameters the user has to specify. Often, it’s just the number and sizes of hidden layers, the number of epochs and the activation function and maybe some regularization techniques. 5.4 Let’s have some fun first: Decision Boundaries We start with a small dataset representing red and black dots on a plane, arranged in the shape of two nested spirals. Then we task H2O’s machine learning methods to separate the red and black dots, i.e., recognize each spiral as such by assigning each point in the plane to one of the two spirals. We visualize the nature of H2O Deep Learning (DL), H2O’s tree methods (GBM/DRF) and H2O’s generalized linear modeling (GLM) by plotting the decision boundary between the red and black spirals: # setwd(&quot;~/h2o-tutorials/tutorials/deeplearning&quot;) ##For RStudio spiral &lt;- h2o.importFile(path = normalizePath(file.path(data_raw_dir, &quot;spiral.csv&quot;))) #&gt; | | | 0% | |=================================================================| 100% grid &lt;- h2o.importFile(path = normalizePath(file.path(data_raw_dir, &quot;grid.csv&quot;))) #&gt; | | | 0% | |=================================================================| 100% # Define helper to plot contours plotC &lt;- function(name, model, data=spiral, g=grid) { data &lt;- as.data.frame(data) #get data from into R pred &lt;- as.data.frame(h2o.predict(model, g)) n=0.5*(sqrt(nrow(g))-1); d &lt;- 1.5; h &lt;- d*(-n:n)/n plot(data[,-3],pch=19,col=data[,3],cex=0.5, xlim=c(-d,d),ylim=c(-d,d),main=name) contour(h,h,z=array(ifelse(pred[,1]==&quot;Red&quot;,0,1), dim=c(2*n+1,2*n+1)),col=&quot;blue&quot;,lwd=2,add=T) } We build a few different models: #dev.new(noRStudioGD=FALSE) #direct plotting output to a new window par(mfrow=c(2,2)) #set up the canvas for 2x2 plots plotC( &quot;DL&quot;, h2o.deeplearning(1:2,3,spiral,epochs=1e3)) plotC(&quot;GBM&quot;, h2o.gbm (1:2,3,spiral)) plotC(&quot;DRF&quot;, h2o.randomForest(1:2,3,spiral)) plotC(&quot;GLM&quot;, h2o.glm (1:2,3,spiral,family=&quot;binomial&quot;)) Let’s investigate some more Deep Learning models. First, we explore the evolution over training time (number of passes over the data), and we use checkpointing to continue training the same model: #dev.new(noRStudioGD=FALSE) #direct plotting output to a new window par(mfrow=c(2,2)) #set up the canvas for 2x2 plots ep &lt;- c(1,250,500,750) plotC(paste0(&quot;DL &quot;,ep[1],&quot; epochs&quot;), h2o.deeplearning(1:2,3,spiral,epochs=ep[1], model_id=&quot;dl_1&quot;)) plotC(paste0(&quot;DL &quot;,ep[2],&quot; epochs&quot;), h2o.deeplearning(1:2,3,spiral,epochs=ep[2], checkpoint=&quot;dl_1&quot;,model_id=&quot;dl_2&quot;)) plotC(paste0(&quot;DL &quot;,ep[3],&quot; epochs&quot;), h2o.deeplearning(1:2,3,spiral,epochs=ep[3], checkpoint=&quot;dl_2&quot;,model_id=&quot;dl_3&quot;)) plotC(paste0(&quot;DL &quot;,ep[4],&quot; epochs&quot;), h2o.deeplearning(1:2,3,spiral,epochs=ep[4], checkpoint=&quot;dl_3&quot;,model_id=&quot;dl_4&quot;)) You can see how the network learns the structure of the spirals with enough training time. We explore different network architectures next: #dev.new(noRStudioGD=FALSE) #direct plotting output to a new window par(mfrow=c(2,2)) #set up the canvas for 2x2 plots for (hidden in list(c(11,13,17,19),c(42,42,42),c(200,200),c(1000))) { plotC(paste0(&quot;DL hidden=&quot;,paste0(hidden, collapse=&quot;x&quot;)), h2o.deeplearning(1:2,3 ,spiral, hidden=hidden, epochs=500)) } It is clear that different configurations can achieve similar performance, and that tuning will be required for optimal performance. Next, we compare between different activation functions, including one with 50% dropout regularization in the hidden layers: #dev.new(noRStudioGD=FALSE) #direct plotting output to a new window par(mfrow=c(2,2)) #set up the canvas for 2x2 plots for (act in c(&quot;Tanh&quot;, &quot;Maxout&quot;, &quot;Rectifier&quot;, &quot;RectifierWithDropout&quot;)) { plotC(paste0(&quot;DL &quot;,act,&quot; activation&quot;), h2o.deeplearning(1:2,3, spiral, activation = act, hidden = c(100,100), epochs = 1000)) } Clearly, the dropout rate was too high or the number of epochs was too low for the last configuration, which often ends up performing the best on larger datasets where generalization is important. More information about the parameters can be found in the H2O Deep Learning booklet. 5.5 Cover Type Dataset We important the full cover type dataset (581k rows, 13 columns, 10 numerical, 3 categorical). We also split the data 3 ways: 60% for training, 20% for validation (hyper parameter tuning) and 20% for final testing. df &lt;- h2o.importFile(path = normalizePath(file.path(data_raw_dir, &quot;covtype.full.csv&quot;))) #&gt; | | | 0% | |================ | 25% | |=================================================================| 100% dim(df) #&gt; [1] 581012 13 df #&gt; Elevation Aspect Slope Horizontal_Distance_To_Hydrology #&gt; 1 3066 124 5 0 #&gt; 2 3136 32 20 450 #&gt; 3 2655 28 14 42 #&gt; 4 3191 45 19 323 #&gt; 5 3217 80 13 30 #&gt; 6 3119 293 13 30 #&gt; Vertical_Distance_To_Hydrology Horizontal_Distance_To_Roadways #&gt; 1 0 1533 #&gt; 2 -38 1290 #&gt; 3 8 1890 #&gt; 4 88 3932 #&gt; 5 1 3901 #&gt; 6 10 4810 #&gt; Hillshade_9am Hillshade_Noon Hillshade_3pm #&gt; 1 229 236 141 #&gt; 2 211 193 111 #&gt; 3 214 209 128 #&gt; 4 221 195 100 #&gt; 5 237 217 109 #&gt; 6 182 237 194 #&gt; Horizontal_Distance_To_Fire_Points Wilderness_Area Soil_Type Cover_Type #&gt; 1 459 area_0 type_22 class_1 #&gt; 2 1112 area_0 type_28 class_1 #&gt; 3 1001 area_2 type_9 class_2 #&gt; 4 2919 area_0 type_39 class_2 #&gt; 5 2859 area_0 type_22 class_7 #&gt; 6 1200 area_0 type_21 class_1 #&gt; #&gt; [581012 rows x 13 columns] splits &lt;- h2o.splitFrame(df, c(0.6, 0.2), seed=1234) train &lt;- h2o.assign(splits[[1]], &quot;train.hex&quot;) # 60% valid &lt;- h2o.assign(splits[[2]], &quot;valid.hex&quot;) # 20% test &lt;- h2o.assign(splits[[3]], &quot;test.hex&quot;) # 20% Here’s a scalable way to do scatter plots via binning (works for categorical and numeric columns) to get more familiar with the dataset. #dev.new(noRStudioGD=FALSE) #direct plotting output to a new window par(mfrow=c(1,1)) # reset canvas plot(h2o.tabulate(df, &quot;Elevation&quot;, &quot;Cover_Type&quot;)) #&gt; Registered S3 methods overwritten by &#39;ggplot2&#39;: #&gt; method from #&gt; [.quosures rlang #&gt; c.quosures rlang #&gt; print.quosures rlang plot(h2o.tabulate(df, &quot;Horizontal_Distance_To_Roadways&quot;, &quot;Cover_Type&quot;)) plot(h2o.tabulate(df, &quot;Soil_Type&quot;, &quot;Cover_Type&quot;)) plot(h2o.tabulate(df, &quot;Horizontal_Distance_To_Roadways&quot;, &quot;Elevation&quot; )) 5.5.1 First Run of H2O Deep Learning Let’s run our first Deep Learning model on the covtype dataset. We want to predict the Cover_Type column, a categorical feature with 7 levels, and the Deep Learning model will be tasked to perform (multi-class) classification. It uses the other 12 predictors of the dataset, of which 10 are numerical, and 2 are categorical with a total of 44 levels. We can expect the Deep Learning model to have 56 input neurons (after automatic one-hot encoding). response &lt;- &quot;Cover_Type&quot; predictors &lt;- setdiff(names(df), response) predictors #&gt; [1] &quot;Elevation&quot; #&gt; [2] &quot;Aspect&quot; #&gt; [3] &quot;Slope&quot; #&gt; [4] &quot;Horizontal_Distance_To_Hydrology&quot; #&gt; [5] &quot;Vertical_Distance_To_Hydrology&quot; #&gt; [6] &quot;Horizontal_Distance_To_Roadways&quot; #&gt; [7] &quot;Hillshade_9am&quot; #&gt; [8] &quot;Hillshade_Noon&quot; #&gt; [9] &quot;Hillshade_3pm&quot; #&gt; [10] &quot;Horizontal_Distance_To_Fire_Points&quot; #&gt; [11] &quot;Wilderness_Area&quot; #&gt; [12] &quot;Soil_Type&quot; train_df &lt;- as.data.frame(train) str(train_df) #&gt; &#39;data.frame&#39;: 349015 obs. of 13 variables: #&gt; $ Elevation : int 3136 3217 3119 2679 3261 2885 3227 2843 2853 2883 ... #&gt; $ Aspect : int 32 80 293 48 322 26 32 12 124 177 ... #&gt; $ Slope : int 20 13 13 7 13 9 6 18 12 9 ... #&gt; $ Horizontal_Distance_To_Hydrology : int 450 30 30 150 30 192 108 335 30 426 ... #&gt; $ Vertical_Distance_To_Hydrology : int -38 1 10 24 5 38 13 50 -5 126 ... #&gt; $ Horizontal_Distance_To_Roadways : int 1290 3901 4810 1588 5701 3271 5542 2642 1485 2139 ... #&gt; $ Hillshade_9am : int 211 237 182 223 186 216 219 199 240 225 ... #&gt; $ Hillshade_Noon : int 193 217 237 224 226 220 227 201 231 246 ... #&gt; $ Hillshade_3pm : int 111 109 194 136 180 140 145 135 119 153 ... #&gt; $ Horizontal_Distance_To_Fire_Points: int 1112 2859 1200 6265 769 2643 765 1719 2497 713 ... #&gt; $ Wilderness_Area : Factor w/ 4 levels &quot;area_0&quot;,&quot;area_1&quot;,..: 1 1 1 1 1 1 1 3 3 3 ... #&gt; $ Soil_Type : Factor w/ 40 levels &quot;type_0&quot;,&quot;type_1&quot;,..: 22 16 15 4 15 22 15 27 12 25 ... #&gt; $ Cover_Type : Factor w/ 7 levels &quot;class_1&quot;,&quot;class_2&quot;,..: 1 7 1 2 1 2 1 2 1 2 ... valid_df &lt;- as.data.frame(valid) str(valid_df) #&gt; &#39;data.frame&#39;: 116018 obs. of 13 variables: #&gt; $ Elevation : int 3066 2655 2902 2994 2697 2990 3237 2884 2972 2696 ... #&gt; $ Aspect : int 124 28 304 61 93 59 135 71 100 169 ... #&gt; $ Slope : int 5 14 22 9 9 12 14 9 4 10 ... #&gt; $ Horizontal_Distance_To_Hydrology : int 0 42 511 391 306 108 240 459 175 323 ... #&gt; $ Vertical_Distance_To_Hydrology : int 0 8 18 57 -2 10 -11 141 13 149 ... #&gt; $ Horizontal_Distance_To_Roadways : int 1533 1890 1273 4286 553 2190 1189 1214 5031 2452 ... #&gt; $ Hillshade_9am : int 229 214 155 227 234 229 241 231 227 228 ... #&gt; $ Hillshade_Noon : int 236 209 223 222 227 215 233 222 234 244 ... #&gt; $ Hillshade_3pm : int 141 128 206 128 125 117 118 124 142 148 ... #&gt; $ Horizontal_Distance_To_Fire_Points: int 459 1001 1347 1928 1716 1048 2748 1355 6198 1044 ... #&gt; $ Wilderness_Area : Factor w/ 4 levels &quot;area_0&quot;,&quot;area_1&quot;,..: 1 3 3 1 1 3 1 3 1 3 ... #&gt; $ Soil_Type : Factor w/ 39 levels &quot;type_0&quot;,&quot;type_1&quot;,..: 15 39 25 4 4 25 14 25 11 23 ... #&gt; $ Cover_Type : Factor w/ 7 levels &quot;class_1&quot;,&quot;class_2&quot;,..: 1 2 2 2 2 2 1 2 1 3 ... To keep it fast, we only run for one epoch (one pass over the training data). m1 &lt;- h2o.deeplearning( model_id=&quot;dl_model_first&quot;, training_frame = train, validation_frame = valid, ## validation dataset: used for scoring and early stopping x = predictors, y = response, #activation=&quot;Rectifier&quot;, ## default #hidden=c(200,200), ## default: 2 hidden layers with 200 neurons each epochs = 1, variable_importances=T ## not enabled by default ) #&gt; | | | 0% | |====== | 10% | |============= | 20% | |=================== | 30% | |========================== | 40% | |================================ | 50% | |======================================= | 60% | |============================================= | 70% | |==================================================== | 80% | |========================================================== | 90% | |=================================================================| 100% summary(m1) #&gt; Model Details: #&gt; ============== #&gt; #&gt; H2OMultinomialModel: deeplearning #&gt; Model Key: dl_model_first #&gt; Status of Neuron Layers: predicting Cover_Type, 7-class classification, multinomial distribution, CrossEntropy loss, 53,007 weights/biases, 634.3 KB, 383,948 training samples, mini-batch size 1 #&gt; layer units type dropout l1 l2 mean_rate rate_rms #&gt; 1 1 56 Input 0.00 % NA NA NA NA #&gt; 2 2 200 Rectifier 0.00 % 0.000000 0.000000 0.052020 0.214281 #&gt; 3 3 200 Rectifier 0.00 % 0.000000 0.000000 0.009483 0.007937 #&gt; 4 4 7 Softmax NA 0.000000 0.000000 0.109319 0.280947 #&gt; momentum mean_weight weight_rms mean_bias bias_rms #&gt; 1 NA NA NA NA NA #&gt; 2 0.000000 -0.013026 0.118328 0.001063 0.113984 #&gt; 3 0.000000 -0.023038 0.120935 0.707201 0.412393 #&gt; 4 0.000000 -0.354173 0.512233 -0.504989 0.119360 #&gt; #&gt; H2OMultinomialMetrics: deeplearning #&gt; ** Reported on training data. ** #&gt; ** Metrics reported on temporary training frame with 9939 samples ** #&gt; #&gt; Training Set Metrics: #&gt; ===================== #&gt; #&gt; MSE: (Extract with `h2o.mse`) 0.133 #&gt; RMSE: (Extract with `h2o.rmse`) 0.365 #&gt; Logloss: (Extract with `h2o.logloss`) 0.429 #&gt; Mean Per-Class Error: 0.3 #&gt; Confusion Matrix: Extract with `h2o.confusionMatrix(&lt;model&gt;,train = TRUE)`) #&gt; ========================================================================= #&gt; Confusion Matrix: Row labels: Actual class; Column labels: Predicted class #&gt; class_1 class_2 class_3 class_4 class_5 class_6 class_7 Error #&gt; class_1 3213 406 0 0 1 1 14 0.1161 #&gt; class_2 785 3966 23 0 7 52 1 0.1796 #&gt; class_3 0 40 452 14 0 135 0 0.2949 #&gt; class_4 0 0 5 29 0 4 0 0.2368 #&gt; class_5 18 86 5 0 46 0 0 0.7032 #&gt; class_6 0 26 38 2 0 192 0 0.2558 #&gt; class_7 112 6 0 0 0 0 260 0.3122 #&gt; Totals 4128 4530 523 45 54 384 275 0.1792 #&gt; Rate #&gt; class_1 = 422 / 3,635 #&gt; class_2 = 868 / 4,834 #&gt; class_3 = 189 / 641 #&gt; class_4 = 9 / 38 #&gt; class_5 = 109 / 155 #&gt; class_6 = 66 / 258 #&gt; class_7 = 118 / 378 #&gt; Totals = 1,781 / 9,939 #&gt; #&gt; Hit Ratio Table: Extract with `h2o.hit_ratio_table(&lt;model&gt;,train = TRUE)` #&gt; ======================================================================= #&gt; Top-7 Hit Ratios: #&gt; k hit_ratio #&gt; 1 1 0.820807 #&gt; 2 2 0.981487 #&gt; 3 3 0.998088 #&gt; 4 4 0.999497 #&gt; 5 5 0.999899 #&gt; 6 6 1.000000 #&gt; 7 7 1.000000 #&gt; #&gt; #&gt; H2OMultinomialMetrics: deeplearning #&gt; ** Reported on validation data. ** #&gt; ** Metrics reported on full validation frame ** #&gt; #&gt; Validation Set Metrics: #&gt; ===================== #&gt; #&gt; Extract validation frame with `h2o.getFrame(&quot;valid.hex&quot;)` #&gt; MSE: (Extract with `h2o.mse`) 0.136 #&gt; RMSE: (Extract with `h2o.rmse`) 0.368 #&gt; Logloss: (Extract with `h2o.logloss`) 0.435 #&gt; Mean Per-Class Error: 0.309 #&gt; Confusion Matrix: Extract with `h2o.confusionMatrix(&lt;model&gt;,valid = TRUE)`) #&gt; ========================================================================= #&gt; Confusion Matrix: Row labels: Actual class; Column labels: Predicted class #&gt; class_1 class_2 class_3 class_4 class_5 class_6 class_7 Error #&gt; class_1 37583 4723 0 0 3 23 168 0.1157 #&gt; class_2 9585 45870 193 2 127 574 29 0.1864 #&gt; class_3 0 475 4825 204 2 1637 0 0.3245 #&gt; class_4 0 1 68 404 0 89 0 0.2811 #&gt; class_5 217 981 52 0 600 20 0 0.6791 #&gt; class_6 19 395 396 22 0 2632 0 0.2402 #&gt; class_7 1349 40 0 0 0 0 2710 0.3389 #&gt; Totals 48753 52485 5534 632 732 4975 2907 0.1844 #&gt; Rate #&gt; class_1 = 4,917 / 42,500 #&gt; class_2 = 10,510 / 56,380 #&gt; class_3 = 2,318 / 7,143 #&gt; class_4 = 158 / 562 #&gt; class_5 = 1,270 / 1,870 #&gt; class_6 = 832 / 3,464 #&gt; class_7 = 1,389 / 4,099 #&gt; Totals = 21,394 / 116,018 #&gt; #&gt; Hit Ratio Table: Extract with `h2o.hit_ratio_table(&lt;model&gt;,valid = TRUE)` #&gt; ======================================================================= #&gt; Top-7 Hit Ratios: #&gt; k hit_ratio #&gt; 1 1 0.815598 #&gt; 2 2 0.982632 #&gt; 3 3 0.997716 #&gt; 4 4 0.999448 #&gt; 5 5 0.999991 #&gt; 6 6 1.000000 #&gt; 7 7 1.000000 #&gt; #&gt; #&gt; #&gt; #&gt; Scoring History: #&gt; timestamp duration training_speed epochs iterations #&gt; 1 2019-09-18 15:51:29 0.000 sec NA 0.00000 0 #&gt; 2 2019-09-18 15:51:34 5.924 sec 8318 obs/sec 0.09987 1 #&gt; 3 2019-09-18 15:51:50 22.266 sec 10948 obs/sec 0.59931 6 #&gt; 4 2019-09-18 15:52:04 36.515 sec 12053 obs/sec 1.10009 11 #&gt; samples training_rmse training_logloss training_r2 #&gt; 1 0.000000 NA NA NA #&gt; 2 34855.000000 0.47893 0.70995 0.88236 #&gt; 3 209168.000000 0.38739 0.47359 0.92303 #&gt; 4 383948.000000 0.36485 0.42851 0.93173 #&gt; training_classification_error validation_rmse validation_logloss #&gt; 1 NA NA NA #&gt; 2 0.31814 0.48767 0.73753 #&gt; 3 0.20676 0.39230 0.48566 #&gt; 4 0.17919 0.36813 0.43459 #&gt; validation_r2 validation_classification_error #&gt; 1 NA NA #&gt; 2 0.87810 0.32713 #&gt; 3 0.92111 0.20664 #&gt; 4 0.93053 0.18440 #&gt; #&gt; Variable Importances: (Extract with `h2o.varimp`) #&gt; ================================================= #&gt; #&gt; Variable Importances: #&gt; variable relative_importance scaled_importance #&gt; 1 Horizontal_Distance_To_Roadways 1.000000 1.000000 #&gt; 2 Wilderness_Area.area_0 0.995628 0.995628 #&gt; 3 Elevation 0.954144 0.954144 #&gt; 4 Horizontal_Distance_To_Fire_Points 0.913634 0.913634 #&gt; 5 Wilderness_Area.area_1 0.833391 0.833391 #&gt; percentage #&gt; 1 0.029803 #&gt; 2 0.029672 #&gt; 3 0.028436 #&gt; 4 0.027229 #&gt; 5 0.024837 #&gt; #&gt; --- #&gt; variable relative_importance scaled_importance #&gt; 51 Slope 0.467730 0.467730 #&gt; 52 Hillshade_9am 0.449014 0.449014 #&gt; 53 Hillshade_3pm 0.443098 0.443098 #&gt; 54 Aspect 0.334827 0.334827 #&gt; 55 Soil_Type.missing(NA) 0.000000 0.000000 #&gt; 56 Wilderness_Area.missing(NA) 0.000000 0.000000 #&gt; percentage #&gt; 51 0.013940 #&gt; 52 0.013382 #&gt; 53 0.013206 #&gt; 54 0.009979 #&gt; 55 0.000000 #&gt; 56 0.000000 Inspect the model in Flow for more information about model building etc. by issuing a cell with the content getModel “dl_model_first”, and pressing Ctrl-Enter. 5.5.2 Variable Importances Variable importances for Neural Network models are notoriously difficult to compute, and there are many pitfalls. H2O Deep Learning has implemented the method of Gedeon, and returns relative variable importances in descending order of importance. head(as.data.frame(h2o.varimp(m1))) #&gt; variable relative_importance scaled_importance #&gt; 1 Horizontal_Distance_To_Roadways 1.000 1.000 #&gt; 2 Wilderness_Area.area_0 0.996 0.996 #&gt; 3 Elevation 0.954 0.954 #&gt; 4 Horizontal_Distance_To_Fire_Points 0.914 0.914 #&gt; 5 Wilderness_Area.area_1 0.833 0.833 #&gt; 6 Wilderness_Area.area_3 0.828 0.828 #&gt; percentage #&gt; 1 0.0298 #&gt; 2 0.0297 #&gt; 3 0.0284 #&gt; 4 0.0272 #&gt; 5 0.0248 #&gt; 6 0.0247 5.5.3 Early Stopping Now we run another, smaller network, and we let it stop automatically once the misclassification rate converges (specifically, if the moving average of length 2 does not improve by at least 1% for 2 consecutive scoring events). We also sample the validation set to 10,000 rows for faster scoring. m2 &lt;- h2o.deeplearning( model_id=&quot;dl_model_faster&quot;, training_frame=train, validation_frame=valid, x=predictors, y=response, hidden=c(32,32,32), ## small network, runs faster epochs=1000000, ## hopefully converges earlier... score_validation_samples=10000, ## sample the validation dataset (faster) stopping_rounds=2, stopping_metric=&quot;misclassification&quot;, ## could be &quot;MSE&quot;,&quot;logloss&quot;,&quot;r2&quot; stopping_tolerance=0.01 ) #&gt; | | | 0% | |=================================================================| 100% summary(m2) #&gt; Model Details: #&gt; ============== #&gt; #&gt; H2OMultinomialModel: deeplearning #&gt; Model Key: dl_model_faster #&gt; Status of Neuron Layers: predicting Cover_Type, 7-class classification, multinomial distribution, CrossEntropy loss, 4,167 weights/biases, 59.0 KB, 5,998,238 training samples, mini-batch size 1 #&gt; layer units type dropout l1 l2 mean_rate rate_rms #&gt; 1 1 56 Input 0.00 % NA NA NA NA #&gt; 2 2 32 Rectifier 0.00 % 0.000000 0.000000 0.043542 0.203150 #&gt; 3 3 32 Rectifier 0.00 % 0.000000 0.000000 0.000315 0.000198 #&gt; 4 4 32 Rectifier 0.00 % 0.000000 0.000000 0.000593 0.000432 #&gt; 5 5 7 Softmax NA 0.000000 0.000000 0.091630 0.265655 #&gt; momentum mean_weight weight_rms mean_bias bias_rms #&gt; 1 NA NA NA NA NA #&gt; 2 0.000000 0.002230 0.302863 0.239473 0.349360 #&gt; 3 0.000000 -0.073745 0.379844 0.896810 0.664966 #&gt; 4 0.000000 -0.025501 0.465759 0.657863 0.967854 #&gt; 5 0.000000 -4.256814 3.272137 -3.303263 0.499360 #&gt; #&gt; H2OMultinomialMetrics: deeplearning #&gt; ** Reported on training data. ** #&gt; ** Metrics reported on temporary training frame with 9869 samples ** #&gt; #&gt; Training Set Metrics: #&gt; ===================== #&gt; #&gt; MSE: (Extract with `h2o.mse`) 0.113 #&gt; RMSE: (Extract with `h2o.rmse`) 0.336 #&gt; Logloss: (Extract with `h2o.logloss`) 0.381 #&gt; Mean Per-Class Error: 0.271 #&gt; Confusion Matrix: Extract with `h2o.confusionMatrix(&lt;model&gt;,train = TRUE)`) #&gt; ========================================================================= #&gt; Confusion Matrix: Row labels: Actual class; Column labels: Predicted class #&gt; class_1 class_2 class_3 class_4 class_5 class_6 class_7 Error #&gt; class_1 3132 463 0 0 2 2 30 0.1370 #&gt; class_2 527 4182 11 0 15 38 4 0.1246 #&gt; class_3 0 41 459 15 3 71 0 0.2207 #&gt; class_4 0 0 13 32 0 4 0 0.3469 #&gt; class_5 10 70 3 0 90 2 0 0.4857 #&gt; class_6 1 38 61 3 0 197 0 0.3433 #&gt; class_7 80 3 0 0 0 0 267 0.2371 #&gt; Totals 3750 4797 547 50 110 314 301 0.1530 #&gt; Rate #&gt; class_1 = 497 / 3,629 #&gt; class_2 = 595 / 4,777 #&gt; class_3 = 130 / 589 #&gt; class_4 = 17 / 49 #&gt; class_5 = 85 / 175 #&gt; class_6 = 103 / 300 #&gt; class_7 = 83 / 350 #&gt; Totals = 1,510 / 9,869 #&gt; #&gt; Hit Ratio Table: Extract with `h2o.hit_ratio_table(&lt;model&gt;,train = TRUE)` #&gt; ======================================================================= #&gt; Top-7 Hit Ratios: #&gt; k hit_ratio #&gt; 1 1 0.846996 #&gt; 2 2 0.986523 #&gt; 3 3 0.997973 #&gt; 4 4 0.999595 #&gt; 5 5 0.999899 #&gt; 6 6 1.000000 #&gt; 7 7 1.000000 #&gt; #&gt; #&gt; H2OMultinomialMetrics: deeplearning #&gt; ** Reported on validation data. ** #&gt; ** Metrics reported on temporary validation frame with 10013 samples ** #&gt; #&gt; Validation Set Metrics: #&gt; ===================== #&gt; #&gt; MSE: (Extract with `h2o.mse`) 0.112 #&gt; RMSE: (Extract with `h2o.rmse`) 0.334 #&gt; Logloss: (Extract with `h2o.logloss`) 0.382 #&gt; Mean Per-Class Error: 0.27 #&gt; Confusion Matrix: Extract with `h2o.confusionMatrix(&lt;model&gt;,valid = TRUE)`) #&gt; ========================================================================= #&gt; Confusion Matrix: Row labels: Actual class; Column labels: Predicted class #&gt; class_1 class_2 class_3 class_4 class_5 class_6 class_7 Error #&gt; class_1 3156 454 0 0 5 1 20 0.1320 #&gt; class_2 542 4242 20 0 21 31 5 0.1273 #&gt; class_3 1 43 486 9 3 94 0 0.2358 #&gt; class_4 0 0 13 28 0 3 0 0.3636 #&gt; class_5 9 68 5 0 83 2 0 0.5030 #&gt; class_6 0 38 58 3 0 213 0 0.3173 #&gt; class_7 72 3 0 0 0 0 282 0.2101 #&gt; Totals 3780 4848 582 40 112 344 307 0.1521 #&gt; Rate #&gt; class_1 = 480 / 3,636 #&gt; class_2 = 619 / 4,861 #&gt; class_3 = 150 / 636 #&gt; class_4 = 16 / 44 #&gt; class_5 = 84 / 167 #&gt; class_6 = 99 / 312 #&gt; class_7 = 75 / 357 #&gt; Totals = 1,523 / 10,013 #&gt; #&gt; Hit Ratio Table: Extract with `h2o.hit_ratio_table(&lt;model&gt;,valid = TRUE)` #&gt; ======================================================================= #&gt; Top-7 Hit Ratios: #&gt; k hit_ratio #&gt; 1 1 0.847898 #&gt; 2 2 0.985119 #&gt; 3 3 0.997104 #&gt; 4 4 0.999101 #&gt; 5 5 0.999900 #&gt; 6 6 1.000000 #&gt; 7 7 1.000000 #&gt; #&gt; #&gt; #&gt; #&gt; Scoring History: #&gt; timestamp duration training_speed epochs iterations #&gt; 1 2019-09-18 15:52:06 0.000 sec NA 0.00000 0 #&gt; 2 2019-09-18 15:52:08 1.222 sec 89899 obs/sec 0.28643 1 #&gt; 3 2019-09-18 15:52:13 6.749 sec 106015 obs/sec 2.00571 7 #&gt; 4 2019-09-18 15:52:18 11.835 sec 111658 obs/sec 3.72423 13 #&gt; 5 2019-09-18 15:52:23 17.043 sec 113010 obs/sec 5.44400 19 #&gt; 6 2019-09-18 15:52:29 22.846 sec 115203 obs/sec 7.44959 26 #&gt; 7 2019-09-18 15:52:35 28.476 sec 117206 obs/sec 9.45636 33 #&gt; 8 2019-09-18 15:52:41 34.391 sec 114568 obs/sec 11.17471 39 #&gt; 9 2019-09-18 15:52:46 39.977 sec 116197 obs/sec 13.17970 46 #&gt; 10 2019-09-18 15:52:52 45.335 sec 118011 obs/sec 15.18186 53 #&gt; 11 2019-09-18 15:52:57 50.814 sec 119147 obs/sec 17.18619 60 #&gt; 12 2019-09-18 15:52:57 50.865 sec 119140 obs/sec 17.18619 60 #&gt; samples training_rmse training_logloss training_r2 #&gt; 1 0.000000 NA NA NA #&gt; 2 99968.000000 0.43130 0.57864 0.90591 #&gt; 3 700022.000000 0.38676 0.46838 0.92434 #&gt; 4 1299811.000000 0.36919 0.43566 0.93105 #&gt; 5 1900039.000000 0.35794 0.41900 0.93519 #&gt; 6 2600018.000000 0.34941 0.39401 0.93824 #&gt; 7 3300411.000000 0.35025 0.39282 0.93794 #&gt; 8 3900141.000000 0.33948 0.38095 0.94170 #&gt; 9 4599914.000000 0.33875 0.37645 0.94195 #&gt; 10 5298698.000000 0.33551 0.38106 0.94306 #&gt; 11 5998238.000000 0.33994 0.39890 0.94155 #&gt; 12 5998238.000000 0.33551 0.38106 0.94306 #&gt; training_classification_error validation_rmse validation_logloss #&gt; 1 NA NA NA #&gt; 2 0.24906 0.42912 0.56878 #&gt; 3 0.20255 0.38178 0.46273 #&gt; 4 0.18401 0.36159 0.42285 #&gt; 5 0.17580 0.35387 0.40662 #&gt; 6 0.16415 0.34462 0.38616 #&gt; 7 0.16131 0.34918 0.39526 #&gt; 8 0.15412 0.33828 0.37853 #&gt; 9 0.15351 0.33712 0.37308 #&gt; 10 0.15300 0.33432 0.38220 #&gt; 11 0.15533 0.33944 0.39855 #&gt; 12 0.15300 0.33432 0.38220 #&gt; validation_r2 validation_classification_error #&gt; 1 NA NA #&gt; 2 0.90702 0.24378 #&gt; 3 0.92640 0.19325 #&gt; 4 0.93398 0.16908 #&gt; 5 0.93677 0.16668 #&gt; 6 0.94003 0.15969 #&gt; 7 0.93843 0.16239 #&gt; 8 0.94222 0.15310 #&gt; 9 0.94261 0.15270 #&gt; 10 0.94356 0.15210 #&gt; 11 0.94182 0.15350 #&gt; 12 0.94356 0.15210 #&gt; #&gt; Variable Importances: (Extract with `h2o.varimp`) #&gt; ================================================= #&gt; #&gt; Variable Importances: #&gt; variable relative_importance scaled_importance #&gt; 1 Elevation 1.000000 1.000000 #&gt; 2 Horizontal_Distance_To_Fire_Points 0.936184 0.936184 #&gt; 3 Horizontal_Distance_To_Roadways 0.870469 0.870469 #&gt; 4 Wilderness_Area.area_3 0.839175 0.839175 #&gt; 5 Wilderness_Area.area_1 0.778196 0.778196 #&gt; percentage #&gt; 1 0.036947 #&gt; 2 0.034590 #&gt; 3 0.032162 #&gt; 4 0.031005 #&gt; 5 0.028752 #&gt; #&gt; --- #&gt; variable relative_importance scaled_importance #&gt; 51 Soil_Type.type_14 0.278891 0.278891 #&gt; 52 Vertical_Distance_To_Hydrology 0.231951 0.231951 #&gt; 53 Slope 0.175502 0.175502 #&gt; 54 Aspect 0.067770 0.067770 #&gt; 55 Soil_Type.missing(NA) 0.000000 0.000000 #&gt; 56 Wilderness_Area.missing(NA) 0.000000 0.000000 #&gt; percentage #&gt; 51 0.010304 #&gt; 52 0.008570 #&gt; 53 0.006484 #&gt; 54 0.002504 #&gt; 55 0.000000 #&gt; 56 0.000000 plot(m2) 5.5.4 Adaptive Learning Rate By default, H2O Deep Learning uses an adaptive learning rate (ADADELTA) for its stochastic gradient descent optimization. There are only two tuning parameters for this method: rho and epsilon, which balance the global and local search efficiencies. rho is the similarity to prior weight updates (similar to momentum), and epsilon is a parameter that prevents the optimization to get stuck in local optima. Defaults are rho=0.99 and epsilon=1e-8. For cases where convergence speed is very important, it might make sense to perform a few runs to optimize these two parameters (e.g., with rho in c(0.9,0.95,0.99,0.999) and epsilon in c(1e-10,1e-8,1e-6,1e-4)). Of course, as always with grid searches, caution has to be applied when extrapolating grid search results to a different parameter regime (e.g., for more epochs or different layer topologies or activation functions, etc.). If adaptive_rate is disabled, several manual learning rate parameters become important: rate, rate_annealing, rate_decay, momentum_start, momentum_ramp, momentum_stable and nesterov_accelerated_gradient, the discussion of which we leave to H2O Deep Learning booklet. 5.5.5 Tuning With some tuning, it is possible to obtain less than 10% test set error rate in about one minute. Error rates of below 5% are possible with larger models. Note that deep tree methods can be more effective for this dataset than Deep Learning, as they directly partition the space into sectors, which seems to be needed here. m3 &lt;- h2o.deeplearning( model_id=&quot;dl_model_tuned&quot;, training_frame=train, validation_frame=valid, x=predictors, y=response, overwrite_with_best_model=F, ## Return final model after 10 epochs, even if not the best hidden=c(128,128,128), ## more hidden layers -&gt; more complex interactions epochs=10, ## to keep it short enough score_validation_samples=10000, ## downsample validation set for faster scoring score_duty_cycle=0.025, ## don&#39;t score more than 2.5% of the wall time adaptive_rate=F, ## manually tuned learning rate rate=0.01, rate_annealing=2e-6, momentum_start=0.2, ## manually tuned momentum momentum_stable=0.4, momentum_ramp=1e7, l1=1e-5, ## add some L1/L2 regularization l2=1e-5, max_w2=10 ## helps stability for Rectifier ) #&gt; | | | 0% | |== | 3% | |==== | 6% | |====== | 9% | |======= | 11% | |========= | 14% | |=========== | 17% | |============= | 20% | |=============== | 23% | |================= | 26% | |=================== | 29% | |==================== | 32% | |====================== | 34% | |======================== | 37% | |========================== | 40% | |============================ | 43% | |============================== | 46% | |================================ | 49% | |================================== | 52% | |=================================== | 54% | |===================================== | 57% | |======================================= | 60% | |========================================= | 63% | |=========================================== | 66% | |============================================= | 69% | |=============================================== | 72% | |================================================ | 74% | |================================================== | 77% | |==================================================== | 80% | |====================================================== | 83% | |======================================================== | 86% | |========================================================== | 89% | |============================================================ | 92% | |============================================================= | 95% | |=============================================================== | 97% | |=================================================================| 100% summary(m3) #&gt; Model Details: #&gt; ============== #&gt; #&gt; H2OMultinomialModel: deeplearning #&gt; Model Key: dl_model_tuned #&gt; Status of Neuron Layers: predicting Cover_Type, 7-class classification, multinomial distribution, CrossEntropy loss, 41,223 weights/biases, 334.1 KB, 3,500,386 training samples, mini-batch size 1 #&gt; layer units type dropout l1 l2 mean_rate rate_rms #&gt; 1 1 56 Input 0.00 % NA NA NA NA #&gt; 2 2 128 Rectifier 0.00 % 0.000010 0.000010 0.001250 0.000000 #&gt; 3 3 128 Rectifier 0.00 % 0.000010 0.000010 0.001250 0.000000 #&gt; 4 4 128 Rectifier 0.00 % 0.000010 0.000010 0.001250 0.000000 #&gt; 5 5 7 Softmax NA 0.000010 0.000010 0.001250 0.000000 #&gt; momentum mean_weight weight_rms mean_bias bias_rms #&gt; 1 NA NA NA NA NA #&gt; 2 0.270008 -0.016978 0.319605 -0.051916 0.324684 #&gt; 3 0.270008 -0.052648 0.220951 0.931599 0.373948 #&gt; 4 0.270008 -0.064876 0.215186 0.836888 0.166593 #&gt; 5 0.270008 -0.020166 0.271090 0.042465 0.955199 #&gt; #&gt; H2OMultinomialMetrics: deeplearning #&gt; ** Reported on training data. ** #&gt; ** Metrics reported on temporary training frame with 9953 samples ** #&gt; #&gt; Training Set Metrics: #&gt; ===================== #&gt; #&gt; MSE: (Extract with `h2o.mse`) 0.0577 #&gt; RMSE: (Extract with `h2o.rmse`) 0.24 #&gt; Logloss: (Extract with `h2o.logloss`) 0.188 #&gt; Mean Per-Class Error: 0.13 #&gt; Confusion Matrix: Extract with `h2o.confusionMatrix(&lt;model&gt;,train = TRUE)`) #&gt; ========================================================================= #&gt; Confusion Matrix: Row labels: Actual class; Column labels: Predicted class #&gt; class_1 class_2 class_3 class_4 class_5 class_6 class_7 Error #&gt; class_1 3286 283 0 0 6 0 23 0.0867 #&gt; class_2 245 4567 19 0 30 15 3 0.0639 #&gt; class_3 0 9 550 2 0 29 0 0.0678 #&gt; class_4 0 0 5 30 0 3 0 0.2105 #&gt; class_5 6 26 5 0 141 0 0 0.2079 #&gt; class_6 1 13 49 0 0 254 0 0.1987 #&gt; class_7 24 2 0 0 0 0 327 0.0737 #&gt; Totals 3562 4900 628 32 177 301 353 0.0802 #&gt; Rate #&gt; class_1 = 312 / 3,598 #&gt; class_2 = 312 / 4,879 #&gt; class_3 = 40 / 590 #&gt; class_4 = 8 / 38 #&gt; class_5 = 37 / 178 #&gt; class_6 = 63 / 317 #&gt; class_7 = 26 / 353 #&gt; Totals = 798 / 9,953 #&gt; #&gt; Hit Ratio Table: Extract with `h2o.hit_ratio_table(&lt;model&gt;,train = TRUE)` #&gt; ======================================================================= #&gt; Top-7 Hit Ratios: #&gt; k hit_ratio #&gt; 1 1 0.919823 #&gt; 2 2 0.996182 #&gt; 3 3 0.999397 #&gt; 4 4 0.999900 #&gt; 5 5 1.000000 #&gt; 6 6 1.000000 #&gt; 7 7 1.000000 #&gt; #&gt; #&gt; H2OMultinomialMetrics: deeplearning #&gt; ** Reported on validation data. ** #&gt; ** Metrics reported on temporary validation frame with 10027 samples ** #&gt; #&gt; Validation Set Metrics: #&gt; ===================== #&gt; #&gt; MSE: (Extract with `h2o.mse`) 0.0633 #&gt; RMSE: (Extract with `h2o.rmse`) 0.251 #&gt; Logloss: (Extract with `h2o.logloss`) 0.209 #&gt; Mean Per-Class Error: 0.132 #&gt; Confusion Matrix: Extract with `h2o.confusionMatrix(&lt;model&gt;,valid = TRUE)`) #&gt; ========================================================================= #&gt; Confusion Matrix: Row labels: Actual class; Column labels: Predicted class #&gt; class_1 class_2 class_3 class_4 class_5 class_6 class_7 Error #&gt; class_1 3287 316 0 0 1 2 28 0.0955 #&gt; class_2 275 4535 15 0 30 19 1 0.0697 #&gt; class_3 0 7 599 6 2 14 0 0.0462 #&gt; class_4 0 0 7 47 0 3 0 0.1754 #&gt; class_5 6 32 0 0 118 3 0 0.2579 #&gt; class_6 0 8 52 2 1 244 0 0.2052 #&gt; class_7 26 2 0 0 0 0 339 0.0763 #&gt; Totals 3594 4900 673 55 152 285 368 0.0856 #&gt; Rate #&gt; class_1 = 347 / 3,634 #&gt; class_2 = 340 / 4,875 #&gt; class_3 = 29 / 628 #&gt; class_4 = 10 / 57 #&gt; class_5 = 41 / 159 #&gt; class_6 = 63 / 307 #&gt; class_7 = 28 / 367 #&gt; Totals = 858 / 10,027 #&gt; #&gt; Hit Ratio Table: Extract with `h2o.hit_ratio_table(&lt;model&gt;,valid = TRUE)` #&gt; ======================================================================= #&gt; Top-7 Hit Ratios: #&gt; k hit_ratio #&gt; 1 1 0.914431 #&gt; 2 2 0.995512 #&gt; 3 3 0.999302 #&gt; 4 4 1.000000 #&gt; 5 5 1.000000 #&gt; 6 6 1.000000 #&gt; 7 7 1.000000 #&gt; #&gt; #&gt; #&gt; #&gt; Scoring History: #&gt; timestamp duration training_speed epochs #&gt; 1 2019-09-18 15:52:58 0.000 sec NA 0.00000 #&gt; 2 2019-09-18 15:53:04 5.874 sec 17786 obs/sec 0.28580 #&gt; 3 2019-09-18 15:53:15 17.380 sec 23616 obs/sec 1.14641 #&gt; 4 2019-09-18 15:53:22 24.609 sec 25023 obs/sec 1.71832 #&gt; 5 2019-09-18 15:53:33 35.207 sec 26176 obs/sec 2.57862 #&gt; 6 2019-09-18 15:53:43 45.649 sec 26894 obs/sec 3.43956 #&gt; 7 2019-09-18 15:53:56 58.187 sec 26321 obs/sec 4.29853 #&gt; 8 2019-09-18 15:54:03 1 min 5.478 sec 26535 obs/sec 4.87291 #&gt; 9 2019-09-18 15:54:14 1 min 15.775 sec 26966 obs/sec 5.73278 #&gt; 10 2019-09-18 15:54:24 1 min 25.937 sec 27328 obs/sec 6.59191 #&gt; 11 2019-09-18 15:54:34 1 min 35.975 sec 27652 obs/sec 7.45031 #&gt; 12 2019-09-18 15:54:44 1 min 46.110 sec 27891 obs/sec 8.30929 #&gt; 13 2019-09-18 15:54:55 1 min 57.427 sec 27806 obs/sec 9.16961 #&gt; 14 2019-09-18 15:55:06 2 min 7.974 sec 27899 obs/sec 10.02933 #&gt; iterations samples training_rmse training_logloss training_r2 #&gt; 1 0 0.000000 NA NA NA #&gt; 2 1 99748.000000 0.42237 0.55312 0.91032 #&gt; 3 4 400116.000000 0.36296 0.41016 0.93377 #&gt; 4 6 599719.000000 0.33585 0.35917 0.94330 #&gt; 5 9 899978.000000 0.31747 0.32316 0.94933 #&gt; 6 12 1200457.000000 0.29301 0.28009 0.95684 #&gt; 7 15 1500253.000000 0.28066 0.25732 0.96040 #&gt; 8 17 1700719.000000 0.27223 0.24098 0.96275 #&gt; 9 20 2000827.000000 0.26314 0.22777 0.96519 #&gt; 10 23 2300675.000000 0.25235 0.20993 0.96799 #&gt; 11 26 2600269.000000 0.25552 0.21299 0.96718 #&gt; 12 29 2900066.000000 0.24977 0.20583 0.96864 #&gt; 13 32 3200330.000000 0.24093 0.19157 0.97082 #&gt; 14 35 3500386.000000 0.24023 0.18839 0.97099 #&gt; training_classification_error validation_rmse validation_logloss #&gt; 1 NA NA NA #&gt; 2 0.23762 0.42810 0.56255 #&gt; 3 0.17784 0.36994 0.42483 #&gt; 4 0.15362 0.33674 0.36047 #&gt; 5 0.13393 0.31944 0.32746 #&gt; 6 0.11574 0.29946 0.29243 #&gt; 7 0.10650 0.28528 0.26399 #&gt; 8 0.09876 0.27914 0.25280 #&gt; 9 0.09113 0.27433 0.24427 #&gt; 10 0.08410 0.26502 0.23177 #&gt; 11 0.08882 0.26406 0.22956 #&gt; 12 0.08440 0.25638 0.21807 #&gt; 13 0.07787 0.24974 0.20773 #&gt; 14 0.08018 0.25150 0.20908 #&gt; validation_r2 validation_classification_error #&gt; 1 NA NA #&gt; 2 0.90796 0.24763 #&gt; 3 0.93127 0.18370 #&gt; 4 0.94305 0.15408 #&gt; 5 0.94875 0.13783 #&gt; 6 0.95496 0.12018 #&gt; 7 0.95913 0.11050 #&gt; 8 0.96087 0.10561 #&gt; 9 0.96221 0.10242 #&gt; 10 0.96473 0.09554 #&gt; 11 0.96498 0.09345 #&gt; 12 0.96699 0.08946 #&gt; 13 0.96868 0.08268 #&gt; 14 0.96823 0.08557 #&gt; #&gt; Variable Importances: (Extract with `h2o.varimp`) #&gt; ================================================= #&gt; #&gt; Variable Importances: #&gt; variable relative_importance scaled_importance #&gt; 1 Elevation 1.000000 1.000000 #&gt; 2 Horizontal_Distance_To_Fire_Points 0.907797 0.907797 #&gt; 3 Horizontal_Distance_To_Roadways 0.900001 0.900001 #&gt; 4 Wilderness_Area.area_0 0.663471 0.663471 #&gt; 5 Wilderness_Area.area_2 0.585090 0.585090 #&gt; percentage #&gt; 1 0.050027 #&gt; 2 0.045414 #&gt; 3 0.045024 #&gt; 4 0.033192 #&gt; 5 0.029270 #&gt; #&gt; --- #&gt; variable relative_importance scaled_importance #&gt; 51 Soil_Type.type_7 0.160631 0.160631 #&gt; 52 Soil_Type.type_24 0.158613 0.158613 #&gt; 53 Soil_Type.type_14 0.146655 0.146655 #&gt; 54 Soil_Type.type_6 0.146298 0.146298 #&gt; 55 Soil_Type.missing(NA) 0.000000 0.000000 #&gt; 56 Wilderness_Area.missing(NA) 0.000000 0.000000 #&gt; percentage #&gt; 51 0.008036 #&gt; 52 0.007935 #&gt; 53 0.007337 #&gt; 54 0.007319 #&gt; 55 0.000000 #&gt; 56 0.000000 Let’s compare the training error with the validation and test set errors h2o.performance(m3, train=T) ## sampled training data (from model building) #&gt; H2OMultinomialMetrics: deeplearning #&gt; ** Reported on training data. ** #&gt; ** Metrics reported on temporary training frame with 9953 samples ** #&gt; #&gt; Training Set Metrics: #&gt; ===================== #&gt; #&gt; MSE: (Extract with `h2o.mse`) 0.0577 #&gt; RMSE: (Extract with `h2o.rmse`) 0.24 #&gt; Logloss: (Extract with `h2o.logloss`) 0.188 #&gt; Mean Per-Class Error: 0.13 #&gt; Confusion Matrix: Extract with `h2o.confusionMatrix(&lt;model&gt;,train = TRUE)`) #&gt; ========================================================================= #&gt; Confusion Matrix: Row labels: Actual class; Column labels: Predicted class #&gt; class_1 class_2 class_3 class_4 class_5 class_6 class_7 Error #&gt; class_1 3286 283 0 0 6 0 23 0.0867 #&gt; class_2 245 4567 19 0 30 15 3 0.0639 #&gt; class_3 0 9 550 2 0 29 0 0.0678 #&gt; class_4 0 0 5 30 0 3 0 0.2105 #&gt; class_5 6 26 5 0 141 0 0 0.2079 #&gt; class_6 1 13 49 0 0 254 0 0.1987 #&gt; class_7 24 2 0 0 0 0 327 0.0737 #&gt; Totals 3562 4900 628 32 177 301 353 0.0802 #&gt; Rate #&gt; class_1 = 312 / 3,598 #&gt; class_2 = 312 / 4,879 #&gt; class_3 = 40 / 590 #&gt; class_4 = 8 / 38 #&gt; class_5 = 37 / 178 #&gt; class_6 = 63 / 317 #&gt; class_7 = 26 / 353 #&gt; Totals = 798 / 9,953 #&gt; #&gt; Hit Ratio Table: Extract with `h2o.hit_ratio_table(&lt;model&gt;,train = TRUE)` #&gt; ======================================================================= #&gt; Top-7 Hit Ratios: #&gt; k hit_ratio #&gt; 1 1 0.919823 #&gt; 2 2 0.996182 #&gt; 3 3 0.999397 #&gt; 4 4 0.999900 #&gt; 5 5 1.000000 #&gt; 6 6 1.000000 #&gt; 7 7 1.000000 h2o.performance(m3, valid=T) ## sampled validation data (from model building) #&gt; H2OMultinomialMetrics: deeplearning #&gt; ** Reported on validation data. ** #&gt; ** Metrics reported on temporary validation frame with 10027 samples ** #&gt; #&gt; Validation Set Metrics: #&gt; ===================== #&gt; #&gt; MSE: (Extract with `h2o.mse`) 0.0633 #&gt; RMSE: (Extract with `h2o.rmse`) 0.251 #&gt; Logloss: (Extract with `h2o.logloss`) 0.209 #&gt; Mean Per-Class Error: 0.132 #&gt; Confusion Matrix: Extract with `h2o.confusionMatrix(&lt;model&gt;,valid = TRUE)`) #&gt; ========================================================================= #&gt; Confusion Matrix: Row labels: Actual class; Column labels: Predicted class #&gt; class_1 class_2 class_3 class_4 class_5 class_6 class_7 Error #&gt; class_1 3287 316 0 0 1 2 28 0.0955 #&gt; class_2 275 4535 15 0 30 19 1 0.0697 #&gt; class_3 0 7 599 6 2 14 0 0.0462 #&gt; class_4 0 0 7 47 0 3 0 0.1754 #&gt; class_5 6 32 0 0 118 3 0 0.2579 #&gt; class_6 0 8 52 2 1 244 0 0.2052 #&gt; class_7 26 2 0 0 0 0 339 0.0763 #&gt; Totals 3594 4900 673 55 152 285 368 0.0856 #&gt; Rate #&gt; class_1 = 347 / 3,634 #&gt; class_2 = 340 / 4,875 #&gt; class_3 = 29 / 628 #&gt; class_4 = 10 / 57 #&gt; class_5 = 41 / 159 #&gt; class_6 = 63 / 307 #&gt; class_7 = 28 / 367 #&gt; Totals = 858 / 10,027 #&gt; #&gt; Hit Ratio Table: Extract with `h2o.hit_ratio_table(&lt;model&gt;,valid = TRUE)` #&gt; ======================================================================= #&gt; Top-7 Hit Ratios: #&gt; k hit_ratio #&gt; 1 1 0.914431 #&gt; 2 2 0.995512 #&gt; 3 3 0.999302 #&gt; 4 4 1.000000 #&gt; 5 5 1.000000 #&gt; 6 6 1.000000 #&gt; 7 7 1.000000 h2o.performance(m3, newdata=train) ## full training data #&gt; H2OMultinomialMetrics: deeplearning #&gt; #&gt; Test Set Metrics: #&gt; ===================== #&gt; #&gt; MSE: (Extract with `h2o.mse`) 0.0559 #&gt; RMSE: (Extract with `h2o.rmse`) 0.236 #&gt; Logloss: (Extract with `h2o.logloss`) 0.185 #&gt; Mean Per-Class Error: 0.12 #&gt; Confusion Matrix: Extract with `h2o.confusionMatrix(&lt;model&gt;, &lt;data&gt;)`) #&gt; ========================================================================= #&gt; Confusion Matrix: Row labels: Actual class; Column labels: Predicted class #&gt; class_1 class_2 class_3 class_4 class_5 class_6 class_7 Error #&gt; class_1 116738 9573 4 0 112 39 654 0.0817 #&gt; class_2 8048 160229 582 2 807 550 124 0.0594 #&gt; class_3 3 324 20292 159 47 617 0 0.0536 #&gt; class_4 0 0 203 1382 0 73 0 0.1665 #&gt; class_5 117 970 123 0 4484 26 0 0.2161 #&gt; class_6 27 334 1548 43 23 8458 0 0.1893 #&gt; class_7 881 62 0 0 3 0 11354 0.0769 #&gt; Totals 125814 171492 22752 1586 5476 9763 12132 0.0747 #&gt; Rate #&gt; class_1 = 10,382 / 127,120 #&gt; class_2 = 10,113 / 170,342 #&gt; class_3 = 1,150 / 21,442 #&gt; class_4 = 276 / 1,658 #&gt; class_5 = 1,236 / 5,720 #&gt; class_6 = 1,975 / 10,433 #&gt; class_7 = 946 / 12,300 #&gt; Totals = 26,078 / 349,015 #&gt; #&gt; Hit Ratio Table: Extract with `h2o.hit_ratio_table(&lt;model&gt;, &lt;data&gt;)` #&gt; ======================================================================= #&gt; Top-7 Hit Ratios: #&gt; k hit_ratio #&gt; 1 1 0.925281 #&gt; 2 2 0.996845 #&gt; 3 3 0.999650 #&gt; 4 4 0.999946 #&gt; 5 5 1.000000 #&gt; 6 6 1.000000 #&gt; 7 7 1.000000 h2o.performance(m3, newdata=valid) ## full validation data #&gt; H2OMultinomialMetrics: deeplearning #&gt; #&gt; Test Set Metrics: #&gt; ===================== #&gt; #&gt; MSE: (Extract with `h2o.mse`) 0.0623 #&gt; RMSE: (Extract with `h2o.rmse`) 0.25 #&gt; Logloss: (Extract with `h2o.logloss`) 0.207 #&gt; Mean Per-Class Error: 0.133 #&gt; Confusion Matrix: Extract with `h2o.confusionMatrix(&lt;model&gt;, &lt;data&gt;)`) #&gt; ========================================================================= #&gt; Confusion Matrix: Row labels: Actual class; Column labels: Predicted class #&gt; class_1 class_2 class_3 class_4 class_5 class_6 class_7 Error #&gt; class_1 38617 3591 1 0 41 17 233 0.0914 #&gt; class_2 2932 52652 203 2 326 217 48 0.0661 #&gt; class_3 1 128 6713 68 16 217 0 0.0602 #&gt; class_4 0 0 67 465 0 30 0 0.1726 #&gt; class_5 48 357 45 0 1406 14 0 0.2481 #&gt; class_6 7 125 562 16 13 2741 0 0.2087 #&gt; class_7 334 20 0 0 1 0 3744 0.0866 #&gt; Totals 41939 56873 7591 551 1803 3236 4025 0.0834 #&gt; Rate #&gt; class_1 = 3,883 / 42,500 #&gt; class_2 = 3,728 / 56,380 #&gt; class_3 = 430 / 7,143 #&gt; class_4 = 97 / 562 #&gt; class_5 = 464 / 1,870 #&gt; class_6 = 723 / 3,464 #&gt; class_7 = 355 / 4,099 #&gt; Totals = 9,680 / 116,018 #&gt; #&gt; Hit Ratio Table: Extract with `h2o.hit_ratio_table(&lt;model&gt;, &lt;data&gt;)` #&gt; ======================================================================= #&gt; Top-7 Hit Ratios: #&gt; k hit_ratio #&gt; 1 1 0.916565 #&gt; 2 2 0.995776 #&gt; 3 3 0.999474 #&gt; 4 4 0.999948 #&gt; 5 5 1.000000 #&gt; 6 6 1.000000 #&gt; 7 7 1.000000 h2o.performance(m3, newdata=test) ## full test data #&gt; H2OMultinomialMetrics: deeplearning #&gt; #&gt; Test Set Metrics: #&gt; ===================== #&gt; #&gt; MSE: (Extract with `h2o.mse`) 0.0616 #&gt; RMSE: (Extract with `h2o.rmse`) 0.248 #&gt; Logloss: (Extract with `h2o.logloss`) 0.204 #&gt; Mean Per-Class Error: 0.135 #&gt; Confusion Matrix: Extract with `h2o.confusionMatrix(&lt;model&gt;, &lt;data&gt;)`) #&gt; ========================================================================= #&gt; Confusion Matrix: Row labels: Actual class; Column labels: Predicted class #&gt; class_1 class_2 class_3 class_4 class_5 class_6 class_7 Error #&gt; class_1 38498 3444 2 0 39 8 229 0.0882 #&gt; class_2 2913 52842 223 0 312 237 52 0.0660 #&gt; class_3 0 151 6704 70 16 228 0 0.0649 #&gt; class_4 0 1 72 431 0 23 0 0.1822 #&gt; class_5 44 362 38 0 1443 16 0 0.2417 #&gt; class_6 18 126 533 19 14 2760 0 0.2046 #&gt; class_7 370 18 0 0 0 0 3723 0.0944 #&gt; Totals 41843 56944 7572 520 1824 3272 4004 0.0826 #&gt; Rate #&gt; class_1 = 3,722 / 42,220 #&gt; class_2 = 3,737 / 56,579 #&gt; class_3 = 465 / 7,169 #&gt; class_4 = 96 / 527 #&gt; class_5 = 460 / 1,903 #&gt; class_6 = 710 / 3,470 #&gt; class_7 = 388 / 4,111 #&gt; Totals = 9,578 / 115,979 #&gt; #&gt; Hit Ratio Table: Extract with `h2o.hit_ratio_table(&lt;model&gt;, &lt;data&gt;)` #&gt; ======================================================================= #&gt; Top-7 Hit Ratios: #&gt; k hit_ratio #&gt; 1 1 0.917416 #&gt; 2 2 0.995637 #&gt; 3 3 0.999629 #&gt; 4 4 0.999905 #&gt; 5 5 0.999991 #&gt; 6 6 1.000000 #&gt; 7 7 1.000000 To confirm that the reported confusion matrix on the validation set (here, the test set) was correct, we make a prediction on the test set and compare the confusion matrices explicitly: pred &lt;- h2o.predict(m3, test) #&gt; | | | 0% | |=================================================================| 100% pred #&gt; predict class_1 class_2 class_3 class_4 class_5 class_6 class_7 #&gt; 1 class_2 2.89e-01 7.11e-01 5.72e-06 5.53e-05 2.95e-06 1.77e-04 4.25e-06 #&gt; 2 class_1 1.00e+00 1.42e-05 3.75e-09 1.61e-08 2.48e-08 3.49e-07 1.46e-07 #&gt; 3 class_1 1.00e+00 8.42e-05 8.32e-10 3.67e-08 3.25e-11 5.82e-08 7.26e-06 #&gt; 4 class_1 9.99e-01 6.13e-04 4.34e-06 1.07e-06 2.06e-07 4.63e-06 1.31e-05 #&gt; 5 class_2 5.56e-02 9.42e-01 2.91e-04 2.35e-06 2.20e-03 2.66e-05 9.69e-06 #&gt; 6 class_5 6.35e-05 6.18e-02 2.77e-05 2.05e-06 9.38e-01 8.65e-09 3.02e-07 #&gt; #&gt; [115979 rows x 8 columns] test$Accuracy &lt;- pred$predict == test$Cover_Type 1-mean(test$Accuracy) #&gt; [1] 0.0826 5.5.6 Hyper-parameter Tuning with Grid Search Since there are a lot of parameters that can impact model accuracy, hyper-parameter tuning is especially important for Deep Learning: For speed, we will only train on the first 10,000 rows of the training dataset: sampled_train=train[1:10000,] The simplest hyperparameter search method is a brute-force scan of the full Cartesian product of all combinations specified by a grid search: hyper_params &lt;- list( hidden=list(c(32,32,32),c(64,64)), input_dropout_ratio=c(0,0.05), rate=c(0.01,0.02), rate_annealing=c(1e-8,1e-7,1e-6) ) hyper_params #&gt; $hidden #&gt; $hidden[[1]] #&gt; [1] 32 32 32 #&gt; #&gt; $hidden[[2]] #&gt; [1] 64 64 #&gt; #&gt; #&gt; $input_dropout_ratio #&gt; [1] 0.00 0.05 #&gt; #&gt; $rate #&gt; [1] 0.01 0.02 #&gt; #&gt; $rate_annealing #&gt; [1] 1e-08 1e-07 1e-06 grid &lt;- h2o.grid( algorithm=&quot;deeplearning&quot;, grid_id=&quot;dl_grid&quot;, training_frame=sampled_train, validation_frame=valid, x=predictors, y=response, epochs=10, stopping_metric=&quot;misclassification&quot;, stopping_tolerance=1e-2, ## stop when misclassification does not improve by &gt;=1% for 2 scoring events stopping_rounds=2, score_validation_samples=10000, ## downsample validation set for faster scoring score_duty_cycle=0.025, ## don&#39;t score more than 2.5% of the wall time adaptive_rate=F, ## manually tuned learning rate momentum_start=0.5, ## manually tuned momentum momentum_stable=0.9, momentum_ramp=1e7, l1=1e-5, l2=1e-5, activation=c(&quot;Rectifier&quot;), max_w2=10, ## can help improve stability for Rectifier hyper_params=hyper_params ) #&gt; | | | 0% | |=== | 5% | |===== | 8% | |======== | 13% | |=========== | 16% | |============== | 21% | |================= | 26% | |==================== | 31% | |======================= | 35% | |========================= | 39% | |============================ | 43% | |=============================== | 47% | |================================= | 51% | |===================================== | 57% | |======================================== | 62% | |=========================================== | 66% | |============================================== | 71% | |================================================ | 75% | |=================================================== | 79% | |====================================================== | 83% | |========================================================= | 88% | |============================================================ | 92% | |=============================================================== | 98% | |=================================================================| 100% grid #&gt; H2O Grid Details #&gt; ================ #&gt; #&gt; Grid ID: dl_grid #&gt; Used hyper parameters: #&gt; - hidden #&gt; - input_dropout_ratio #&gt; - rate #&gt; - rate_annealing #&gt; Number of models: 24 #&gt; Number of failed models: 0 #&gt; #&gt; Hyper-Parameter Search Summary: ordered by increasing logloss #&gt; hidden input_dropout_ratio rate rate_annealing model_ids #&gt; 1 [64, 64] 0.0 0.01 1.0E-6 dl_grid_model_18 #&gt; 2 [64, 64] 0.05 0.01 1.0E-8 dl_grid_model_4 #&gt; 3 [64, 64] 0.0 0.01 1.0E-8 dl_grid_model_2 #&gt; 4 [32, 32, 32] 0.0 0.01 1.0E-6 dl_grid_model_17 #&gt; 5 [64, 64] 0.0 0.02 1.0E-8 dl_grid_model_6 #&gt; logloss #&gt; 1 0.5618605271020779 #&gt; 2 0.572902728804771 #&gt; 3 0.5761586614752959 #&gt; 4 0.5801724572823488 #&gt; 5 0.5814099351932657 #&gt; #&gt; --- #&gt; hidden input_dropout_ratio rate rate_annealing model_ids #&gt; 19 [32, 32, 32] 0.05 0.01 1.0E-7 dl_grid_model_11 #&gt; 20 [64, 64] 0.05 0.02 1.0E-7 dl_grid_model_16 #&gt; 21 [32, 32, 32] 0.0 0.02 1.0E-7 dl_grid_model_13 #&gt; 22 [32, 32, 32] 0.05 0.02 1.0E-6 dl_grid_model_23 #&gt; 23 [32, 32, 32] 0.05 0.02 1.0E-8 dl_grid_model_7 #&gt; 24 [32, 32, 32] 0.0 0.02 1.0E-6 dl_grid_model_21 #&gt; logloss #&gt; 19 0.629487796033131 #&gt; 20 0.6295385203022523 #&gt; 21 0.6298958759921242 #&gt; 22 0.640911514586607 #&gt; 23 0.6449045470153191 #&gt; 24 0.6546427560160966 Let’s see which model had the lowest validation error: grid &lt;- h2o.getGrid(&quot;dl_grid&quot;,sort_by=&quot;err&quot;,decreasing=FALSE) grid #&gt; H2O Grid Details #&gt; ================ #&gt; #&gt; Grid ID: dl_grid #&gt; Used hyper parameters: #&gt; - hidden #&gt; - input_dropout_ratio #&gt; - rate #&gt; - rate_annealing #&gt; Number of models: 24 #&gt; Number of failed models: 0 #&gt; #&gt; Hyper-Parameter Search Summary: ordered by increasing err #&gt; hidden input_dropout_ratio rate rate_annealing model_ids #&gt; 1 [64, 64] 0.0 0.01 1.0E-6 dl_grid_model_18 #&gt; 2 [64, 64] 0.0 0.01 1.0E-8 dl_grid_model_2 #&gt; 3 [32, 32, 32] 0.0 0.01 1.0E-6 dl_grid_model_17 #&gt; 4 [64, 64] 0.0 0.02 1.0E-8 dl_grid_model_6 #&gt; 5 [64, 64] 0.05 0.01 1.0E-8 dl_grid_model_4 #&gt; err #&gt; 1 0.2375524895020996 #&gt; 2 0.23998405421566674 #&gt; 3 0.2474879421221865 #&gt; 4 0.2486984381257509 #&gt; 5 0.25027552349463983 #&gt; #&gt; --- #&gt; hidden input_dropout_ratio rate rate_annealing model_ids #&gt; 19 [32, 32, 32] 0.0 0.01 1.0E-7 dl_grid_model_9 #&gt; 20 [32, 32, 32] 0.05 0.02 1.0E-6 dl_grid_model_23 #&gt; 21 [64, 64] 0.05 0.01 1.0E-7 dl_grid_model_12 #&gt; 22 [64, 64] 0.05 0.02 1.0E-7 dl_grid_model_16 #&gt; 23 [32, 32, 32] 0.0 0.02 1.0E-6 dl_grid_model_21 #&gt; 24 [32, 32, 32] 0.05 0.02 1.0E-8 dl_grid_model_7 #&gt; err #&gt; 19 0.2664463802943827 #&gt; 20 0.26938003781470793 #&gt; 21 0.2696830775363763 #&gt; 22 0.2722523608599558 #&gt; 23 0.28170426065162907 #&gt; 24 0.2853138452297527 ## To see what other &quot;sort_by&quot; criteria are allowed #grid &lt;- h2o.getGrid(&quot;dl_grid&quot;,sort_by=&quot;wrong_thing&quot;,decreasing=FALSE) ## Sort by logloss h2o.getGrid(&quot;dl_grid&quot;,sort_by=&quot;logloss&quot;,decreasing=FALSE) #&gt; H2O Grid Details #&gt; ================ #&gt; #&gt; Grid ID: dl_grid #&gt; Used hyper parameters: #&gt; - hidden #&gt; - input_dropout_ratio #&gt; - rate #&gt; - rate_annealing #&gt; Number of models: 24 #&gt; Number of failed models: 0 #&gt; #&gt; Hyper-Parameter Search Summary: ordered by increasing logloss #&gt; hidden input_dropout_ratio rate rate_annealing model_ids #&gt; 1 [64, 64] 0.0 0.01 1.0E-6 dl_grid_model_18 #&gt; 2 [64, 64] 0.05 0.01 1.0E-8 dl_grid_model_4 #&gt; 3 [64, 64] 0.0 0.01 1.0E-8 dl_grid_model_2 #&gt; 4 [32, 32, 32] 0.0 0.01 1.0E-6 dl_grid_model_17 #&gt; 5 [64, 64] 0.0 0.02 1.0E-8 dl_grid_model_6 #&gt; logloss #&gt; 1 0.5618605271020779 #&gt; 2 0.572902728804771 #&gt; 3 0.5761586614752959 #&gt; 4 0.5801724572823488 #&gt; 5 0.5814099351932657 #&gt; #&gt; --- #&gt; hidden input_dropout_ratio rate rate_annealing model_ids #&gt; 19 [32, 32, 32] 0.05 0.01 1.0E-7 dl_grid_model_11 #&gt; 20 [64, 64] 0.05 0.02 1.0E-7 dl_grid_model_16 #&gt; 21 [32, 32, 32] 0.0 0.02 1.0E-7 dl_grid_model_13 #&gt; 22 [32, 32, 32] 0.05 0.02 1.0E-6 dl_grid_model_23 #&gt; 23 [32, 32, 32] 0.05 0.02 1.0E-8 dl_grid_model_7 #&gt; 24 [32, 32, 32] 0.0 0.02 1.0E-6 dl_grid_model_21 #&gt; logloss #&gt; 19 0.629487796033131 #&gt; 20 0.6295385203022523 #&gt; 21 0.6298958759921242 #&gt; 22 0.640911514586607 #&gt; 23 0.6449045470153191 #&gt; 24 0.6546427560160966 ## Find the best model and its full set of parameters grid@summary_table[1,] #&gt; Hyper-Parameter Search Summary: ordered by increasing err #&gt; hidden input_dropout_ratio rate rate_annealing model_ids #&gt; 1 [64, 64] 0.0 0.01 1.0E-6 dl_grid_model_18 #&gt; err #&gt; 1 0.2375524895020996 best_model &lt;- h2o.getModel(grid@model_ids[[1]]) best_model #&gt; Model Details: #&gt; ============== #&gt; #&gt; H2OMultinomialModel: deeplearning #&gt; Model ID: dl_grid_model_18 #&gt; Status of Neuron Layers: predicting Cover_Type, 7-class classification, multinomial distribution, CrossEntropy loss, 8,263 weights/biases, 72.5 KB, 100,000 training samples, mini-batch size 1 #&gt; layer units type dropout l1 l2 mean_rate rate_rms #&gt; 1 1 56 Input 0.00 % NA NA NA NA #&gt; 2 2 64 Rectifier 0.00 % 0.000010 0.000010 0.009091 0.000000 #&gt; 3 3 64 Rectifier 0.00 % 0.000010 0.000010 0.009091 0.000000 #&gt; 4 4 7 Softmax NA 0.000010 0.000010 0.009091 0.000000 #&gt; momentum mean_weight weight_rms mean_bias bias_rms #&gt; 1 NA NA NA NA NA #&gt; 2 0.504000 -0.013996 0.207411 0.167479 0.126126 #&gt; 3 0.504000 -0.053521 0.182685 0.862394 0.121009 #&gt; 4 0.504000 0.001140 0.393659 -0.007795 0.487922 #&gt; #&gt; #&gt; H2OMultinomialMetrics: deeplearning #&gt; ** Reported on training data. ** #&gt; ** Metrics reported on full training frame ** #&gt; #&gt; Training Set Metrics: #&gt; ===================== #&gt; #&gt; Extract training frame with `h2o.getFrame(&quot;RTMP_sid_a417_9&quot;)` #&gt; MSE: (Extract with `h2o.mse`) 0.161 #&gt; RMSE: (Extract with `h2o.rmse`) 0.401 #&gt; Logloss: (Extract with `h2o.logloss`) 0.5 #&gt; Mean Per-Class Error: 0.414 #&gt; Confusion Matrix: Extract with `h2o.confusionMatrix(&lt;model&gt;,train = TRUE)`) #&gt; ========================================================================= #&gt; Confusion Matrix: Row labels: Actual class; Column labels: Predicted class #&gt; class_1 class_2 class_3 class_4 class_5 class_6 class_7 Error #&gt; class_1 2755 872 1 0 0 0 60 0.2530 #&gt; class_2 639 4100 76 0 4 8 8 0.1520 #&gt; class_3 0 36 591 0 0 3 0 0.0619 #&gt; class_4 0 0 24 19 0 1 0 0.5682 #&gt; class_5 15 106 5 0 30 0 0 0.8077 #&gt; class_6 0 66 193 0 0 50 0 0.8382 #&gt; class_7 72 1 0 0 0 0 265 0.2160 #&gt; Totals 3481 5181 890 19 34 62 333 0.2190 #&gt; Rate #&gt; class_1 = 933 / 3,688 #&gt; class_2 = 735 / 4,835 #&gt; class_3 = 39 / 630 #&gt; class_4 = 25 / 44 #&gt; class_5 = 126 / 156 #&gt; class_6 = 259 / 309 #&gt; class_7 = 73 / 338 #&gt; Totals = 2,190 / 10,000 #&gt; #&gt; Hit Ratio Table: Extract with `h2o.hit_ratio_table(&lt;model&gt;,train = TRUE)` #&gt; ======================================================================= #&gt; Top-7 Hit Ratios: #&gt; k hit_ratio #&gt; 1 1 0.781000 #&gt; 2 2 0.979600 #&gt; 3 3 0.997600 #&gt; 4 4 0.999500 #&gt; 5 5 0.999800 #&gt; 6 6 1.000000 #&gt; 7 7 1.000000 #&gt; #&gt; #&gt; H2OMultinomialMetrics: deeplearning #&gt; ** Reported on validation data. ** #&gt; ** Metrics reported on temporary validation frame with 10002 samples ** #&gt; #&gt; Validation Set Metrics: #&gt; ===================== #&gt; #&gt; MSE: (Extract with `h2o.mse`) 0.177 #&gt; RMSE: (Extract with `h2o.rmse`) 0.421 #&gt; Logloss: (Extract with `h2o.logloss`) 0.562 #&gt; Mean Per-Class Error: 0.462 #&gt; Confusion Matrix: Extract with `h2o.confusionMatrix(&lt;model&gt;,valid = TRUE)`) #&gt; ========================================================================= #&gt; Confusion Matrix: Row labels: Actual class; Column labels: Predicted class #&gt; class_1 class_2 class_3 class_4 class_5 class_6 class_7 Error #&gt; class_1 2631 949 0 0 0 1 58 0.2770 #&gt; class_2 672 4092 85 0 12 12 12 0.1623 #&gt; class_3 0 53 566 3 0 4 0 0.0958 #&gt; class_4 0 1 36 16 0 0 0 0.6981 #&gt; class_5 15 103 8 0 22 0 0 0.8514 #&gt; class_6 1 77 180 3 0 29 0 0.9000 #&gt; class_7 89 2 0 0 0 0 270 0.2521 #&gt; Totals 3408 5277 875 22 34 46 340 0.2376 #&gt; Rate #&gt; class_1 = 1,008 / 3,639 #&gt; class_2 = 793 / 4,885 #&gt; class_3 = 60 / 626 #&gt; class_4 = 37 / 53 #&gt; class_5 = 126 / 148 #&gt; class_6 = 261 / 290 #&gt; class_7 = 91 / 361 #&gt; Totals = 2,376 / 10,002 #&gt; #&gt; Hit Ratio Table: Extract with `h2o.hit_ratio_table(&lt;model&gt;,valid = TRUE)` #&gt; ======================================================================= #&gt; Top-7 Hit Ratios: #&gt; k hit_ratio #&gt; 1 1 0.762448 #&gt; 2 2 0.972706 #&gt; 3 3 0.995501 #&gt; 4 4 0.998300 #&gt; 5 5 0.999600 #&gt; 6 6 1.000000 #&gt; 7 7 1.000000 print(best_model@allparameters) #&gt; $model_id #&gt; [1] &quot;dl_grid_model_18&quot; #&gt; #&gt; $training_frame #&gt; [1] &quot;RTMP_sid_a417_9&quot; #&gt; #&gt; $validation_frame #&gt; [1] &quot;valid.hex&quot; #&gt; #&gt; $nfolds #&gt; [1] 0 #&gt; #&gt; $keep_cross_validation_models #&gt; [1] TRUE #&gt; #&gt; $keep_cross_validation_predictions #&gt; [1] FALSE #&gt; #&gt; $keep_cross_validation_fold_assignment #&gt; [1] FALSE #&gt; #&gt; $fold_assignment #&gt; [1] &quot;AUTO&quot; #&gt; #&gt; $ignore_const_cols #&gt; [1] TRUE #&gt; #&gt; $score_each_iteration #&gt; [1] FALSE #&gt; #&gt; $balance_classes #&gt; [1] FALSE #&gt; #&gt; $max_after_balance_size #&gt; [1] 5 #&gt; #&gt; $max_confusion_matrix_size #&gt; [1] 20 #&gt; #&gt; $max_hit_ratio_k #&gt; [1] 0 #&gt; #&gt; $overwrite_with_best_model #&gt; [1] TRUE #&gt; #&gt; $use_all_factor_levels #&gt; [1] TRUE #&gt; #&gt; $standardize #&gt; [1] TRUE #&gt; #&gt; $activation #&gt; [1] &quot;Rectifier&quot; #&gt; #&gt; $hidden #&gt; [1] 64 64 #&gt; #&gt; $epochs #&gt; [1] 10 #&gt; #&gt; $train_samples_per_iteration #&gt; [1] -2 #&gt; #&gt; $target_ratio_comm_to_comp #&gt; [1] 0.05 #&gt; #&gt; $seed #&gt; [1] -4.57e+16 #&gt; #&gt; $adaptive_rate #&gt; [1] FALSE #&gt; #&gt; $rho #&gt; [1] 0.99 #&gt; #&gt; $epsilon #&gt; [1] 1e-08 #&gt; #&gt; $rate #&gt; [1] 0.01 #&gt; #&gt; $rate_annealing #&gt; [1] 1e-06 #&gt; #&gt; $rate_decay #&gt; [1] 1 #&gt; #&gt; $momentum_start #&gt; [1] 0.5 #&gt; #&gt; $momentum_ramp #&gt; [1] 1e+07 #&gt; #&gt; $momentum_stable #&gt; [1] 0.9 #&gt; #&gt; $nesterov_accelerated_gradient #&gt; [1] TRUE #&gt; #&gt; $input_dropout_ratio #&gt; [1] 0 #&gt; #&gt; $l1 #&gt; [1] 1e-05 #&gt; #&gt; $l2 #&gt; [1] 1e-05 #&gt; #&gt; $max_w2 #&gt; [1] 10 #&gt; #&gt; $initial_weight_distribution #&gt; [1] &quot;UniformAdaptive&quot; #&gt; #&gt; $initial_weight_scale #&gt; [1] 1 #&gt; #&gt; $loss #&gt; [1] &quot;Automatic&quot; #&gt; #&gt; $distribution #&gt; [1] &quot;AUTO&quot; #&gt; #&gt; $quantile_alpha #&gt; [1] 0.5 #&gt; #&gt; $tweedie_power #&gt; [1] 1.5 #&gt; #&gt; $huber_alpha #&gt; [1] 0.9 #&gt; #&gt; $score_interval #&gt; [1] 5 #&gt; #&gt; $score_training_samples #&gt; [1] 10000 #&gt; #&gt; $score_validation_samples #&gt; [1] 10000 #&gt; #&gt; $score_duty_cycle #&gt; [1] 0.025 #&gt; #&gt; $classification_stop #&gt; [1] 0 #&gt; #&gt; $regression_stop #&gt; [1] 1e-06 #&gt; #&gt; $stopping_rounds #&gt; [1] 2 #&gt; #&gt; $stopping_metric #&gt; [1] &quot;misclassification&quot; #&gt; #&gt; $stopping_tolerance #&gt; [1] 0.01 #&gt; #&gt; $max_runtime_secs #&gt; [1] 1.8e+308 #&gt; #&gt; $score_validation_sampling #&gt; [1] &quot;Uniform&quot; #&gt; #&gt; $diagnostics #&gt; [1] TRUE #&gt; #&gt; $fast_mode #&gt; [1] TRUE #&gt; #&gt; $force_load_balance #&gt; [1] TRUE #&gt; #&gt; $variable_importances #&gt; [1] TRUE #&gt; #&gt; $replicate_training_data #&gt; [1] TRUE #&gt; #&gt; $single_node_mode #&gt; [1] FALSE #&gt; #&gt; $shuffle_training_data #&gt; [1] FALSE #&gt; #&gt; $missing_values_handling #&gt; [1] &quot;MeanImputation&quot; #&gt; #&gt; $quiet_mode #&gt; [1] FALSE #&gt; #&gt; $autoencoder #&gt; [1] FALSE #&gt; #&gt; $sparse #&gt; [1] FALSE #&gt; #&gt; $col_major #&gt; [1] FALSE #&gt; #&gt; $average_activation #&gt; [1] 0 #&gt; #&gt; $sparsity_beta #&gt; [1] 0 #&gt; #&gt; $max_categorical_features #&gt; [1] 2147483647 #&gt; #&gt; $reproducible #&gt; [1] FALSE #&gt; #&gt; $export_weights_and_biases #&gt; [1] FALSE #&gt; #&gt; $mini_batch_size #&gt; [1] 1 #&gt; #&gt; $categorical_encoding #&gt; [1] &quot;AUTO&quot; #&gt; #&gt; $elastic_averaging #&gt; [1] FALSE #&gt; #&gt; $elastic_averaging_moving_rate #&gt; [1] 0.9 #&gt; #&gt; $elastic_averaging_regularization #&gt; [1] 0.001 #&gt; #&gt; $x #&gt; [1] &quot;Soil_Type&quot; #&gt; [2] &quot;Wilderness_Area&quot; #&gt; [3] &quot;Elevation&quot; #&gt; [4] &quot;Aspect&quot; #&gt; [5] &quot;Slope&quot; #&gt; [6] &quot;Horizontal_Distance_To_Hydrology&quot; #&gt; [7] &quot;Vertical_Distance_To_Hydrology&quot; #&gt; [8] &quot;Horizontal_Distance_To_Roadways&quot; #&gt; [9] &quot;Hillshade_9am&quot; #&gt; [10] &quot;Hillshade_Noon&quot; #&gt; [11] &quot;Hillshade_3pm&quot; #&gt; [12] &quot;Horizontal_Distance_To_Fire_Points&quot; #&gt; #&gt; $y #&gt; [1] &quot;Cover_Type&quot; print(h2o.performance(best_model, valid=T)) #&gt; H2OMultinomialMetrics: deeplearning #&gt; ** Reported on validation data. ** #&gt; ** Metrics reported on temporary validation frame with 10002 samples ** #&gt; #&gt; Validation Set Metrics: #&gt; ===================== #&gt; #&gt; MSE: (Extract with `h2o.mse`) 0.177 #&gt; RMSE: (Extract with `h2o.rmse`) 0.421 #&gt; Logloss: (Extract with `h2o.logloss`) 0.562 #&gt; Mean Per-Class Error: 0.462 #&gt; Confusion Matrix: Extract with `h2o.confusionMatrix(&lt;model&gt;,valid = TRUE)`) #&gt; ========================================================================= #&gt; Confusion Matrix: Row labels: Actual class; Column labels: Predicted class #&gt; class_1 class_2 class_3 class_4 class_5 class_6 class_7 Error #&gt; class_1 2631 949 0 0 0 1 58 0.2770 #&gt; class_2 672 4092 85 0 12 12 12 0.1623 #&gt; class_3 0 53 566 3 0 4 0 0.0958 #&gt; class_4 0 1 36 16 0 0 0 0.6981 #&gt; class_5 15 103 8 0 22 0 0 0.8514 #&gt; class_6 1 77 180 3 0 29 0 0.9000 #&gt; class_7 89 2 0 0 0 0 270 0.2521 #&gt; Totals 3408 5277 875 22 34 46 340 0.2376 #&gt; Rate #&gt; class_1 = 1,008 / 3,639 #&gt; class_2 = 793 / 4,885 #&gt; class_3 = 60 / 626 #&gt; class_4 = 37 / 53 #&gt; class_5 = 126 / 148 #&gt; class_6 = 261 / 290 #&gt; class_7 = 91 / 361 #&gt; Totals = 2,376 / 10,002 #&gt; #&gt; Hit Ratio Table: Extract with `h2o.hit_ratio_table(&lt;model&gt;,valid = TRUE)` #&gt; ======================================================================= #&gt; Top-7 Hit Ratios: #&gt; k hit_ratio #&gt; 1 1 0.762448 #&gt; 2 2 0.972706 #&gt; 3 3 0.995501 #&gt; 4 4 0.998300 #&gt; 5 5 0.999600 #&gt; 6 6 1.000000 #&gt; 7 7 1.000000 print(h2o.logloss(best_model, valid=T)) #&gt; [1] 0.562 5.5.7 Random Hyper-Parameter Search Often, hyper-parameter search for more than 4 parameters can be done more efficiently with random parameter search than with grid search. Basically, chances are good to find one of many good models in less time than performing an exhaustive grid search. We simply build up to max_models models with parameters drawn randomly from user-specified distributions (here, uniform). For this example, we use the adaptive learning rate and focus on tuning the network architecture and the regularization parameters. We also let the grid search stop automatically once the performance at the top of the leaderboard doesn’t change much anymore, i.e., once the search has converged. hyper_params &lt;- list( activation=c(&quot;Rectifier&quot;,&quot;Tanh&quot;,&quot;Maxout&quot;,&quot;RectifierWithDropout&quot;,&quot;TanhWithDropout&quot;,&quot;MaxoutWithDropout&quot;), hidden=list(c(20,20),c(50,50),c(30,30,30),c(25,25,25,25)), input_dropout_ratio=c(0,0.05), l1=seq(0,1e-4,1e-6), l2=seq(0,1e-4,1e-6) ) hyper_params ## Stop once the top 5 models are within 1% of each other (i.e., the windowed average varies less than 1%) search_criteria = list(strategy = &quot;RandomDiscrete&quot;, max_runtime_secs = 360, max_models = 100, seed=1234567, stopping_rounds=5, stopping_tolerance=1e-2) dl_random_grid &lt;- h2o.grid( algorithm=&quot;deeplearning&quot;, grid_id = &quot;dl_grid_random&quot;, training_frame=sampled_train, validation_frame=valid, x=predictors, y=response, epochs=1, stopping_metric=&quot;logloss&quot;, stopping_tolerance=1e-2, ## stop when logloss does not improve by &gt;=1% for 2 scoring events stopping_rounds=2, score_validation_samples=10000, ## downsample validation set for faster scoring score_duty_cycle=0.025, ## don&#39;t score more than 2.5% of the wall time max_w2=10, ## can help improve stability for Rectifier hyper_params = hyper_params, search_criteria = search_criteria ) grid &lt;- h2o.getGrid(&quot;dl_grid_random&quot;,sort_by=&quot;logloss&quot;,decreasing=FALSE) grid grid@summary_table[1,] best_model &lt;- h2o.getModel(grid@model_ids[[1]]) ## model with lowest logloss best_model Let’s look at the model with the lowest validation misclassification rate: grid &lt;- h2o.getGrid(&quot;dl_grid&quot;,sort_by=&quot;err&quot;,decreasing=FALSE) best_model &lt;- h2o.getModel(grid@model_ids[[1]]) ## model with lowest classification error (on validation, since it was available during training) h2o.confusionMatrix(best_model,valid=T) #&gt; Confusion Matrix: Row labels: Actual class; Column labels: Predicted class #&gt; class_1 class_2 class_3 class_4 class_5 class_6 class_7 Error #&gt; class_1 2631 949 0 0 0 1 58 0.2770 #&gt; class_2 672 4092 85 0 12 12 12 0.1623 #&gt; class_3 0 53 566 3 0 4 0 0.0958 #&gt; class_4 0 1 36 16 0 0 0 0.6981 #&gt; class_5 15 103 8 0 22 0 0 0.8514 #&gt; class_6 1 77 180 3 0 29 0 0.9000 #&gt; class_7 89 2 0 0 0 0 270 0.2521 #&gt; Totals 3408 5277 875 22 34 46 340 0.2376 #&gt; Rate #&gt; class_1 = 1,008 / 3,639 #&gt; class_2 = 793 / 4,885 #&gt; class_3 = 60 / 626 #&gt; class_4 = 37 / 53 #&gt; class_5 = 126 / 148 #&gt; class_6 = 261 / 290 #&gt; class_7 = 91 / 361 #&gt; Totals = 2,376 / 10,002 best_params &lt;- best_model@allparameters best_params$activation #&gt; [1] &quot;Rectifier&quot; best_params$hidden #&gt; [1] 64 64 best_params$input_dropout_ratio #&gt; [1] 0 best_params$l1 #&gt; [1] 1e-05 best_params$l2 #&gt; [1] 1e-05 5.5.8 Checkpointing Let’s continue training the manually tuned model from before, for 2 more epochs. Note that since many important parameters such as epochs, l1, l2, max_w2, score_interval, train_samples_per_iteration, input_dropout_ratio, hidden_dropout_ratios, score_duty_cycle, classification_stop, regression_stop, variable_importances, force_load_balance can be modified between checkpoint restarts, it is best to specify as many parameters as possible explicitly. max_epochs &lt;- 12 ## Add two more epochs m_cont &lt;- h2o.deeplearning( model_id=&quot;dl_model_tuned_continued&quot;, checkpoint=&quot;dl_model_tuned&quot;, training_frame=train, validation_frame=valid, x=predictors, y=response, hidden=c(128,128,128), ## more hidden layers -&gt; more complex interactions epochs=max_epochs, ## hopefully long enough to converge (otherwise restart again) stopping_metric=&quot;logloss&quot;, ## logloss is directly optimized by Deep Learning stopping_tolerance=1e-2, ## stop when validation logloss does not improve by &gt;=1% for 2 scoring events stopping_rounds=2, score_validation_samples=10000, ## downsample validation set for faster scoring score_duty_cycle=0.025, ## don&#39;t score more than 2.5% of the wall time adaptive_rate=F, ## manually tuned learning rate rate=0.01, rate_annealing=2e-6, momentum_start=0.2, ## manually tuned momentum momentum_stable=0.4, momentum_ramp=1e7, l1=1e-5, ## add some L1/L2 regularization l2=1e-5, max_w2=10 ## helps stability for Rectifier ) summary(m_cont) plot(m_cont) Once we are satisfied with the results, we can save the model to disk (on the cluster). In this example, we store the model in a directory called mybest_deeplearning_covtype_model, which will be created for us since force=TRUE. path &lt;- h2o.saveModel(m_cont, path = file.path(data_out_dir, &quot;mybest_deeplearning_covtype_model&quot;), force=TRUE) It can be loaded later with the following command: print(path) #&gt; [1] &quot;/home/datascience/repos/machine-learning-rsuite/export/mybest_deeplearning_covtype_model/dl_model_tuned_continued&quot; m_loaded &lt;- h2o.loadModel(path) summary(m_loaded) #&gt; Model Details: #&gt; ============== #&gt; #&gt; H2OMultinomialModel: deeplearning #&gt; Model Key: dl_model_tuned_continued #&gt; Status of Neuron Layers: predicting Cover_Type, 7-class classification, multinomial distribution, CrossEntropy loss, 41,223 weights/biases, 334.1 KB, 4,200,519 training samples, mini-batch size 1 #&gt; layer units type dropout l1 l2 mean_rate rate_rms #&gt; 1 1 56 Input 0.00 % NA NA NA NA #&gt; 2 2 128 Rectifier 0.00 % 0.000010 0.000010 0.001064 0.000000 #&gt; 3 3 128 Rectifier 0.00 % 0.000010 0.000010 0.001064 0.000000 #&gt; 4 4 128 Rectifier 0.00 % 0.000010 0.000010 0.001064 0.000000 #&gt; 5 5 7 Softmax NA 0.000010 0.000010 0.001064 0.000000 #&gt; momentum mean_weight weight_rms mean_bias bias_rms #&gt; 1 NA NA NA NA NA #&gt; 2 0.284010 -0.017301 0.328908 -0.059557 0.338893 #&gt; 3 0.284010 -0.052717 0.226107 0.937802 0.383537 #&gt; 4 0.284010 -0.065329 0.220134 0.836975 0.173792 #&gt; 5 0.284010 -0.020685 0.271065 0.045344 0.956986 #&gt; #&gt; H2OMultinomialMetrics: deeplearning #&gt; ** Reported on training data. ** #&gt; ** Metrics reported on temporary training frame with 9915 samples ** #&gt; #&gt; Training Set Metrics: #&gt; ===================== #&gt; #&gt; MSE: (Extract with `h2o.mse`) 0.0516 #&gt; RMSE: (Extract with `h2o.rmse`) 0.227 #&gt; Logloss: (Extract with `h2o.logloss`) 0.17 #&gt; Mean Per-Class Error: 0.118 #&gt; Confusion Matrix: Extract with `h2o.confusionMatrix(&lt;model&gt;,train = TRUE)`) #&gt; ========================================================================= #&gt; Confusion Matrix: Row labels: Actual class; Column labels: Predicted class #&gt; class_1 class_2 class_3 class_4 class_5 class_6 class_7 Error #&gt; class_1 3355 227 0 0 3 0 13 0.0675 #&gt; class_2 268 4535 10 1 22 6 0 0.0634 #&gt; class_3 0 15 572 4 1 24 0 0.0714 #&gt; class_4 0 0 9 47 0 1 0 0.1754 #&gt; class_5 0 25 5 0 113 1 0 0.2153 #&gt; class_6 2 14 30 0 0 253 0 0.1538 #&gt; class_7 27 2 0 0 0 0 330 0.0808 #&gt; Totals 3652 4818 626 52 139 285 343 0.0716 #&gt; Rate #&gt; class_1 = 243 / 3,598 #&gt; class_2 = 307 / 4,842 #&gt; class_3 = 44 / 616 #&gt; class_4 = 10 / 57 #&gt; class_5 = 31 / 144 #&gt; class_6 = 46 / 299 #&gt; class_7 = 29 / 359 #&gt; Totals = 710 / 9,915 #&gt; #&gt; Hit Ratio Table: Extract with `h2o.hit_ratio_table(&lt;model&gt;,train = TRUE)` #&gt; ======================================================================= #&gt; Top-7 Hit Ratios: #&gt; k hit_ratio #&gt; 1 1 0.928391 #&gt; 2 2 0.997680 #&gt; 3 3 1.000000 #&gt; 4 4 1.000000 #&gt; 5 5 1.000000 #&gt; 6 6 1.000000 #&gt; 7 7 1.000000 #&gt; #&gt; #&gt; H2OMultinomialMetrics: deeplearning #&gt; ** Reported on validation data. ** #&gt; ** Metrics reported on temporary validation frame with 10000 samples ** #&gt; #&gt; Validation Set Metrics: #&gt; ===================== #&gt; #&gt; MSE: (Extract with `h2o.mse`) 0.0573 #&gt; RMSE: (Extract with `h2o.rmse`) 0.239 #&gt; Logloss: (Extract with `h2o.logloss`) 0.19 #&gt; Mean Per-Class Error: 0.135 #&gt; Confusion Matrix: Extract with `h2o.confusionMatrix(&lt;model&gt;,valid = TRUE)`) #&gt; ========================================================================= #&gt; Confusion Matrix: Row labels: Actual class; Column labels: Predicted class #&gt; class_1 class_2 class_3 class_4 class_5 class_6 class_7 Error #&gt; class_1 3410 246 0 0 4 0 8 0.0703 #&gt; class_2 303 4528 19 0 26 14 0 0.0740 #&gt; class_3 0 14 574 7 0 18 0 0.0636 #&gt; class_4 0 0 7 40 0 5 0 0.2308 #&gt; class_5 2 28 5 0 114 2 0 0.2450 #&gt; class_6 0 19 25 2 1 230 0 0.1697 #&gt; class_7 29 3 0 0 0 0 317 0.0917 #&gt; Totals 3744 4838 630 49 145 269 325 0.0787 #&gt; Rate #&gt; class_1 = 258 / 3,668 #&gt; class_2 = 362 / 4,890 #&gt; class_3 = 39 / 613 #&gt; class_4 = 12 / 52 #&gt; class_5 = 37 / 151 #&gt; class_6 = 47 / 277 #&gt; class_7 = 32 / 349 #&gt; Totals = 787 / 10,000 #&gt; #&gt; Hit Ratio Table: Extract with `h2o.hit_ratio_table(&lt;model&gt;,valid = TRUE)` #&gt; ======================================================================= #&gt; Top-7 Hit Ratios: #&gt; k hit_ratio #&gt; 1 1 0.921300 #&gt; 2 2 0.995800 #&gt; 3 3 0.999600 #&gt; 4 4 1.000000 #&gt; 5 5 1.000000 #&gt; 6 6 1.000000 #&gt; 7 7 1.000000 #&gt; #&gt; #&gt; #&gt; #&gt; Scoring History: #&gt; timestamp duration training_speed epochs #&gt; 1 2019-09-18 15:52:58 0.000 sec NA 0.00000 #&gt; 2 2019-09-18 15:53:04 5.874 sec 17786 obs/sec 0.28580 #&gt; 3 2019-09-18 15:53:15 17.380 sec 23616 obs/sec 1.14641 #&gt; 4 2019-09-18 15:53:22 24.609 sec 25023 obs/sec 1.71832 #&gt; 5 2019-09-18 15:53:33 35.207 sec 26176 obs/sec 2.57862 #&gt; 6 2019-09-18 15:53:43 45.649 sec 26894 obs/sec 3.43956 #&gt; 7 2019-09-18 15:53:56 58.187 sec 26321 obs/sec 4.29853 #&gt; 8 2019-09-18 15:54:03 1 min 5.478 sec 26535 obs/sec 4.87291 #&gt; 9 2019-09-18 15:54:14 1 min 15.775 sec 26966 obs/sec 5.73278 #&gt; 10 2019-09-18 15:54:24 1 min 25.937 sec 27328 obs/sec 6.59191 #&gt; 11 2019-09-18 15:54:34 1 min 35.975 sec 27652 obs/sec 7.45031 #&gt; 12 2019-09-18 15:54:44 1 min 46.110 sec 27891 obs/sec 8.30929 #&gt; 13 2019-09-18 15:54:55 1 min 57.427 sec 27806 obs/sec 9.16961 #&gt; 14 2019-09-18 15:55:06 2 min 7.974 sec 27899 obs/sec 10.02933 #&gt; 15 2019-09-18 15:56:16 2 min 12.116 sec 27824 obs/sec 10.31635 #&gt; 16 2019-09-18 15:56:24 2 min 19.655 sec 27798 obs/sec 10.89000 #&gt; 17 2019-09-18 15:56:36 2 min 31.672 sec 27601 obs/sec 11.74913 #&gt; 18 2019-09-18 15:56:40 2 min 35.802 sec 27550 obs/sec 12.03535 #&gt; iterations samples training_rmse training_logloss training_r2 #&gt; 1 0 0.000000 NA NA NA #&gt; 2 1 99748.000000 0.42237 0.55312 0.91032 #&gt; 3 4 400116.000000 0.36296 0.41016 0.93377 #&gt; 4 6 599719.000000 0.33585 0.35917 0.94330 #&gt; 5 9 899978.000000 0.31747 0.32316 0.94933 #&gt; 6 12 1200457.000000 0.29301 0.28009 0.95684 #&gt; 7 15 1500253.000000 0.28066 0.25732 0.96040 #&gt; 8 17 1700719.000000 0.27223 0.24098 0.96275 #&gt; 9 20 2000827.000000 0.26314 0.22777 0.96519 #&gt; 10 23 2300675.000000 0.25235 0.20993 0.96799 #&gt; 11 26 2600269.000000 0.25552 0.21299 0.96718 #&gt; 12 29 2900066.000000 0.24977 0.20583 0.96864 #&gt; 13 32 3200330.000000 0.24093 0.19157 0.97082 #&gt; 14 35 3500386.000000 0.24023 0.18839 0.97099 #&gt; 15 36 3600560.000000 0.23529 0.18202 0.97180 #&gt; 16 38 3800773.000000 0.23150 0.17772 0.97270 #&gt; 17 41 4100621.000000 0.22951 0.17459 0.97317 #&gt; 18 42 4200519.000000 0.22717 0.17041 0.97371 #&gt; training_classification_error validation_rmse validation_logloss #&gt; 1 NA NA NA #&gt; 2 0.23762 0.42810 0.56255 #&gt; 3 0.17784 0.36994 0.42483 #&gt; 4 0.15362 0.33674 0.36047 #&gt; 5 0.13393 0.31944 0.32746 #&gt; 6 0.11574 0.29946 0.29243 #&gt; 7 0.10650 0.28528 0.26399 #&gt; 8 0.09876 0.27914 0.25280 #&gt; 9 0.09113 0.27433 0.24427 #&gt; 10 0.08410 0.26502 0.23177 #&gt; 11 0.08882 0.26406 0.22956 #&gt; 12 0.08440 0.25638 0.21807 #&gt; 13 0.07787 0.24974 0.20773 #&gt; 14 0.08018 0.25150 0.20908 #&gt; 15 0.07564 0.24974 0.20582 #&gt; 16 0.07171 0.24465 0.19984 #&gt; 17 0.06889 0.24111 0.19326 #&gt; 18 0.07161 0.23935 0.18977 #&gt; validation_r2 validation_classification_error #&gt; 1 NA NA #&gt; 2 0.90796 0.24763 #&gt; 3 0.93127 0.18370 #&gt; 4 0.94305 0.15408 #&gt; 5 0.94875 0.13783 #&gt; 6 0.95496 0.12018 #&gt; 7 0.95913 0.11050 #&gt; 8 0.96087 0.10561 #&gt; 9 0.96221 0.10242 #&gt; 10 0.96473 0.09554 #&gt; 11 0.96498 0.09345 #&gt; 12 0.96699 0.08946 #&gt; 13 0.96868 0.08268 #&gt; 14 0.96823 0.08557 #&gt; 15 0.96716 0.08290 #&gt; 16 0.96848 0.08020 #&gt; 17 0.96939 0.08070 #&gt; 18 0.96984 0.07870 #&gt; #&gt; Variable Importances: (Extract with `h2o.varimp`) #&gt; ================================================= #&gt; #&gt; Variable Importances: #&gt; variable relative_importance scaled_importance #&gt; 1 Elevation 1.000000 1.000000 #&gt; 2 Horizontal_Distance_To_Fire_Points 0.905047 0.905047 #&gt; 3 Horizontal_Distance_To_Roadways 0.900960 0.900960 #&gt; 4 Wilderness_Area.area_0 0.656999 0.656999 #&gt; 5 Wilderness_Area.area_2 0.581994 0.581994 #&gt; percentage #&gt; 1 0.050474 #&gt; 2 0.045681 #&gt; 3 0.045475 #&gt; 4 0.033161 #&gt; 5 0.029376 #&gt; #&gt; --- #&gt; variable relative_importance scaled_importance #&gt; 51 Soil_Type.type_7 0.156338 0.156338 #&gt; 52 Soil_Type.type_24 0.154870 0.154870 #&gt; 53 Soil_Type.type_14 0.142213 0.142213 #&gt; 54 Soil_Type.type_6 0.141860 0.141860 #&gt; 55 Soil_Type.missing(NA) 0.000000 0.000000 #&gt; 56 Wilderness_Area.missing(NA) 0.000000 0.000000 #&gt; percentage #&gt; 51 0.007891 #&gt; 52 0.007817 #&gt; 53 0.007178 #&gt; 54 0.007160 #&gt; 55 0.000000 #&gt; 56 0.000000 This model is fully functional and can be inspected, restarted, or used to score a dataset, etc. Note that binary compatibility between H2O versions is currently not guaranteed. 5.5.9 Cross-Validation For N-fold cross-validation, specify nfolds&gt;1 instead of (or in addition to) a validation frame, and N+1 models will be built: 1 model on the full training data, and N models with each 1/N-th of the data held out (there are different holdout strategies). Those N models then score on the held out data, and their combined predictions on the full training data are scored to get the cross-validation metrics. dlmodel &lt;- h2o.deeplearning( x=predictors, y=response, training_frame=train, hidden=c(10,10), epochs=1, nfolds=5, fold_assignment=&quot;Modulo&quot; # can be &quot;AUTO&quot;, &quot;Modulo&quot;, &quot;Random&quot; or &quot;Stratified&quot; ) dlmodel N-fold cross-validation is especially useful with early stopping, as the main model will pick the ideal number of epochs from the convergence behavior of the cross-validation models. 5.6 Regression and Binary Classification Assume we want to turn the multi-class problem above into a binary classification problem. We create a binary response as follows: train$bin_response &lt;- ifelse(train[,response] == &quot;class_1&quot;, 0, 1) Let’s build a quick model and inspect the model: dlmodel &lt;- h2o.deeplearning( x=predictors, y=&quot;bin_response&quot;, training_frame=train, hidden=c(10,10), epochs=0.1 ) summary(dlmodel) Instead of a binary classification model, we find a regression model (H2ORegressionModel) that contains only 1 output neuron (instead of 2). The reason is that the response was a numerical feature (ordinal numbers 0 and 1), and H2O Deep Learning was run with distribution=AUTO, which defaulted to a Gaussian regression problem for a real-valued response. H2O Deep Learning supports regression for distributions other than Gaussian such as Poisson, Gamma, Tweedie, Laplace. It also supports Huber loss and per-row offsets specified via an offset_column. We refer to our H2O Deep Learning regression code examples for more information. To perform classification, the response must first be turned into a categorical (factor) feature: train$bin_response &lt;- as.factor(train$bin_response) ##make categorical dlmodel &lt;- h2o.deeplearning( x=predictors, y=&quot;bin_response&quot;, training_frame=train, hidden=c(10,10), epochs=0.1 #balance_classes=T ## enable this for high class imbalance ) summary(dlmodel) ## Now the model metrics contain AUC for binary classification plot(h2o.performance(dlmodel)) ## display ROC curve Now the model performs (binary) classification, and has multiple (2) output neurons. 5.7 Unsupervised Anomaly detection For instructions on how to build unsupervised models with H2O Deep Learning, we refer to our previous Tutorial on Anomaly Detection with H2O Deep Learning and our MNIST Anomaly detection code example, as well as our Stacked AutoEncoder R code example and another one for Unsupervised Pretraining with an AutoEncoder R code example. 5.8 H2O Deep Learning Tips &amp; Tricks 5.8.1 Performance Tuning The Definitive H2O Deep Learning Performance Tuning blog post covers many of the following points that affect the computational efficiency, so it’s highly recommended. 5.8.2 Activation Functions While sigmoids have been used historically for neural networks, H2O Deep Learning implements Tanh, a scaled and shifted variant of the sigmoid which is symmetric around 0. Since its output values are bounded by -1..1, the stability of the neural network is rarely endangered. However, the derivative of the tanh function is always non-zero and back-propagation (training) of the weights is more computationally expensive than for rectified linear units, or Rectifier, which is max(0,x) and has vanishing gradient for x&lt;=0, leading to much faster training speed for large networks and is often the fastest path to accuracy on larger problems. In case you encounter instabilities with the Rectifier (in which case model building is automatically aborted), try a limited value to re-scale the weights: max_w2=10. The Maxout activation function is computationally more expensive, but can lead to higher accuracy. It is a generalized version of the Rectifier with two non-zero channels. In practice, the Rectifier (and RectifierWithDropout, see below) is the most versatile and performant option for most problems. 5.8.3 Generalization Techniques L1 and L2 penalties can be applied by specifying the l1 and l2 parameters. Intuition: L1 lets only strong weights survive (constant pulling force towards zero), while L2 prevents any single weight from getting too big. Dropout has recently been introduced as a powerful generalization technique, and is available as a parameter per layer, including the input layer. input_dropout_ratio controls the amount of input layer neurons that are randomly dropped (set to zero), while hidden_dropout_ratios are specified for each hidden layer. The former controls overfitting with respect to the input data (useful for high-dimensional noisy data), while the latter controls overfitting of the learned features. Note that hidden_dropout_ratios require the activation function to end with …WithDropout. 5.8.4 Early stopping and optimizing for lowest validation error By default, Deep Learning training stops when the stopping_metric does not improve by at least stopping_tolerance (0.01 means 1% improvement) for stopping_rounds consecutive scoring events on the training (or validation) data. By default, overwrite_with_best_model is enabled and the model returned after training for the specified number of epochs (or after stopping early due to convergence) is the model that has the best training set error (according to the metric specified by stopping_metric), or, if a validation set is provided, the lowest validation set error. Note that the training or validation set errors can be based on a subset of the training or validation data, depending on the values for score_validation_samples or score_training_samples, see below. For early stopping on a predefined error rate on the training data (accuracy for classification or MSE for regression), specify classification_stop or regression_stop. 5.8.5 Training Samples per MapReduce Iteration The parameter train_samples_per_iteration matters especially in multi-node operation. It controls the number of rows trained on for each MapReduce iteration. Depending on the value selected, one MapReduce pass can sample observations, and multiple such passes are needed to train for one epoch. All H2O compute nodes then communicate to agree on the best model coefficients (weights/biases) so far, and the model may then be scored (controlled by other parameters below). The default value of -2 indicates auto-tuning, which attemps to keep the communication overhead at 5% of the total runtime. The parameter target_ratio_comm_to_comp controls this ratio. This parameter is explained in more detail in the H2O Deep Learning booklet, 5.8.6 Categorical Data For categorical data, a feature with K factor levels is automatically one-hot encoded (horizontalized) into K-1 input neurons. Hence, the input neuron layer can grow substantially for datasets with high factor counts. In these cases, it might make sense to reduce the number of hidden neurons in the first hidden layer, such that large numbers of factor levels can be handled. In the limit of 1 neuron in the first hidden layer, the resulting model is similar to logistic regression with stochastic gradient descent, except that for classification problems, there’s still a softmax output layer, and that the activation function is not necessarily a sigmoid (Tanh). If variable importances are computed, it is recommended to turn on use_all_factor_levels (K input neurons for K levels). The experimental option max_categorical_features uses feature hashing to reduce the number of input neurons via the hash trick at the expense of hash collisions and reduced accuracy. Another way to reduce the dimensionality of the (categorical) features is to use h2o.glrm(), we refer to the GLRM tutorial for more details. 5.8.7 Sparse Data If the input data is sparse (many zeros), then it might make sense to enable the sparse option. This will result in the input not being standardized (0 mean, 1 variance), but only de-scaled (1 variance) and 0 values remain 0, leading to more efficient back-propagation. Sparsity is also a reason why CPU implementations can be faster than GPU implementations, because they can take advantage of if/else statements more effectively. 5.8.8 Missing Values H2O Deep Learning automatically does mean imputation for missing values during training (leaving the input layer activation at 0 after standardizing the values). For testing, missing test set values are also treated the same way by default. See the h2o.impute function to do your own mean imputation. 5.8.9 Loss functions, Distributions, Offsets, Observation Weights H2O Deep Learning supports advanced statistical features such as multiple loss functions, non-Gaussian distributions, per-row offsets and observation weights. In addition to Gaussian distributions and Squared loss, H2O Deep Learning supports Poisson, Gamma, Tweedie and Laplace distributions. It also supports Absolute and Huber loss and per-row offsets specified via an offset_column. Observation weights are supported via a user-specified weights_column. We refer to our H2O Deep Learning R test code examples for more information. 5.8.10 Exporting Weights and Biases The model parameters (weights connecting two adjacent layers and per-neuron bias terms) can be stored as H2O Frames (like a dataset) by enabling export_weights_and_biases, and they can be accessed as follows: iris_dl &lt;- h2o.deeplearning(1:4,5,as.h2o(iris), export_weights_and_biases=T) #&gt; | | | 0% | |=================================================================| 100% #&gt; | | | 0% | |====== | 10% | |=================================================================| 100% h2o.weights(iris_dl, matrix_id=1) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 1 -0.0497 0.0916 -0.0200 0.1987 #&gt; 2 0.1536 0.0635 0.1136 -0.0389 #&gt; 3 -0.1475 0.0249 0.0808 -0.0770 #&gt; 4 0.1029 -0.0945 0.0409 0.0838 #&gt; 5 0.1619 0.0669 0.1563 0.0342 #&gt; 6 -0.0789 0.0448 -0.0923 0.0518 #&gt; #&gt; [200 rows x 4 columns] h2o.weights(iris_dl, matrix_id=2) #&gt; C1 C2 C3 C4 C5 C6 C7 C8 #&gt; 1 0.0731 -0.10087 0.0272 -1.05e-01 0.0509 0.1006 -0.1060 -0.0427 #&gt; 2 0.0513 -0.11052 -0.1085 9.26e-02 0.0176 0.1042 0.0110 0.0206 #&gt; 3 -0.0236 0.10339 0.0614 5.50e-02 -0.0276 -0.0284 0.0522 0.0315 #&gt; 4 0.1178 -0.10172 0.1097 6.29e-05 0.0321 -0.0588 -0.0994 0.1098 #&gt; 5 0.0959 0.00214 0.0291 -1.16e-01 -0.0702 -0.0691 -0.0536 -0.0665 #&gt; 6 -0.0721 0.11318 0.0259 -3.06e-02 -0.0386 0.0249 -0.0363 0.0891 #&gt; C9 C10 C11 C12 C13 C14 C15 C16 #&gt; 1 -0.0160 -0.0175 -0.1073 0.0263 0.0728 -0.0369 0.0411 -0.09490 #&gt; 2 -0.0873 0.1061 -0.0427 0.0701 0.0447 -0.0852 -0.0460 0.11952 #&gt; 3 -0.0672 -0.1103 -0.0115 -0.0901 0.0608 -0.0893 0.1136 -0.02424 #&gt; 4 -0.0344 0.0616 -0.1141 0.0343 -0.0501 0.0533 0.0421 0.08321 #&gt; 5 0.1045 -0.0456 -0.1009 0.0157 -0.0600 0.1153 -0.0142 -0.00559 #&gt; 6 0.0759 0.1115 -0.0412 0.0266 0.0878 -0.0134 -0.1037 0.03528 #&gt; C17 C18 C19 C20 C21 C22 C23 C24 #&gt; 1 0.00478 -0.0755 -0.0759 -0.0712 0.0877 -0.0857 -0.0554 0.00893 #&gt; 2 -0.01798 0.0503 0.0135 -0.0411 -0.0157 -0.0967 -0.0101 -0.01183 #&gt; 3 -0.06171 0.0208 0.0982 -0.1065 -0.0382 -0.1207 0.0743 0.05040 #&gt; 4 0.10928 -0.0224 -0.0350 0.0827 -0.1182 -0.0152 -0.0293 -0.02553 #&gt; 5 0.11777 -0.0389 0.0750 -0.0989 -0.0535 -0.0165 0.0199 -0.02985 #&gt; 6 0.08801 -0.0628 0.1190 0.0641 0.0136 -0.0982 -0.0938 -0.00272 #&gt; C25 C26 C27 C28 C29 C30 C31 C32 #&gt; 1 0.0640 0.0260 0.04661 0.01078 -0.11437 0.00131 0.06296 -0.04645 #&gt; 2 -0.0288 0.1107 0.11412 -0.03420 0.04450 0.09099 0.08275 -0.01712 #&gt; 3 -0.1036 0.0802 0.05763 0.05445 0.07248 -0.08267 -0.08010 -0.02543 #&gt; 4 0.1199 0.1315 -0.05627 0.00887 -0.10333 -0.13612 0.03010 0.11086 #&gt; 5 -0.0399 -0.0344 -0.00388 0.08507 0.00883 0.05663 0.00397 -0.00805 #&gt; 6 0.0221 -0.0411 0.01616 0.04661 0.07470 -0.06869 0.01847 0.04970 #&gt; C33 C34 C35 C36 C37 C38 C39 C40 #&gt; 1 0.0521 0.03673 -0.14412 0.0851 -0.03657 0.09489 -0.0760 -0.05650 #&gt; 2 0.0618 -0.09491 0.03098 -0.1100 -0.09198 0.02381 -0.0983 -0.00665 #&gt; 3 0.0657 0.01217 0.09968 0.0468 0.06303 0.00584 0.0928 0.06753 #&gt; 4 0.0313 -0.00612 0.00487 -0.0746 0.01793 -0.05836 0.0634 -0.06300 #&gt; 5 0.1111 -0.03248 0.01606 0.0611 0.00521 0.04014 -0.0497 0.10688 #&gt; 6 -0.0458 0.12714 -0.11167 -0.0951 0.03743 -0.09163 0.0144 0.03140 #&gt; C41 C42 C43 C44 C45 C46 C47 C48 #&gt; 1 0.10232 0.0902 -0.0671 -0.0619 0.03809 0.0472 0.08146 -0.09730 #&gt; 2 -0.10832 -0.0240 -0.0619 0.0120 -0.04791 -0.0630 -0.12081 -0.04970 #&gt; 3 -0.03932 -0.0262 -0.0944 0.0453 0.07485 0.1214 -0.01026 0.01179 #&gt; 4 0.02013 -0.0496 -0.1094 -0.0279 -0.13560 -0.0740 -0.05061 -0.11284 #&gt; 5 0.07315 0.0398 0.0803 -0.0683 -0.00424 0.0941 -0.07391 -0.00984 #&gt; 6 -0.00992 -0.0525 -0.0492 -0.0767 -0.05989 0.0826 -0.00688 -0.02931 #&gt; C49 C50 C51 C52 C53 C54 C55 C56 #&gt; 1 0.0790 -0.09735 -0.0945 0.0661 -0.0701 0.0835 -0.0255 -0.1208 #&gt; 2 -0.0255 0.11235 -0.0742 0.1034 -0.0804 0.0778 -0.0331 0.0410 #&gt; 3 0.0210 -0.05148 -0.0146 0.0387 -0.0192 -0.1131 -0.1214 0.1075 #&gt; 4 0.0228 0.11934 -0.0783 0.1125 -0.0386 0.0548 0.0434 -0.0765 #&gt; 5 0.0568 0.00392 -0.0328 -0.0433 0.0562 0.1124 0.0809 -0.1043 #&gt; 6 0.1000 0.04811 -0.0697 0.0998 -0.0956 -0.0526 0.0289 -0.0974 #&gt; C57 C58 C59 C60 C61 C62 C63 C64 #&gt; 1 0.05255 -0.00497 -0.08978 -0.0878 0.0931 0.09788 0.07303 -0.1062 #&gt; 2 0.06784 0.00632 -0.03932 -0.0899 -0.0378 0.03532 0.11821 0.1010 #&gt; 3 -0.08331 -0.02194 0.02149 -0.0117 0.1063 0.07023 0.00490 0.0523 #&gt; 4 -0.00352 0.12025 0.01942 0.0794 -0.0425 0.00681 -0.00842 -0.1082 #&gt; 5 0.04727 -0.00919 0.00340 -0.1017 -0.0530 -0.09789 0.04581 0.0932 #&gt; 6 0.11186 -0.02841 0.00422 0.0257 0.0239 0.10423 0.09466 0.1222 #&gt; C65 C66 C67 C68 C69 C70 C71 C72 C73 #&gt; 1 0.0264 -0.1249 0.0614 0.1055 -0.02003 -0.0703 -0.0887 -0.1070 0.0759 #&gt; 2 0.0286 0.0723 -0.1038 -0.0770 0.09026 -0.0292 0.1204 -0.0709 0.0293 #&gt; 3 0.0604 -0.1011 0.0227 0.0444 -0.08956 -0.0421 0.0395 -0.0433 -0.0870 #&gt; 4 -0.0902 0.0733 -0.1120 0.1108 0.00335 0.0830 0.1111 0.0596 0.0164 #&gt; 5 -0.1121 -0.0929 0.0491 -0.0275 -0.02960 -0.0396 0.0828 0.0834 -0.0255 #&gt; 6 0.0415 -0.0245 -0.0350 -0.0249 0.01962 0.0921 -0.0718 -0.1133 -0.0884 #&gt; C74 C75 C76 C77 C78 C79 C80 C81 #&gt; 1 -0.0511 0.11635 -0.02026 -0.12003 -0.1028 0.0580 0.0863 0.0257 #&gt; 2 -0.0497 -0.08399 -0.12591 -0.10755 -0.0304 0.0245 0.0502 -0.1322 #&gt; 3 0.0287 -0.08393 0.00107 -0.00346 0.0513 -0.0920 -0.0633 -0.0568 #&gt; 4 0.0824 -0.09088 0.09693 -0.08737 -0.0302 -0.0830 -0.0614 0.0943 #&gt; 5 -0.0771 0.06759 -0.10165 0.10907 0.0574 0.0480 0.1142 -0.0589 #&gt; 6 -0.0625 -0.00817 -0.11827 0.04069 -0.0271 -0.0753 0.0575 -0.1049 #&gt; C82 C83 C84 C85 C86 C87 C88 C89 #&gt; 1 -0.0509 0.057381 0.10341 0.1269 -0.0119 0.10546 -0.0120 0.09682 #&gt; 2 0.0945 -0.059643 -0.09406 0.0615 0.0340 0.09766 -0.0109 0.09064 #&gt; 3 0.0386 0.045052 0.01199 0.0640 -0.0878 -0.00908 -0.0722 0.10484 #&gt; 4 0.0849 -0.000383 -0.10061 -0.0451 -0.0225 0.02065 -0.0686 -0.06506 #&gt; 5 0.0297 -0.077343 -0.09226 -0.0568 -0.0406 0.05656 -0.0879 -0.01069 #&gt; 6 -0.0358 -0.102680 0.00756 0.0227 0.1063 -0.04178 -0.0802 -0.00525 #&gt; C90 C91 C92 C93 C94 C95 C96 C97 #&gt; 1 0.1005 0.09298 -0.04817 0.0729 -0.1190 0.0170 0.0432 0.0732 #&gt; 2 0.0915 0.11578 -0.04299 0.1041 -0.1084 0.0581 0.0738 0.1156 #&gt; 3 0.0117 -0.11705 0.00929 -0.0836 0.0909 0.0721 0.1115 0.0879 #&gt; 4 -0.0175 0.04504 -0.00878 0.1094 -0.0634 0.0234 -0.0631 -0.1057 #&gt; 5 0.0490 0.00206 0.00297 0.0901 0.0165 -0.0390 -0.0257 -0.0296 #&gt; 6 -0.0710 -0.05158 0.12051 -0.0275 -0.0107 -0.0147 0.0135 -0.0208 #&gt; C98 C99 C100 C101 C102 C103 C104 C105 #&gt; 1 -0.0977 -0.0456 0.03749 -0.0580 0.06079 0.10616 -0.0324 0.11189 #&gt; 2 0.0342 -0.1333 0.07315 -0.0474 -0.10306 -0.02245 0.0670 -0.10617 #&gt; 3 0.0615 -0.0775 -0.10432 -0.0355 0.09349 0.03501 -0.0336 0.04575 #&gt; 4 -0.0423 -0.0102 -0.00376 -0.0843 -0.00626 0.01431 0.1232 -0.04679 #&gt; 5 0.0761 -0.0987 -0.08208 0.0445 0.07740 0.00356 -0.0325 0.06300 #&gt; 6 -0.0929 -0.0201 -0.03655 -0.0950 -0.03415 -0.11198 0.0790 -0.00784 #&gt; C106 C107 C108 C109 C110 C111 C112 C113 #&gt; 1 0.0779 0.089598 -0.00149 0.0399 0.0914 -0.1143 0.0162 0.01463 #&gt; 2 -0.0818 0.001313 0.08198 0.0529 0.0930 -0.0979 -0.0459 0.01805 #&gt; 3 0.0697 0.000663 -0.06086 0.0999 -0.0862 -0.1008 0.1196 -0.06671 #&gt; 4 0.0969 -0.098089 0.01808 -0.0818 -0.0300 0.0270 -0.0435 0.01858 #&gt; 5 0.0326 -0.012967 -0.13046 -0.1028 0.0185 0.0673 -0.1227 -0.00642 #&gt; 6 0.1252 0.112852 0.04900 0.0761 0.0486 0.0431 0.0627 -0.06513 #&gt; C114 C115 C116 C117 C118 C119 C120 C121 #&gt; 1 0.12813 -0.0954 -0.0281 0.0121 0.0238 0.0232 0.10001 0.04784 #&gt; 2 0.11071 0.0844 0.0171 -0.0192 0.0197 -0.0862 -0.09185 -0.00903 #&gt; 3 0.02839 0.0552 -0.0571 -0.0541 -0.0791 -0.1206 0.10807 -0.04027 #&gt; 4 -0.00672 -0.0491 -0.0945 0.0266 -0.0317 -0.0754 0.05078 0.12405 #&gt; 5 0.09821 0.0252 0.1064 0.0976 0.0837 -0.0512 -0.00625 -0.04721 #&gt; 6 0.00552 0.0767 0.0855 0.0586 0.1085 -0.0586 0.01604 -0.05074 #&gt; C122 C123 C124 C125 C126 C127 C128 C129 #&gt; 1 -0.0362 0.1130 0.1188 0.03903 0.0134 -0.00125 -0.0461 -0.05245 #&gt; 2 0.0296 0.0680 -0.0247 -0.00558 0.0162 -0.06692 0.0567 -0.11155 #&gt; 3 -0.0695 0.0274 0.0201 0.08228 -0.0555 -0.02330 -0.0713 -0.00941 #&gt; 4 -0.1197 0.0868 0.1037 0.05397 -0.0945 0.07496 0.0741 0.03811 #&gt; 5 0.0834 -0.1059 -0.0403 0.03620 0.0104 0.06771 -0.1059 -0.08062 #&gt; 6 0.0671 0.0893 0.0940 -0.11025 0.1136 -0.01787 -0.0428 -0.00816 #&gt; C130 C131 C132 C133 C134 C135 C136 C137 #&gt; 1 -0.0288 0.09740 0.0999 0.0307 -0.0968 0.0968 0.11702 0.06049 #&gt; 2 -0.0332 -0.02315 -0.0236 -0.1303 -0.0679 0.0251 0.04595 -0.03257 #&gt; 3 -0.1186 0.03169 0.0283 -0.0941 -0.0870 -0.0402 0.09531 -0.00872 #&gt; 4 -0.0359 -0.06483 -0.0716 0.0439 0.1127 -0.1188 0.12211 0.09086 #&gt; 5 0.0300 0.12077 0.0538 0.0457 0.0220 0.1264 -0.00945 0.03387 #&gt; 6 0.0186 -0.00297 -0.0913 -0.0410 -0.0990 -0.0201 -0.03685 -0.06241 #&gt; C138 C139 C140 C141 C142 C143 C144 C145 #&gt; 1 0.043313 0.07919 0.00356 -0.0336 -0.05424 -0.07395 -0.0681 -0.082382 #&gt; 2 0.107693 0.00112 0.01814 0.0784 0.06639 0.01936 -0.0515 0.095619 #&gt; 3 0.013073 -0.01933 0.04196 0.0983 0.00648 -0.04774 0.1138 0.018470 #&gt; 4 -0.046624 -0.11151 -0.06136 0.0630 0.03200 0.00554 -0.0503 -0.040379 #&gt; 5 0.112144 -0.11112 -0.00285 -0.0572 0.09440 -0.11234 0.0690 0.000992 #&gt; 6 -0.000802 0.03472 0.00747 -0.0380 -0.02024 0.09403 0.1194 -0.091868 #&gt; C146 C147 C148 C149 C150 C151 C152 C153 #&gt; 1 -0.00161 -0.0530 0.0909 -0.07759 0.0224 -0.0342 -0.0866 -0.119895 #&gt; 2 0.03923 -0.0474 0.1102 0.00696 0.0684 -0.0682 -0.0344 -0.000776 #&gt; 3 -0.09969 0.1047 0.0849 0.10808 -0.0545 0.0615 0.0476 -0.022787 #&gt; 4 -0.06858 0.0435 0.0658 -0.11499 0.0558 -0.1115 0.0651 -0.002139 #&gt; 5 0.10658 0.0779 0.0838 -0.10970 0.0463 -0.0782 -0.0160 -0.064803 #&gt; 6 0.00753 0.0108 0.0409 -0.01102 -0.0955 0.0308 -0.0804 -0.030417 #&gt; C154 C155 C156 C157 C158 C159 C160 C161 C162 #&gt; 1 0.1052 -0.0591 -0.0296 0.0256 0.0936 -0.07580 0.0489 -0.0898 0.0289 #&gt; 2 0.0867 0.0212 0.0105 0.0695 -0.0168 0.11747 -0.0808 0.0468 -0.0582 #&gt; 3 -0.0825 0.0416 0.0862 -0.0949 0.1017 -0.03899 0.0760 -0.1070 0.0433 #&gt; 4 0.0203 0.0895 0.0715 -0.0321 0.0164 0.02218 -0.0859 -0.0478 -0.0228 #&gt; 5 -0.0814 -0.0153 -0.0403 -0.0169 0.0570 0.00802 0.0387 -0.0255 -0.1103 #&gt; 6 -0.0985 0.0805 -0.0721 -0.0178 -0.0687 -0.02205 0.0466 0.0635 -0.0096 #&gt; C163 C164 C165 C166 C167 C168 C169 C170 #&gt; 1 0.0414 0.0955 -0.07469 0.00183 0.0280 0.02004 0.03004 0.000885 #&gt; 2 0.0155 0.0292 0.00442 0.01482 -0.1126 -0.00361 -0.04059 0.084465 #&gt; 3 -0.0762 0.0988 0.03730 -0.08979 -0.0250 0.12108 0.11664 -0.028106 #&gt; 4 -0.0241 0.0708 -0.07482 -0.05371 0.1065 0.09863 -0.00482 0.112746 #&gt; 5 0.0458 -0.0655 0.11423 -0.07328 -0.0598 -0.04803 0.02727 -0.009078 #&gt; 6 -0.0219 0.0299 -0.03379 0.01844 0.0854 0.04698 0.07603 -0.096861 #&gt; C171 C172 C173 C174 C175 C176 C177 C178 #&gt; 1 0.1000 0.0931 0.09741 -0.02300 -0.02439 0.00935 -0.03032 -0.0713 #&gt; 2 0.0912 -0.0017 -0.01814 -0.02614 -0.10059 0.02287 0.06633 -0.0242 #&gt; 3 -0.0832 -0.1190 -0.08153 -0.00545 -0.04295 -0.02540 0.09360 -0.0794 #&gt; 4 -0.0615 -0.0362 -0.00729 -0.11769 -0.07007 0.02253 -0.04264 0.0897 #&gt; 5 -0.0637 0.0753 -0.05118 0.08683 -0.00583 0.09956 -0.10903 -0.0981 #&gt; 6 0.0999 0.0420 -0.09225 0.01746 -0.06295 -0.05636 0.00391 0.0627 #&gt; C179 C180 C181 C182 C183 C184 C185 C186 C187 #&gt; 1 0.00909 -0.0917 -0.0723 -0.0140 -0.0874 -0.1042 -0.0190 -0.0165 -0.0899 #&gt; 2 0.04709 -0.0322 0.0721 0.1083 0.0997 0.0407 0.0743 0.0671 -0.0611 #&gt; 3 0.06664 0.0372 -0.0290 0.0176 0.0992 0.0203 -0.0660 -0.1131 0.0311 #&gt; 4 -0.07943 0.0726 0.0745 -0.0581 0.0166 -0.0924 0.0675 -0.0304 -0.0763 #&gt; 5 -0.11599 -0.1295 0.0287 -0.0798 0.0011 0.0743 0.0975 0.0377 -0.0855 #&gt; 6 0.07310 -0.0394 0.1213 0.0641 0.0831 -0.0535 0.0253 -0.0860 -0.0851 #&gt; C188 C189 C190 C191 C192 C193 C194 C195 #&gt; 1 -0.00502 -0.1157 0.0190 -0.0673 -0.0971 -0.067037 0.1232 -0.12398 #&gt; 2 0.11710 -0.0331 0.0932 0.1266 -0.1069 0.094276 -0.0913 0.09682 #&gt; 3 0.09201 0.0577 0.1222 0.0737 -0.0443 -0.062389 -0.0750 0.09094 #&gt; 4 0.04308 0.0290 -0.1013 -0.0957 -0.0718 -0.009119 0.0657 0.00113 #&gt; 5 -0.08342 0.0738 -0.0802 0.0540 0.1215 0.000609 -0.0743 0.04733 #&gt; 6 -0.02334 -0.0696 0.0439 -0.0395 0.0704 0.027635 0.0225 0.06320 #&gt; C196 C197 C198 C199 C200 #&gt; 1 0.0185 -0.090620 0.0971 -0.10681 -0.07871 #&gt; 2 -0.1047 -0.107901 0.0957 -0.07692 -0.11630 #&gt; 3 -0.0178 -0.020815 -0.0962 -0.09388 -0.03983 #&gt; 4 0.0559 -0.035532 0.0515 0.05285 0.12677 #&gt; 5 0.0807 -0.000924 0.0645 0.02574 -0.00143 #&gt; 6 -0.1083 -0.006790 -0.0641 -0.00619 0.08396 #&gt; #&gt; [200 rows x 200 columns] h2o.weights(iris_dl, matrix_id=3) #&gt; C1 C2 C3 C4 C5 C6 C7 C8 C9 C10 #&gt; 1 -0.620 0.0281 -0.138 -0.0627 0.267 -0.291 -0.329 -0.161 0.607 0.5847 #&gt; 2 -0.147 0.0243 0.604 -0.2955 -0.626 -0.217 0.606 -0.361 0.611 -0.4059 #&gt; 3 0.558 0.6214 0.285 0.5056 0.676 0.300 -0.443 0.138 -0.555 -0.0733 #&gt; C11 C12 C13 C14 C15 C16 C17 C18 C19 C20 #&gt; 1 0.512 -0.0934 0.083 0.282 -0.470 0.186 0.0629 0.251 0.4972 -0.1273 #&gt; 2 0.441 0.5286 0.157 0.540 -0.293 0.273 0.6195 0.655 0.0441 -0.0662 #&gt; 3 0.269 0.5844 -0.411 0.266 0.183 0.442 -0.1261 -0.657 -0.3394 0.1161 #&gt; C21 C22 C23 C24 C25 C26 C27 C28 C29 C30 #&gt; 1 0.5769 -0.213 -0.596 0.652 -0.335 0.672 0.347 -0.448 -0.373 -0.0216 #&gt; 2 0.0317 -0.589 0.424 -0.527 -0.391 -0.563 -0.444 -0.244 0.434 0.0863 #&gt; 3 0.0174 -0.348 -0.370 -0.033 0.595 0.605 -0.536 0.297 0.118 0.5978 #&gt; C31 C32 C33 C34 C35 C36 C37 C38 C39 C40 #&gt; 1 0.583 -0.1742 0.3613 0.557 -0.337 0.593 -0.586 -0.498 -0.0316 0.324 #&gt; 2 -0.154 0.0552 -0.0677 0.525 -0.269 0.654 -0.454 0.110 0.2947 -0.618 #&gt; 3 0.286 0.1460 -0.2394 0.160 0.477 -0.205 -0.369 -0.321 -0.6049 -0.554 #&gt; C41 C42 C43 C44 C45 C46 C47 C48 C49 C50 #&gt; 1 0.0854 -0.1609 0.4765 0.4314 -0.464 0.362 0.488 -0.247 0.600 -0.433 #&gt; 2 0.1944 -0.2082 0.4835 -0.0341 0.515 0.437 -0.654 0.365 0.197 0.194 #&gt; 3 0.0494 0.0469 -0.0975 -0.3390 -0.187 -0.667 -0.107 -0.575 -0.413 -0.625 #&gt; C51 C52 C53 C54 C55 C56 C57 C58 C59 C60 #&gt; 1 0.502 0.586 -0.371 -0.263 -0.00507 -0.546 0.2396 0.225 -0.00871 0.122 #&gt; 2 0.185 0.395 -0.102 -0.501 0.48735 0.612 -0.6338 -0.542 -0.41116 -0.595 #&gt; 3 0.429 0.618 0.161 -0.598 0.61592 -0.305 0.0308 0.079 0.32567 -0.454 #&gt; C61 C62 C63 C64 C65 C66 C67 C68 C69 C70 #&gt; 1 0.662 0.284 -0.204 0.4022 -0.640 -0.171 -0.677 -0.324 0.587 -0.00357 #&gt; 2 0.167 0.135 0.263 0.0919 0.422 -0.360 -0.528 0.373 -0.612 -0.50450 #&gt; 3 0.667 0.280 0.396 0.5246 -0.413 -0.540 0.489 -0.012 -0.558 0.01022 #&gt; C71 C72 C73 C74 C75 C76 C77 C78 C79 #&gt; 1 -0.0207 0.550982 -0.343 -0.320 -0.377 -0.0628 -0.377 -0.52466 0.624 #&gt; 2 0.4598 -0.210810 -0.570 -0.119 -0.670 -0.0740 0.152 0.24720 -0.231 #&gt; 3 0.2452 0.000579 -0.307 0.104 0.290 -0.0646 -0.245 -0.00597 0.506 #&gt; C80 C81 C82 C83 C84 C85 C86 C87 C88 #&gt; 1 0.0777 0.594 0.0606 -0.4379 -0.687 -0.4176 -0.285 0.0565 -0.449 #&gt; 2 -0.6015 -0.614 0.2803 0.3260 0.508 0.6490 0.259 -0.2190 -0.513 #&gt; 3 -0.3096 0.555 0.6586 0.0165 0.682 0.0704 0.687 -0.6648 0.211 #&gt; C89 C90 C91 C92 C93 C94 C95 C96 C97 C98 #&gt; 1 0.349 -0.343 -0.163 0.159 0.478 -0.433 0.450 0.634 -0.00712 0.397 #&gt; 2 -0.667 0.497 -0.640 0.419 0.261 0.446 -0.556 0.607 0.66220 0.595 #&gt; 3 -0.196 -0.243 0.667 0.487 -0.482 0.441 -0.119 -0.579 -0.28301 0.311 #&gt; C99 C100 C101 C102 C103 C104 C105 C106 C107 #&gt; 1 0.4115 0.311 -0.284 0.6763 -0.00996 -0.333 0.3651 -0.458 -0.080 #&gt; 2 -0.4266 -0.173 -0.494 0.3806 -0.06370 0.224 -0.1346 -0.635 0.376 #&gt; 3 -0.0514 0.288 -0.539 0.0573 0.11897 0.644 -0.0109 0.143 0.537 #&gt; C108 C109 C110 C111 C112 C113 C114 C115 C116 C117 #&gt; 1 -0.193 0.518 -0.139 0.135 0.432 -0.2124 0.658 0.515 -0.334 -0.257 #&gt; 2 0.672 -0.520 0.493 0.636 0.384 0.5858 -0.203 0.625 -0.620 0.289 #&gt; 3 -0.519 0.473 0.252 -0.444 -0.626 0.0748 0.129 -0.553 -0.366 -0.141 #&gt; C118 C119 C120 C121 C122 C123 C124 C125 C126 C127 #&gt; 1 -0.347 -0.200 0.169 0.271 0.584 -0.147 0.1020 0.342 -0.230 -0.393 #&gt; 2 0.270 -0.653 0.363 0.443 0.661 -0.239 -0.3653 -0.310 -0.372 0.397 #&gt; 3 0.186 -0.326 -0.251 -0.170 -0.176 -0.521 -0.0471 0.262 -0.288 -0.670 #&gt; C128 C129 C130 C131 C132 C133 C134 C135 C136 C137 #&gt; 1 -0.101 0.30108 0.170 0.532 0.424 0.112 0.3987 0.346 -0.193 -0.0894 #&gt; 2 0.500 -0.67934 -0.403 -0.238 0.246 0.226 0.1419 0.295 -0.392 0.0975 #&gt; 3 0.553 -0.00239 -0.487 -0.472 0.126 -0.553 -0.0232 -0.350 0.402 0.0948 #&gt; C138 C139 C140 C141 C142 C143 C144 C145 C146 #&gt; 1 -0.232 0.610 0.4167 0.0345 0.00565 -0.430 -0.544 0.5474 0.260 #&gt; 2 -0.225 -0.399 0.0498 0.1386 -0.43067 -0.122 0.415 -0.0478 0.123 #&gt; 3 0.255 0.239 -0.6726 -0.5608 0.10836 -0.305 0.608 -0.6112 0.635 #&gt; C147 C148 C149 C150 C151 C152 C153 C154 C155 C156 #&gt; 1 -0.174 -0.466 0.675 -0.549 -0.633 -0.371 0.383 -0.313 -0.360 0.341 #&gt; 2 -0.297 0.164 0.208 -0.201 0.394 -0.030 0.623 0.227 0.212 0.385 #&gt; 3 0.201 0.439 -0.422 -0.469 0.498 -0.277 -0.110 -0.451 0.632 -0.587 #&gt; C157 C158 C159 C160 C161 C162 C163 C164 C165 C166 #&gt; 1 -0.128 0.667 0.0246 0.453 0.442 0.305 -0.0511 -0.4756 0.105 -0.6830 #&gt; 2 -0.455 0.127 0.0299 -0.455 0.169 0.506 -0.3055 -0.6684 -0.358 0.4100 #&gt; 3 -0.554 0.231 -0.1658 -0.262 -0.385 -0.641 -0.6504 0.0244 0.669 -0.0723 #&gt; C167 C168 C169 C170 C171 C172 C173 C174 C175 C176 #&gt; 1 0.443 -0.670 -0.294 -0.228 0.294 0.549 0.203 -0.190 -0.1231 -0.519 #&gt; 2 0.515 0.479 0.654 -0.409 -0.208 -0.306 0.120 0.665 -0.3890 0.583 #&gt; 3 -0.663 0.298 0.561 0.108 0.376 -0.525 0.169 -0.392 0.0374 0.494 #&gt; C177 C178 C179 C180 C181 C182 C183 C184 C185 C186 #&gt; 1 0.208 -0.0932 0.682 -0.374 -0.545 0.6393 -0.240 -0.189 0.1223 -0.655 #&gt; 2 0.145 0.4987 0.328 -0.559 0.369 0.0317 0.224 0.506 -0.0505 0.579 #&gt; 3 0.223 -0.5171 -0.575 -0.304 0.470 -0.6264 0.221 -0.168 -0.4498 0.474 #&gt; C187 C188 C189 C190 C191 C192 C193 C194 C195 C196 #&gt; 1 0.0685 0.624 -0.472 0.112 -0.397 -0.3545 0.215 -0.0656 -0.677 -0.0230 #&gt; 2 0.6632 -0.517 0.326 0.014 -0.193 -0.0639 -0.617 0.2425 0.458 -0.3413 #&gt; 3 0.1084 -0.192 0.430 0.386 0.632 -0.6297 0.347 -0.6417 0.665 0.0785 #&gt; C197 C198 C199 C200 #&gt; 1 -0.647 -0.516 0.503 -0.356 #&gt; 2 -0.276 -0.149 0.433 0.631 #&gt; 3 -0.683 -0.142 -0.387 0.579 #&gt; #&gt; [3 rows x 200 columns] h2o.biases(iris_dl, vector_id=1) #&gt; C1 #&gt; 1 0.457 #&gt; 2 0.485 #&gt; 3 0.488 #&gt; 4 0.493 #&gt; 5 0.486 #&gt; 6 0.481 #&gt; #&gt; [200 rows x 1 column] h2o.biases(iris_dl, vector_id=2) #&gt; C1 #&gt; 1 1.002 #&gt; 2 1.002 #&gt; 3 0.997 #&gt; 4 1.002 #&gt; 5 1.002 #&gt; 6 1.002 #&gt; #&gt; [200 rows x 1 column] h2o.biases(iris_dl, vector_id=3) #&gt; C1 #&gt; 1 -0.00172 #&gt; 2 -0.00122 #&gt; 3 0.00119 #&gt; #&gt; [3 rows x 1 column] #plot weights connecting `Sepal.Length` to first hidden neurons plot(as.data.frame(h2o.weights(iris_dl, matrix_id=1))[,1]) 5.8.11 Reproducibility Every run of DeepLearning results in different results since multithreading is done via Hogwild! that benefits from intentional lock-free race conditions between threads. To get reproducible results for small datasets and testing purposes, set reproducible=T and set seed=1337 (pick any integer). This will not work for big data for technical reasons, and is probably also not desired because of the significant slowdown (runs on 1 core only). 5.8.12 Scoring on Training/Validation Sets During Training The training and/or validation set errors can be based on a subset of the training or validation data, depending on the values for score_validation_samples (defaults to 0: all) or score_training_samples (defaults to 10,000 rows, since the training error is only used for early stopping and monitoring). For large datasets, Deep Learning can automatically sample the validation set to avoid spending too much time in scoring during training, especially since scoring results are not currently displayed in the model returned to R. Note that the default value of score_duty_cycle=0.1 limits the amount of time spent in scoring to 10%, so a large number of scoring samples won’t slow down overall training progress too much, but it will always score once after the first MapReduce iteration, and once at the end of training. Stratified sampling of the validation dataset can help with scoring on datasets with class imbalance. Note that this option also requires balance_classes to be enabled (used to over/under-sample the training dataset, based on the max. relative size of the resulting training dataset, max_after_balance_size): More information can be found in the H2O Deep Learning booklet, in our H2O SlideShare Presentations, our H2O YouTube channel, as well as on our H2O Github Repository, especially in our H2O Deep Learning R tests, and H2O Deep Learning Python tests. 5.9 All done, shutdown H2O h2o.shutdown(prompt=FALSE) #&gt; [1] TRUE "],
["sensitivity-analysis-for-neural-networks.html", "Chapter 6 Sensitivity analysis for neural networks 6.1 Introduction 6.2 The Lek profile function 6.3 Getting a dataframe from lek 6.4 The lek function works with lm 6.5 lek function works with RSNNS", " Chapter 6 Sensitivity analysis for neural networks 6.1 Introduction https://beckmw.wordpress.com/tag/nnet/ I’ve made quite a few blog posts about neural networks and some of the diagnostic tools that can be used to ‘demystify’ the information contained in these models. Frankly, I’m kind of sick of writing about neural networks but I wanted to share one last tool I’ve implemented in R. I’m a strong believer that supervised neural networks can be used for much more than prediction, as is the common assumption by most researchers. I hope that my collection of posts, including this one, has shown the versatility of these models to develop inference into causation. To date, I’ve authored posts on visualizing neural networks, animating neural networks, and determining importance of model inputs. This post will describe a function for a sensitivity analysis of a neural network. Specifically, I will describe an approach to evaluate the form of the relationship of a response variable with the explanatory variables used in the model. The general goal of a sensitivity analysis is similar to evaluating relative importance of explanatory variables, with a few important distinctions. For both analyses, we are interested in the relationships between explanatory and response variables as described by the model in the hope that the neural network has explained some real-world phenomenon. Using Garson’s algorithm,1 we can get an idea of the magnitude and sign of the relationship between variables relative to each other. Conversely, the sensitivity analysis allows us to obtain information about the form of the relationship between variables rather than a categorical description, such as variable x is positively and strongly related to y. For example, how does a response variable change in relation to increasing or decreasing values of a given explanatory variable? Is it a linear response, non-linear, uni-modal, no response, etc.? Furthermore, how does the form of the response change given values of the other explanatory variables in the model? We might expect that the relationship between a response and explanatory variable might differ given the context of the other explanatory variables (i.e., an interaction may be present). The sensitivity analysis can provide this information. As with most of my posts, I’ve created the sensitivity analysis function using ideas from other people that are much more clever than me. I’ve simply converted these ideas into a useful form in R. Ultimate credit for the sensitivity analysis goes to Sovan Lek (and colleagues), who developed the approach in the mid-1990s. The ‘Lek-profile method’ is described briefly in Lek et al. 19962 and in more detail in Gevrey et al. 2003.3 I’ll provide a brief summary here since the method is pretty simple. In fact, the profile method can be extended to any statistical model and is not specific to neural networks, although it is one of few methods used to evaluate the latter. For any statistical model where multiple response variables are related to multiple explanatory variables, we choose one response and one explanatory variable. We obtain predictions of the response variable across the range of values for the given explanatory variable. All other explanatory variables are held constant at a given set of respective values (e.g., minimum, 20th percentile, maximum). The final product is a set of response curves for one response variable across the range of values for one explanatory variable, while holding all other explanatory variables constant. This is implemented in R by creating a matrix of values for explanatory variables where the number of rows is the number of observations and the number of columns is the number of explanatory variables. All explanatory variables are held at their mean (or other constant value) while the variable of interest is sequenced from its minimum to maximum value across the range of observations. This matrix (actually a data frame) is then used to predict values of the response variable from a fitted model object. This is repeated for different variables. I’ll illustrate the function using simulated data, as I’ve done in previous posts. The exception here is that I’ll be using two response variables instead of one. The two response variables are linear combinations of eight explanatory variables, with random error components taken from a normal distribution. The relationships between the variables are determined by the arbitrary set of parameters (parms1 and parms2). The explanatory variables are partially correlated and taken from a multivariate normal distribution. require(clusterGeneration) #&gt; Loading required package: clusterGeneration #&gt; Loading required package: MASS require(nnet) #&gt; Loading required package: nnet #define number of variables and observations set.seed(2) num.vars&lt;-8 num.obs&lt;-10000 #define correlation matrix for explanatory variables #define actual parameter values cov.mat&lt;-genPositiveDefMat(num.vars,covMethod=c(&quot;unifcorrmat&quot;))$Sigma rand.vars&lt;-mvrnorm(num.obs,rep(0,num.vars),Sigma=cov.mat) parms1&lt;-runif(num.vars,-10,10) y1&lt;-rand.vars %*% matrix(parms1) + rnorm(num.obs,sd=20) parms2&lt;-runif(num.vars,-10,10) y2&lt;-rand.vars %*% matrix(parms2) + rnorm(num.obs,sd=20) #prep data and create neural network rand.vars&lt;-data.frame(rand.vars) resp&lt;-apply(cbind(y1,y2),2, function(y) (y-min(y))/(max(y)-min(y))) resp&lt;-data.frame(resp) names(resp)&lt;-c(&#39;Y1&#39;,&#39;Y2&#39;) mod1 &lt;- nnet(rand.vars,resp,size=8,linout=T) #&gt; # weights: 90 #&gt; initial value 30121.205794 #&gt; iter 10 value 130.537462 #&gt; iter 20 value 57.187090 #&gt; iter 30 value 47.285919 #&gt; iter 40 value 42.778564 #&gt; iter 50 value 39.837784 #&gt; iter 60 value 36.694632 #&gt; iter 70 value 35.140948 #&gt; iter 80 value 34.268819 #&gt; iter 90 value 33.772282 #&gt; iter 100 value 33.472654 #&gt; final value 33.472654 #&gt; stopped after 100 iterations #import the function from Github library(devtools) # source_url(&#39;https://gist.githubusercontent.com/fawda123/7471137/raw/466c1474d0a505ff044412703516c34f1a4684a5/nnet_plot_update.r&#39;) source(&quot;nnet_plot_update.r&quot;) #plot each model plot.nnet(mod1) #&gt; Loading required package: scales #&gt; Loading required package: reshape 6.2 The Lek profile function We’ve created a neural network that hopefully describes the relationship of two response variables with eight explanatory variables. The sensitivity analysis lets us visualize these relationships. The Lek profile function can be used once we have a neural network model in our workspace. The function is imported and used as follows: # source(&#39;https://gist.githubusercontent.com/fawda123/6860630/raw/b8bf4a6c88d6b392b1bfa6ef24759ae98f31877c/lek_fun.r&#39;) source(&quot;lek_fun.r&quot;) lek.fun(mod1) #&gt; Loading required package: ggplot2 #&gt; Registered S3 methods overwritten by &#39;ggplot2&#39;: #&gt; method from #&gt; [.quosures rlang #&gt; c.quosures rlang #&gt; print.quosures rlang Fig: Sensitivity analysis of the two response variables in the neural network model to individual explanatory variables. Splits represent the quantile values at which the remaining explanatory variables were held constant. The function can be obtained here By default, the function runs a sensitivity analysis for all variables. This creates a busy plot so we may want to look at specific variables of interest. Maybe we want to evaluate different quantile values as well. These options can be changed using the arguments. lek.fun(mod1,var.sens=c(&#39;X2&#39;,&#39;X5&#39;),split.vals=seq(0,1,by=0.05)) Fig: Sensitivity analysis of the two response variables in relation to explanatory variables X2 and X5 and different quantile values for the remaining variables. The function also returns a ggplot2 object that can be further modified. You may prefer a different theme, color, or line type, for example. p1&lt;-lek.fun(mod1) class(p1) #&gt; [1] &quot;gg&quot; &quot;ggplot&quot; # [1] &quot;gg&quot; &quot;ggplot&quot; p1 + theme_bw() + scale_colour_brewer(palette=&quot;PuBu&quot;) + scale_linetype_manual(values=rep(&#39;dashed&#39;,6)) + scale_size_manual(values=rep(1,6)) #&gt; Scale for &#39;linetype&#39; is already present. Adding another scale for #&gt; &#39;linetype&#39;, which will replace the existing scale. #&gt; Scale for &#39;size&#39; is already present. Adding another scale for &#39;size&#39;, #&gt; which will replace the existing scale. 6.3 Getting a dataframe from lek Finally, the actual values from the sensitivity analysis can be returned if you’d prefer that instead. The output is a data frame in long form that was created using melt.list from the reshape package for compatibility with ggplot2. The six columns indicate values for explanatory variables on the x-axes, names of the response variables, predicted values of the response variables, quantiles at which other explanatory variables were held constant, and names of the explanatory variables on the x-axes. head(lek.fun(mod1,val.out = TRUE)) #&gt; Explanatory resp.name Response Splits exp.name #&gt; 1 -9.58 Y1 0.466 0 X1 #&gt; 2 -9.39 Y1 0.466 0 X1 #&gt; 3 -9.19 Y1 0.467 0 X1 #&gt; 4 -9.00 Y1 0.467 0 X1 #&gt; 5 -8.81 Y1 0.468 0 X1 #&gt; 6 -8.62 Y1 0.468 0 X1 6.4 The lek function works with lm I mentioned earlier that the function is not unique to neural networks and can work with other models created in R. I haven’t done an extensive test of the function, but I’m fairly certain that it will work if the model object has a predict method (e.g., predict.lm). Here’s an example using the function to evaluate a multiple linear regression for one of the response variables. mod2 &lt;-lm(Y1 ~ ., data = cbind(resp[,&#39;Y1&#39;, drop = F], rand.vars)) lek.fun(mod2) This function has little relevance for conventional models like linear regression since a wealth of diagnostic tools are already available (e.g., effects plots, add/drop procedures, outlier tests, etc.). The application of the function to neural networks provides insight into the relationships described by the models, insights that to my knowledge, cannot be obtained using current tools in R. This post concludes my contribution of diagnostic tools for neural networks in R and I hope that they have been useful to some of you. I have spent the last year or so working with neural networks and my opinion of their utility is mixed. I see advantages in the use of highly flexible computer-based algorithms, although in most cases similar conclusions can be made using more conventional analyses. I suggest that neural networks only be used if there is an extremely high sample size and other methods have proven inconclusive. Feel free to voice your opinions or suggestions in the comments. 6.5 lek function works with RSNNS require(clusterGeneration) require(RSNNS) #&gt; Loading required package: RSNNS #&gt; Loading required package: Rcpp require(devtools) #define number of variables and observations set.seed(2) num.vars&lt;-8 num.obs&lt;-10000 #define correlation matrix for explanatory variables #define actual parameter values cov.mat &lt;-genPositiveDefMat(num.vars,covMethod=c(&quot;unifcorrmat&quot;))$Sigma rand.vars &lt;-mvrnorm(num.obs,rep(0,num.vars),Sigma=cov.mat) parms1 &lt;-runif(num.vars,-10,10) y1 &lt;-rand.vars %*% matrix(parms1) + rnorm(num.obs,sd=20) parms2 &lt;-runif(num.vars,-10,10) y2 &lt;-rand.vars %*% matrix(parms2) + rnorm(num.obs,sd=20) #prep data and create neural network rand.vars &lt;- data.frame(rand.vars) resp &lt;- apply(cbind(y1,y2),2, function(y) (y-min(y))/(max(y)-min(y))) resp &lt;- data.frame(resp) names(resp)&lt;-c(&#39;Y1&#39;,&#39;Y2&#39;) tibble::as_tibble(rand.vars) #&gt; # A tibble: 10,000 x 8 #&gt; X1 X2 X3 X4 X5 X6 X7 X8 #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1.61 2.13 2.13 3.97 -1.34 2.00 3.11 -2.55 #&gt; 2 -1.25 3.07 -0.325 1.61 -0.484 2.28 2.98 -1.71 #&gt; 3 -3.17 -1.29 -1.77 -1.66 -0.549 -3.19 1.07 1.81 #&gt; 4 -2.39 3.28 -3.42 -0.160 -1.52 2.67 7.05 -1.14 #&gt; 5 -1.55 -0.181 -1.14 2.27 -1.68 -1.67 3.08 0.334 #&gt; 6 0.0690 -1.54 -2.98 2.84 1.42 1.31 1.82 2.07 #&gt; # … with 9,994 more rows tibble::as_tibble(resp) #&gt; # A tibble: 10,000 x 2 #&gt; Y1 Y2 #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.461 0.500 #&gt; 2 0.416 0.509 #&gt; 3 0.534 0.675 #&gt; 4 0.548 0.619 #&gt; 5 0.519 0.659 #&gt; 6 0.389 0.622 #&gt; # … with 9,994 more rows # create neural network model mod2 &lt;- mlp(rand.vars, resp, size = 8, linOut = T) #import sensitivity analysis function source_url(&#39;https://gist.githubusercontent.com/fawda123/6860630/raw/b8bf4a6c88d6b392b1bfa6ef24759ae98f31877c/lek_fun.r&#39;) #&gt; SHA-1 hash of file is 4a2d33b94a08f46a94518207a4ae7cc412845222 #sensitivity analsyis, note &#39;exp.in&#39; argument lek.fun(mod2, exp.in = rand.vars) "],
["references.html", "Chapter 7 References", " Chapter 7 References 1 Garson GD. 1991. Interpreting neural network connection weights. Artificial Intelligence Expert. 6:46–51. 2 Lek S, Delacoste M, Baran P, Dimopoulos I, Lauga J, Aulagnier S. 1996. Application of neural networks to modelling nonlinear relationships in Ecology. Ecological Modelling. 90:39-52. 3 Gevrey M, Dimopoulos I, Lek S. 2003. Review and comparison of methods to study the contribution of variables in artificial neural network models. Ecological Modelling. 160:249-264. "],
["regression-with-ann-yacht-hydrodynamics.html", "Chapter 8 Regression with ANN - Yacht Hydrodynamics 8.1 Introduction 8.2 Replication Requirements 8.3 Data Preparation 8.4 1st Regression ANN 8.5 Regression Hyperparameters 8.6 Wrapping Up", " Chapter 8 Regression with ANN - Yacht Hydrodynamics 8.1 Introduction Regression ANNs predict an output variable as a function of the inputs. The input features (independent variables) can be categorical or numeric types, however, for regression ANNs, we require a numeric dependent variable. If the output variable is a categorical variable (or binary) the ANN will function as a classifier (see next tutorial). Source: http://uc-r.github.io/ann_regression In this tutorial we introduce a neural network used for numeric predictions and cover: Replication requirements: What you’ll need to reproduce the analysis in this tutorial. Data Preparation: Preparing our data. 1st Regression ANN: Constructing a 1-hidden layer ANN with 1 neuron. Regression Hyperparameters: Tuning the model. Wrapping Up: Final comments and some exercises to test your skills. 8.2 Replication Requirements We require the following packages for the analysis. library(tidyverse) #&gt; Registered S3 methods overwritten by &#39;ggplot2&#39;: #&gt; method from #&gt; [.quosures rlang #&gt; c.quosures rlang #&gt; print.quosures rlang #&gt; Registered S3 method overwritten by &#39;rvest&#39;: #&gt; method from #&gt; read_xml.response xml2 #&gt; ── Attaching packages ───────────────────────────────────────── tidyverse 1.2.1 ── #&gt; ✔ ggplot2 3.1.1 ✔ purrr 0.3.2 #&gt; ✔ tibble 2.1.1 ✔ dplyr 0.8.0.1 #&gt; ✔ tidyr 0.8.3 ✔ stringr 1.4.0 #&gt; ✔ readr 1.3.1 ✔ forcats 0.4.0 #&gt; ── Conflicts ──────────────────────────────────────────── tidyverse_conflicts() ── #&gt; ✖ dplyr::filter() masks stats::filter() #&gt; ✖ dplyr::lag() masks stats::lag() library(neuralnet) #&gt; #&gt; Attaching package: &#39;neuralnet&#39; #&gt; The following object is masked from &#39;package:dplyr&#39;: #&gt; #&gt; compute library(GGally) #&gt; Registered S3 method overwritten by &#39;GGally&#39;: #&gt; method from #&gt; +.gg ggplot2 #&gt; #&gt; Attaching package: &#39;GGally&#39; #&gt; The following object is masked from &#39;package:dplyr&#39;: #&gt; #&gt; nasa 8.3 Data Preparation Our regression ANN will use the Yacht Hydrodynamics data set from UCI’s Machine Learning Repository. The yacht data was provided by Dr. Roberto Lopez email. This data set contains data contains results from 308 full-scale experiments performed at the Delft Ship Hydromechanics Laboratory where they test 22 different hull forms. Their experiment tested the effect of variations in the hull geometry and the ship’s Froude number on the craft’s residuary resistance per unit weight of displacement. To begin we download the data from UCI. url &lt;- &#39;http://archive.ics.uci.edu/ml/machine-learning-databases/00243/yacht_hydrodynamics.data&#39; Yacht_Data &lt;- read_table(file = url, col_names = c(&#39;LongPos_COB&#39;, &#39;Prismatic_Coeff&#39;, &#39;Len_Disp_Ratio&#39;, &#39;Beam_Draut_Ratio&#39;, &#39;Length_Beam_Ratio&#39;,&#39;Froude_Num&#39;, &#39;Residuary_Resist&#39;)) %&gt;% na.omit() #&gt; Parsed with column specification: #&gt; cols( #&gt; LongPos_COB = col_double(), #&gt; Prismatic_Coeff = col_double(), #&gt; Len_Disp_Ratio = col_double(), #&gt; Beam_Draut_Ratio = col_double(), #&gt; Length_Beam_Ratio = col_double(), #&gt; Froude_Num = col_double(), #&gt; Residuary_Resist = col_double() #&gt; ) dplyr::glimpse(Yacht_Data) #&gt; Observations: 308 #&gt; Variables: 7 #&gt; $ LongPos_COB &lt;dbl&gt; -2.3, -2.3, -2.3, -2.3, -2.3, -2.3, -2.3, -2.3… #&gt; $ Prismatic_Coeff &lt;dbl&gt; 0.568, 0.568, 0.568, 0.568, 0.568, 0.568, 0.56… #&gt; $ Len_Disp_Ratio &lt;dbl&gt; 4.78, 4.78, 4.78, 4.78, 4.78, 4.78, 4.78, 4.78… #&gt; $ Beam_Draut_Ratio &lt;dbl&gt; 3.99, 3.99, 3.99, 3.99, 3.99, 3.99, 3.99, 3.99… #&gt; $ Length_Beam_Ratio &lt;dbl&gt; 3.17, 3.17, 3.17, 3.17, 3.17, 3.17, 3.17, 3.17… #&gt; $ Froude_Num &lt;dbl&gt; 0.125, 0.150, 0.175, 0.200, 0.225, 0.250, 0.27… #&gt; $ Residuary_Resist &lt;dbl&gt; 0.11, 0.27, 0.47, 0.78, 1.18, 1.82, 2.61, 3.76… # save the dataset locally write.csv(Yacht_Data, file = file.path(data_raw_dir, &quot;yach_data.csv&quot;)) Prior to any data analysis lets take a look at the data set. ggpairs(Yacht_Data, title = &quot;Scatterplot Matrix of the Features of the Yacht Data Set&quot;) Here we see an excellent summary of the variation of each feature in our data set. Draw your attention to the bottom-most strip of scatter-plots. This shows the residuary resistance as a function of the other data set features (independent experimental values). The greatest variation appears with the Froude Number feature. It will be interesting to see how this pattern appears in the subsequent regression ANNs. Prior to regression ANN construction we first must split the Yacht data set into test and training data sets. Before we split, first scale each feature to fall in the [0,1] interval. # Scale the Data scale01 &lt;- function(x){ (x - min(x)) / (max(x) - min(x)) } Yacht_Data &lt;- Yacht_Data %&gt;% mutate_all(scale01) # Split into test and train sets set.seed(12345) Yacht_Data_Train &lt;- sample_frac(tbl = Yacht_Data, replace = FALSE, size = 0.80) Yacht_Data_Test &lt;- anti_join(Yacht_Data, Yacht_Data_Train) #&gt; Joining, by = c(&quot;LongPos_COB&quot;, &quot;Prismatic_Coeff&quot;, &quot;Len_Disp_Ratio&quot;, &quot;Beam_Draut_Ratio&quot;, &quot;Length_Beam_Ratio&quot;, &quot;Froude_Num&quot;, &quot;Residuary_Resist&quot;) The scale01() function maps each data observation onto the [0,1] interval as called in the dplyr mutate_all() function. We then provided a seed for reproducible results and randomly extracted (without replacement) 80% of the observations to build the Yacht_Data_Train data set. Using dplyr’s anti_join() function we extracted all the observations not within the Yacht_Data_Train data set as our test data set in Yacht_Data_Test. 8.4 1st Regression ANN To begin we construct a 1-hidden layer ANN with 1 neuron, the simplest of all neural networks. set.seed(12321) Yacht_NN1 &lt;- neuralnet(Residuary_Resist ~ LongPos_COB + Prismatic_Coeff + Len_Disp_Ratio + Beam_Draut_Ratio + Length_Beam_Ratio + Froude_Num, data = Yacht_Data_Train) The Yacht_NN1 is a list containing all parameters of the regression ANN as well as the results of the neural network on the test data set. To view a diagram of the Yacht_NN1 use the plot() function. plot(Yacht_NN1, rep = &#39;best&#39;) This plot shows the weights learned by the Yacht_NN1 neural network, and displays the number of iterations before convergence, as well as the SSE of the training data set. To manually compute the SSE you can use the following: NN1_Train_SSE &lt;- sum((Yacht_NN1$net.result - Yacht_Data_Train[, 7])^2)/2 paste(&quot;SSE: &quot;, round(NN1_Train_SSE, 4)) #&gt; [1] &quot;SSE: 0.0365&quot; ## [1] &quot;SSE: 0.0361&quot; This SSE is the error associated with the training data set. A superior metric for estimating the generalization capability of the ANN would be the SSE of the test data set. Recall, the test data set contains observations not used to train the Yacht_NN1 ANN. To calculate the test error, we first must run our test observations through the Yacht_NN1 ANN. This is accomplished with the neuralnet package compute() function, which takes as its first input the desired neural network object created by the neuralnet() function, and the second argument the test data set feature (independent variable(s)) values. Test_NN1_Output &lt;- compute(Yacht_NN1, Yacht_Data_Test[, 1:6])$net.result NN1_Test_SSE &lt;- sum((Test_NN1_Output - Yacht_Data_Test[, 7])^2)/2 NN1_Test_SSE #&gt; [1] 0.0139 ## [1] 0.008417631461 The compute() function outputs the response variable, in our case the Residuary_Resist, as estimated by the neural network. Once we have the ANN estimated response we can compute the test SSE. Comparing the test error of 0.0084 to the training error of 0.0361 we see that in our case our test error is smaller than our training error. 8.5 Regression Hyperparameters We have constructed the most basic of regression ANNs without modifying any of the default hyperparameters associated with the neuralnet() function. We should try and improve the network by modifying its basic structure and hyperparameter modification. To begin we will add depth to the hidden layer of the network, then we will change the activation function from the logistic to the tangent hyperbolicus (tanh) to determine if these modifications can improve the test data set SSE. When using the tanh activation function, we first must rescale the data from \\([0,1]\\) to \\([-1,1]\\) using the rescale package. For the purposes of this exercise we will use the same random seed for reproducible results, generally this is not a best practice. # 2-Hidden Layers, Layer-1 4-neurons, Layer-2, 1-neuron, logistic activation # function set.seed(12321) Yacht_NN2 &lt;- neuralnet(Residuary_Resist ~ LongPos_COB + Prismatic_Coeff + Len_Disp_Ratio + Beam_Draut_Ratio + Length_Beam_Ratio + Froude_Num, data = Yacht_Data_Train, hidden = c(4, 1), act.fct = &quot;logistic&quot;) ## Training Error NN2_Train_SSE &lt;- sum((Yacht_NN2$net.result - Yacht_Data_Train[, 7])^2)/2 ## Test Error Test_NN2_Output &lt;- compute(Yacht_NN2, Yacht_Data_Test[, 1:6])$net.result NN2_Test_SSE &lt;- sum((Test_NN2_Output - Yacht_Data_Test[, 7])^2)/2 # Rescale for tanh activation function scale11 &lt;- function(x) { (2 * ((x - min(x))/(max(x) - min(x)))) - 1 } Yacht_Data_Train &lt;- Yacht_Data_Train %&gt;% mutate_all(scale11) Yacht_Data_Test &lt;- Yacht_Data_Test %&gt;% mutate_all(scale11) # 2-Hidden Layers, Layer-1 4-neurons, Layer-2, 1-neuron, tanh activation # function set.seed(12321) Yacht_NN3 &lt;- neuralnet(Residuary_Resist ~ LongPos_COB + Prismatic_Coeff + Len_Disp_Ratio + Beam_Draut_Ratio + Length_Beam_Ratio + Froude_Num, data = Yacht_Data_Train, hidden = c(4, 1), act.fct = &quot;tanh&quot;) ## Training Error NN3_Train_SSE &lt;- sum((Yacht_NN3$net.result - Yacht_Data_Train[, 7])^2)/2 ## Test Error Test_NN3_Output &lt;- compute(Yacht_NN3, Yacht_Data_Test[, 1:6])$net.result NN3_Test_SSE &lt;- sum((Test_NN3_Output - Yacht_Data_Test[, 7])^2)/2 # 1-Hidden Layer, 1-neuron, tanh activation function set.seed(12321) Yacht_NN4 &lt;- neuralnet(Residuary_Resist ~ LongPos_COB + Prismatic_Coeff + Len_Disp_Ratio + Beam_Draut_Ratio + Length_Beam_Ratio + Froude_Num, data = Yacht_Data_Train, act.fct = &quot;tanh&quot;) ## Training Error NN4_Train_SSE &lt;- sum((Yacht_NN4$net.result - Yacht_Data_Train[, 7])^2)/2 ## Test Error Test_NN4_Output &lt;- compute(Yacht_NN4, Yacht_Data_Test[, 1:6])$net.result NN4_Test_SSE &lt;- sum((Test_NN4_Output - Yacht_Data_Test[, 7])^2)/2 # Bar plot of results Regression_NN_Errors &lt;- tibble(Network = rep(c(&quot;NN1&quot;, &quot;NN2&quot;, &quot;NN3&quot;, &quot;NN4&quot;), each = 2), DataSet = rep(c(&quot;Train&quot;, &quot;Test&quot;), time = 4), SSE = c(NN1_Train_SSE, NN1_Test_SSE, NN2_Train_SSE, NN2_Test_SSE, NN3_Train_SSE, NN3_Test_SSE, NN4_Train_SSE, NN4_Test_SSE)) Regression_NN_Errors %&gt;% ggplot(aes(Network, SSE, fill = DataSet)) + geom_col(position = &quot;dodge&quot;) + ggtitle(&quot;Regression ANN&#39;s SSE&quot;) As evident from the plot, we see that the best regression ANN we found was Yacht_NN2 with a training and test SSE of 0.0188 and 0.0057. We make this determination by the value of the training and test SSEs only. Yacht_NN2’s structure is presented here: plot(Yacht_NN2, rep = &quot;best&quot;) set.seed(12321) Yacht_NN2 &lt;- neuralnet(Residuary_Resist ~ LongPos_COB + Prismatic_Coeff + Len_Disp_Ratio + Beam_Draut_Ratio + Length_Beam_Ratio + Froude_Num, data = Yacht_Data_Train, hidden = c(4, 1), act.fct = &quot;logistic&quot;, rep = 10) plot(Yacht_NN2, rep = &quot;best&quot;) By setting the same seed, prior to running the 10 repetitions of ANNs, we force the software to reproduce the exact same Yacht_NN2 ANN for the first replication. The subsequent 9 generated ANNs, use a different random set of starting weights. Comparing the ‘best’ of the 10 repetitions, to the Yacht_NN2, we observe a decrease in training set error indicating we have a superior set of weights. 8.6 Wrapping Up We have briefly covered regression ANNs in this tutorial. In the next tutorial we will cover classification ANNs. The neuralnet package used in this tutorial is one of many tools available for ANN implementation in R. Others include: nnet autoencoder caret RSNNS h2o Before you move on to the next tutorial, test your new knowledge on the exercises that follow. Why do we split the yacht data into a training and test data sets? Re-load the Yacht Data from the UCI Machine learning repository yacht data without scaling. Run any regression ANN. What happens? Why do you think this happens? After completing exercise question 1, re-scale the yacht data. Perform a simple linear regression fitting Residuary_Resist as a function of all other features. Now run a regression neural network (see 1st Regression ANN section). Plot the regression ANN and compare the weights on the features in the ANN to the p-values for the regressors. Build your own regression ANN using the scaled yacht data modifying one hyperparameter. Use ?neuralnet to see the function options. Plot your ANN. "],
["regression-cereals-dataset.html", "Chapter 9 Regression - cereals dataset 9.1 Introduction 9.2 The Basics of Neural Networks 9.3 Fitting a Neural Network in R 9.4 End Notes", " Chapter 9 Regression - cereals dataset 9.1 Introduction Source: https://www.analyticsvidhya.com/blog/2017/09/creating-visualizing-neural-network-in-r/ Neural network is an information-processing machine and can be viewed as analogous to human nervous system. Just like human nervous system, which is made up of interconnected neurons, a neural network is made up of interconnected information processing units. The information processing units do not work in a linear manner. In fact, neural network draws its strength from parallel processing of information, which allows it to deal with non-linearity. Neural network becomes handy to infer meaning and detect patterns from complex data sets. Neural network is considered as one of the most useful technique in the world of data analytics. However, it is complex and is often regarded as a black box, i.e. users view the input and output of a neural network but remain clueless about the knowledge generating process. We hope that the article will help readers learn about the internal mechanism of a neural network and get hands-on experience to implement it in R. 9.2 The Basics of Neural Networks A neural network is a model characterized by an activation function, which is used by interconnected information processing units to transform input into output. A neural network has always been compared to human nervous system. Information in passed through interconnected units analogous to information passage through neurons in humans. The first layer of the neural network receives the raw input, processes it and passes the processed information to the hidden layers. The hidden layer passes the information to the last layer, which produces the output. The advantage of neural network is that it is adaptive in nature. It learns from the information provided, i.e. trains itself from the data, which has a known outcome and optimizes its weights for a better prediction in situations with unknown outcome. A perceptron, viz. single layer neural network, is the most basic form of a neural network. A perceptron receives multidimensional input and processes it using a weighted summation and an activation function. It is trained using a labeled data and learning algorithm that optimize the weights in the summation processor. A major limitation of perceptron model is its inability to deal with non-linearity. A multilayered neural network overcomes this limitation and helps solve non-linear problems. The input layer connects with hidden layer, which in turn connects to the output layer. The connections are weighted and weights are optimized using a learning rule. There are many learning rules that are used with neural network: least mean square; gradient descent; newton’s rule; conjugate gradient etc. The learning rules can be used in conjunction with backpropgation error method. The learning rule is used to calculate the error at the output unit. This error is backpropagated to all the units such that the error at each unit is proportional to the contribution of that unit towards total error at the output unit. The errors at each unit are then used to optimize the weight at each connection. Figure 1 displays the structure of a simple neural network model for better understanding. 9.3 Fitting a Neural Network in R Now we will fit a neural network model in R. In this article, we use a subset of cereal dataset shared by Carnegie Mellon University (CMU). The details of the dataset are on the following link: http://lib.stat.cmu.edu/DASL/Datafiles/Cereals.html. The objective is to predict rating of the cereals variables such as calories, proteins, fat etc. The R script is provided side by side and is commented for better understanding of the user. . The data is in .csv format and can be downloaded by clicking: cereals. Please set working directory in R using setwd( ) function, and keep cereal.csv in the working directory. We use rating as the dependent variable and calories, proteins, fat, sodium and fiber as the independent variables. We divide the data into training and test set. Training set is used to find the relationship between dependent and independent variables while the test set assesses the performance of the model. We use 60% of the dataset as training set. The assignment of the data to training and test set is done using random sampling. We perform random sampling on R using sample ( ) function. We have used set.seed( ) to generate same random sample everytime and maintain consistency. We will use the index variable while fitting neural network to create training and test data sets. The R script is as follows: ## Creating index variable # Read the Data data = read.csv(file.path(data_raw_dir, &quot;cereals.csv&quot;), header=T) # Random sampling samplesize = 0.60 * nrow(data) set.seed(80) index = sample( seq_len ( nrow ( data ) ), size = samplesize ) # Create training and test set datatrain = data[ index, ] datatest = data[ -index, ] dplyr::glimpse(data) #&gt; Observations: 75 #&gt; Variables: 6 #&gt; $ calories &lt;int&gt; 70, 120, 70, 50, 110, 110, 130, 90, 90, 120, 110, 120, … #&gt; $ protein &lt;int&gt; 4, 3, 4, 4, 2, 2, 3, 2, 3, 1, 6, 1, 3, 1, 2, 2, 1, 1, 3… #&gt; $ fat &lt;int&gt; 1, 5, 1, 0, 2, 0, 2, 1, 0, 2, 2, 3, 2, 1, 0, 0, 0, 1, 3… #&gt; $ sodium &lt;int&gt; 130, 15, 260, 140, 180, 125, 210, 200, 210, 220, 290, 2… #&gt; $ fiber &lt;dbl&gt; 10.0, 2.0, 9.0, 14.0, 1.5, 1.0, 2.0, 4.0, 5.0, 0.0, 2.0… #&gt; $ rating &lt;dbl&gt; 68.4, 34.0, 59.4, 93.7, 29.5, 33.2, 37.0, 49.1, 53.3, 1… Now we fit a neural network on our data. We use neuralnet library for the analysis. The first step is to scale the cereal dataset. The scaling of data is essential because otherwise a variable may have large impact on the prediction variable only because of its scale. Using unscaled may lead to meaningless results. The common techniques to scale data are: min-max normalization, Z-score normalization, median and MAD, and tan-h estimators. The min-max normalization transforms the data into a common range, thus removing the scaling effect from all the variables. Unlike Z-score normalization and median and MAD method, the min-max method retains the original distribution of the variables. We use min-max normalization to scale the data. The R script for scaling the data is as follows. ## Scale data for neural network max = apply(data , 2 , max) min = apply(data, 2 , min) scaled = as.data.frame(scale(data, center = min, scale = max - min)) ## Fit neural network # install library # install.packages(&quot;neuralnet &quot;) # load library library(neuralnet) # creating training and test set trainNN = scaled[index , ] testNN = scaled[-index , ] # fit neural network set.seed(2) NN = neuralnet(rating ~ calories + protein + fat + sodium + fiber, trainNN, hidden = 3 , linear.output = T ) # plot neural network plot(NN) ## Prediction using neural network predict_testNN = compute(NN, testNN[,c(1:5)]) predict_testNN = (predict_testNN$net.result * (max(data$rating) - min(data$rating))) + min(data$rating) plot(datatest$rating, predict_testNN, col=&#39;blue&#39;, pch=16, ylab = &quot;predicted rating NN&quot;, xlab = &quot;real rating&quot;) abline(0,1) # Calculate Root Mean Square Error (RMSE) RMSE.NN = (sum((datatest$rating - predict_testNN)^2) / nrow(datatest)) ^ 0.5 ## Cross validation of neural network model # install relevant libraries # install.packages(&quot;boot&quot;) # install.packages(&quot;plyr&quot;) # Load libraries library(boot) library(plyr) # Initialize variables set.seed(50) k = 100 RMSE.NN = NULL List = list( ) # Fit neural network model within nested for loop for(j in 10:65){ for (i in 1:k) { index = sample(1:nrow(data),j ) trainNN = scaled[index,] testNN = scaled[-index,] datatest = data[-index,] NN = neuralnet(rating ~ calories + protein + fat + sodium + fiber, trainNN, hidden = 3, linear.output= T) predict_testNN = compute(NN,testNN[,c(1:5)]) predict_testNN = (predict_testNN$net.result*(max(data$rating)-min(data$rating)))+min(data$rating) RMSE.NN [i]&lt;- (sum((datatest$rating - predict_testNN)^2)/nrow(datatest))^0.5 } List[[j]] = RMSE.NN } Matrix.RMSE = do.call(cbind, List) ## Prepare boxplot boxplot(Matrix.RMSE[,56], ylab = &quot;RMSE&quot;, main = &quot;RMSE BoxPlot (length of traning set = 65)&quot;) ## Variation of median RMSE # install.packages(&quot;matrixStats&quot;) library(matrixStats) #&gt; #&gt; Attaching package: &#39;matrixStats&#39; #&gt; The following object is masked from &#39;package:plyr&#39;: #&gt; #&gt; count med = colMedians(Matrix.RMSE) X = seq(10,65) plot (med~X, type = &quot;l&quot;, xlab = &quot;length of training set&quot;, ylab = &quot;median RMSE&quot;, main = &quot;Variation of RMSE with length of training set&quot;) Figure 9.1: Variation of RMSE Figure 9.1) shows that the median RMSE of our model decreases as the length of the training the set. This is an important result. The reader must remember that the model accuracy is dependent on the length of training set. The performance of neural network model is sensitive to training-test split. 9.4 End Notes The article discusses the theoretical aspects of a neural network, its implementation in R and post training evaluation. Neural network is inspired from biological nervous system. Similar to nervous system the information is passed through layers of processors. The significance of variables is represented by weights of each connection. The article provides basic understanding of back propagation algorithm, which is used to assign these weights. In this article we also implement neural network on R. We use a publically available dataset shared by CMU. The aim is to predict the rating of cereals using information such as calories, fat, protein etc. After constructing the neural network we evaluate the model for accuracy and robustness. We compute RMSE and perform cross-validation analysis. In cross validation, we check the variation in model accuracy as the length of training set is changed. We consider training sets with length 10 to 65. For each length a 100 samples are random picked and median RMSE is calculated. We show that model accuracy increases when training set is large. Before using the model for prediction, it is important to check the robustness of performance through cross validation. The article provides a quick review neural network and is a useful reference for data enthusiasts. We have provided commented R code throughout the article to help readers with hands on experience of using neural networks. "],
["fitting-a-neural-network.html", "Chapter 10 Fitting a neural network 10.1 Introduction 10.2 The dataset 10.3 Preparing to fit the neural network 10.4 Parameters 10.5 Predicting medv using the neural network 10.6 A (fast) cross validation 10.7 A final note on model interpretability", " Chapter 10 Fitting a neural network 10.1 Introduction https://www.r-bloggers.com/fitting-a-neural-network-in-r-neuralnet-package/ https://datascienceplus.com/fitting-neural-network-in-r/ Neural networks have always been one of the fascinating machine learning models in my opinion, not only because of the fancy backpropagation algorithm but also because of their complexity (think of deep learning with many hidden layers) and structure inspired by the brain. Neural networks have not always been popular, partly because they were, and still are in some cases, computationally expensive and partly because they did not seem to yield better results when compared with simpler methods such as support vector machines (SVMs). Nevertheless, Neural Networks have, once again, raised attention and become popular. Update: We published another post about Network analysis at DataScience+ Network analysis of Game of Thrones In this post, we are going to fit a simple neural network using the neuralnet package and fit a linear model as a comparison. 10.2 The dataset We are going to use the Boston dataset in the MASS package. The Boston dataset is a collection of data about housing values in the suburbs of Boston. Our goal is to predict the median value of owner-occupied homes (medv) using all the other continuous variables available. set.seed(500) library(MASS) data &lt;- Boston dplyr::glimpse(data) #&gt; Observations: 506 #&gt; Variables: 14 #&gt; $ crim &lt;dbl&gt; 0.00632, 0.02731, 0.02729, 0.03237, 0.06905, 0.02985, 0.… #&gt; $ zn &lt;dbl&gt; 18.0, 0.0, 0.0, 0.0, 0.0, 0.0, 12.5, 12.5, 12.5, 12.5, 1… #&gt; $ indus &lt;dbl&gt; 2.31, 7.07, 7.07, 2.18, 2.18, 2.18, 7.87, 7.87, 7.87, 7.… #&gt; $ chas &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,… #&gt; $ nox &lt;dbl&gt; 0.538, 0.469, 0.469, 0.458, 0.458, 0.458, 0.524, 0.524, … #&gt; $ rm &lt;dbl&gt; 6.58, 6.42, 7.18, 7.00, 7.15, 6.43, 6.01, 6.17, 5.63, 6.… #&gt; $ age &lt;dbl&gt; 65.2, 78.9, 61.1, 45.8, 54.2, 58.7, 66.6, 96.1, 100.0, 8… #&gt; $ dis &lt;dbl&gt; 4.09, 4.97, 4.97, 6.06, 6.06, 6.06, 5.56, 5.95, 6.08, 6.… #&gt; $ rad &lt;int&gt; 1, 2, 2, 3, 3, 3, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4,… #&gt; $ tax &lt;dbl&gt; 296, 242, 242, 222, 222, 222, 311, 311, 311, 311, 311, 3… #&gt; $ ptratio &lt;dbl&gt; 15.3, 17.8, 17.8, 18.7, 18.7, 18.7, 15.2, 15.2, 15.2, 15… #&gt; $ black &lt;dbl&gt; 397, 397, 393, 395, 397, 394, 396, 397, 387, 387, 393, 3… #&gt; $ lstat &lt;dbl&gt; 4.98, 9.14, 4.03, 2.94, 5.33, 5.21, 12.43, 19.15, 29.93,… #&gt; $ medv &lt;dbl&gt; 24.0, 21.6, 34.7, 33.4, 36.2, 28.7, 22.9, 27.1, 16.5, 18… First we need to check that no datapoint is missing, otherwise we need to fix the dataset. apply(data,2,function(x) sum(is.na(x))) #&gt; crim zn indus chas nox rm age dis rad #&gt; 0 0 0 0 0 0 0 0 0 #&gt; tax ptratio black lstat medv #&gt; 0 0 0 0 0 There is no missing data, good. We proceed by randomly splitting the data into a train and a test set, then we fit a linear regression model and test it on the test set. Note that I am using the gml() function instead of the lm() this will become useful later when cross validating the linear model. index &lt;- sample(1:nrow(data),round(0.75*nrow(data))) train &lt;- data[index,] test &lt;- data[-index,] lm.fit &lt;- glm(medv~., data=train) summary(lm.fit) #&gt; #&gt; Call: #&gt; glm(formula = medv ~ ., data = train) #&gt; #&gt; Deviance Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -15.211 -2.559 -0.655 1.828 29.711 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error t value Pr(&gt;|t|) #&gt; (Intercept) 31.11170 5.45981 5.70 2.5e-08 *** #&gt; crim -0.11137 0.03326 -3.35 0.00090 *** #&gt; zn 0.04263 0.01431 2.98 0.00308 ** #&gt; indus 0.00148 0.06745 0.02 0.98247 #&gt; chas 1.75684 0.98109 1.79 0.07417 . #&gt; nox -18.18485 4.47157 -4.07 5.8e-05 *** #&gt; rm 4.76034 0.48047 9.91 &lt; 2e-16 *** #&gt; age -0.01344 0.01410 -0.95 0.34119 #&gt; dis -1.55375 0.21893 -7.10 6.7e-12 *** #&gt; rad 0.28818 0.07202 4.00 7.6e-05 *** #&gt; tax -0.01374 0.00406 -3.38 0.00079 *** #&gt; ptratio -0.94755 0.14012 -6.76 5.4e-11 *** #&gt; black 0.00950 0.00290 3.28 0.00115 ** #&gt; lstat -0.38890 0.05973 -6.51 2.5e-10 *** #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; (Dispersion parameter for gaussian family taken to be 20.2) #&gt; #&gt; Null deviance: 32463.5 on 379 degrees of freedom #&gt; Residual deviance: 7407.1 on 366 degrees of freedom #&gt; AIC: 2237 #&gt; #&gt; Number of Fisher Scoring iterations: 2 pr.lm &lt;- predict(lm.fit,test) MSE.lm &lt;- sum((pr.lm - test$medv)^2)/nrow(test) The sample(x,size) function simply outputs a vector of the specified size of randomly selected samples from the vector x. By default the sampling is without replacement: index is essentially a random vector of indeces. Since we are dealing with a regression problem, we are going to use the mean squared error (MSE) as a measure of how much our predictions are far away from the real data. 10.3 Preparing to fit the neural network Before fitting a neural network, some preparation need to be done. Neural networks are not that easy to train and tune. As a first step, we are going to address data preprocessing. It is good practice to normalize your data before training a neural network. I cannot emphasize enough how important this step is: depending on your dataset, avoiding normalization may lead to useless results or to a very difficult training process (most of the times the algorithm will not converge before the number of maximum iterations allowed). You can choose different methods to scale the data (z-normalization, min-max scale, etc…). I chose to use the min-max method and scale the data in the interval [0,1]. Usually scaling in the intervals [0,1] or [-1,1] tends to give better results. We therefore scale and split the data before moving on: maxs &lt;- apply(data, 2, max) mins &lt;- apply(data, 2, min) scaled &lt;- as.data.frame(scale(data, center = mins, scale = maxs - mins)) train_ &lt;- scaled[index,] test_ &lt;- scaled[-index,] Note that scale returns a matrix that needs to be coerced into a data.frame. 10.4 Parameters As far as I know there is no fixed rule as to how many layers and neurons to use although there are several more or less accepted rules of thumb. Usually, if at all necessary, one hidden layer is enough for a vast numbers of applications. As far as the number of neurons is concerned, it should be between the input layer size and the output layer size, usually 2/3 of the input size. At least in my brief experience testing again and again is the best solution since there is no guarantee that any of these rules will fit your model best. Since this is a toy example, we are going to use 2 hidden layers with this configuration: 13:5:3:1. The input layer has 13 inputs, the two hidden layers have 5 and 3 neurons and the output layer has, of course, a single output since we are doing regression. Let’s fit the net: library(neuralnet) n &lt;- names(train_) f &lt;- as.formula(paste(&quot;medv ~&quot;, paste(n[!n %in% &quot;medv&quot;], collapse = &quot; + &quot;))) nn &lt;- neuralnet(f,data=train_,hidden=c(5,3),linear.output=T) A couple of notes: For some reason the formula y~. is not accepted in the neuralnet() function. You need to first write the formula and then pass it as an argument in the fitting function. The hidden argument accepts a vector with the number of neurons for each hidden layer, while the argument linear.output is used to specify whether we want to do regression linear.output=TRUE or classification linear.output=FALSE The neuralnet package provides a nice tool to plot the model: This is the graphical representation of the model with the weights on each connection: plot(nn) The black lines show the connections between each layer and the weights on each connection while the blue lines show the bias term added in each step. The bias can be thought as the intercept of a linear model. The net is essentially a black box so we cannot say that much about the fitting, the weights and the model. Suffice to say that the training algorithm has converged and therefore the model is ready to be used. 10.5 Predicting medv using the neural network Now we can try to predict the values for the test set and calculate the MSE. Remember that the net will output a normalized prediction, so we need to scale it back in order to make a meaningful comparison (or just a simple prediction). pr.nn &lt;- compute(nn,test_[,1:13]) pr.nn_ &lt;- pr.nn$net.result*(max(data$medv)-min(data$medv))+min(data$medv) test.r &lt;- (test_$medv)*(max(data$medv)-min(data$medv))+min(data$medv) MSE.nn &lt;- sum((test.r - pr.nn_)^2)/nrow(test_) we then compare the two MSEs print(paste(MSE.lm,MSE.nn)) #&gt; [1] &quot;31.2630222372615 16.4595537665717&quot; Apparently, the net is doing a better work than the linear model at predicting medv. Once again, be careful because this result depends on the train-test split performed above. Below, after the visual plot, we are going to perform a fast cross validation in order to be more confident about the results. A first visual approach to the performance of the network and the linear model on the test set is plotted below par(mfrow=c(1,2)) plot(test$medv,pr.nn_,col=&#39;red&#39;,main=&#39;Real vs predicted NN&#39;,pch=18,cex=0.7) abline(0,1,lwd=2) legend(&#39;bottomright&#39;,legend=&#39;NN&#39;,pch=18,col=&#39;red&#39;, bty=&#39;n&#39;) plot(test$medv,pr.lm,col=&#39;blue&#39;,main=&#39;Real vs predicted lm&#39;,pch=18, cex=0.7) abline(0,1,lwd=2) legend(&#39;bottomright&#39;,legend=&#39;LM&#39;,pch=18,col=&#39;blue&#39;, bty=&#39;n&#39;, cex=.95) By visually inspecting the plot we can see that the predictions made by the neural network are (in general) more concetrated around the line (a perfect alignment with the line would indicate a MSE of 0 and thus an ideal perfect prediction) than those made by the linear model. plot(test$medv,pr.nn_,col=&#39;red&#39;,main=&#39;Real vs predicted NN&#39;,pch=18,cex=0.7) points(test$medv,pr.lm,col=&#39;blue&#39;,pch=18,cex=0.7) abline(0,1,lwd=2) legend(&#39;bottomright&#39;,legend=c(&#39;NN&#39;,&#39;LM&#39;),pch=18,col=c(&#39;red&#39;,&#39;blue&#39;)) 10.6 A (fast) cross validation Cross validation is another very important step of building predictive models. While there are different kind of cross validation methods, the basic idea is repeating the following process a number of time: train-test split Do the train-test split Fit the model to the train set Test the model on the test set Calculate the prediction error Repeat the process K times Then by calculating the average error we can get a grasp of how the model is doing. We are going to implement a fast cross validation using a for loop for the neural network and the cv.glm() function in the boot package for the linear model. As far as I know, there is no built-in function in R to perform cross-validation on this kind of neural network, if you do know such a function, please let me know in the comments. Here is the 10 fold cross-validated MSE for the linear model: library(boot) set.seed(200) lm.fit &lt;- glm(medv~.,data=data) cv.glm(data,lm.fit,K=10)$delta[1] #&gt; [1] 23.2 Now the net. Note that I am splitting the data in this way: 90% train set and 10% test set in a random way for 10 times. I am also initializing a progress bar using the plyr library because I want to keep an eye on the status of the process since the fitting of the neural network may take a while. set.seed(450) cv.error &lt;- NULL k &lt;- 10 library(plyr) pbar &lt;- create_progress_bar(&#39;text&#39;) pbar$init(k) #&gt; | | | 0% for(i in 1:k){ index &lt;- sample(1:nrow(data),round(0.9*nrow(data))) train.cv &lt;- scaled[index,] test.cv &lt;- scaled[-index,] nn &lt;- neuralnet(f,data=train.cv,hidden=c(5,2),linear.output=T) pr.nn &lt;- compute(nn,test.cv[,1:13]) pr.nn &lt;- pr.nn$net.result*(max(data$medv)-min(data$medv))+min(data$medv) test.cv.r &lt;- (test.cv$medv)*(max(data$medv)-min(data$medv))+min(data$medv) cv.error[i] &lt;- sum((test.cv.r - pr.nn)^2)/nrow(test.cv) pbar$step() } #&gt; | |====== | 10% | |============= | 20% | |==================== | 30% | |========================== | 40% | |================================ | 50% | |======================================= | 60% | |============================================== | 70% | |==================================================== | 80% | |========================================================== | 90% | |=================================================================| 100% After a while, the process is done, we calculate the average MSE and plot the results as a boxplot mean(cv.error) #&gt; [1] 7.64 cv.error #&gt; [1] 13.33 7.10 6.58 5.70 6.84 5.77 10.75 5.38 9.45 5.50 The code for the box plot: The code above outputs the following boxplot: boxplot(cv.error,xlab=&#39;MSE CV&#39;,col=&#39;cyan&#39;, border=&#39;blue&#39;,names=&#39;CV error (MSE)&#39;, main=&#39;CV error (MSE) for NN&#39;,horizontal=TRUE) As you can see, the average MSE for the neural network (10.33) is lower than the one of the linear model although there seems to be a certain degree of variation in the MSEs of the cross validation. This may depend on the splitting of the data or the random initialization of the weights in the net. By running the simulation different times with different seeds you can get a more precise point estimate for the average MSE. 10.7 A final note on model interpretability Neural networks resemble black boxes a lot: explaining their outcome is much more difficult than explaining the outcome of simpler model such as a linear model. Therefore, depending on the kind of application you need, you might want to take into account this factor too. Furthermore, as you have seen above, extra care is needed to fit a neural network and small changes can lead to different results. A gist with the full code for this post can be found here. Thank you for reading this post, leave a comment below if you have any question. "],
["visualization-of-neural-networks.html", "Chapter 11 Visualization of neural networks 11.1 caret and plot NN 11.2 Multiple hidden layers 11.3 Binary predictors 11.4 color coding the input layer", " Chapter 11 Visualization of neural networks https://beckmw.wordpress.com/tag/neuralnet/ In my last post I said I wasn’t going to write anymore about neural networks (i.e., multilayer feedforward perceptron, supervised ANN, etc.). That was a lie. I’ve received several requests to update the neural network plotting function described in the original post. As previously explained, R does not provide a lot of options for visualizing neural networks. The only option I know of is a plotting method for objects from the neuralnet package. This may be my opinion, but I think this plot leaves much to be desired (see below). Also, no plotting methods exist for neural networks created in other packages, i.e., nnet and RSNNS. These packages are the only ones listed on the CRAN task view, so I’ve updated my original plotting function to work with all three. Additionally, I’ve added a new option for plotting a raw weight vector to allow use with neural networks created elsewhere. This blog describes these changes, as well as some new arguments added to the original function. As usual, I’ll simulate some data to use for creating the neural networks. The dataset contains eight input variables and two output variables. The final dataset is a data frame with all variables, as well as separate data frames for the input and output variables. I’ve retained separate datasets based on the syntax for each package. library(clusterGeneration) #&gt; Loading required package: MASS library(tictoc) seed.val&lt;- 12345 set.seed(seed.val) num.vars&lt;-8 num.obs&lt;-1000 # input variables cov.mat &lt;-genPositiveDefMat(num.vars,covMethod=c(&quot;unifcorrmat&quot;))$Sigma rand.vars &lt;-mvrnorm(num.obs,rep(0,num.vars),Sigma=cov.mat) # output variables parms &lt;-runif(num.vars,-10,10) y1 &lt;- rand.vars %*% matrix(parms) + rnorm(num.obs,sd=20) parms2 &lt;- runif(num.vars,-10,10) y2 &lt;- rand.vars %*% matrix(parms2) + rnorm(num.obs,sd=20) # final datasets rand.vars &lt;- data.frame(rand.vars) resp &lt;- data.frame(y1,y2) names(resp) &lt;- c(&#39;Y1&#39;,&#39;Y2&#39;) dat.in &lt;- data.frame(resp, rand.vars) dplyr::glimpse(dat.in) #&gt; Observations: 1,000 #&gt; Variables: 10 #&gt; $ Y1 &lt;dbl&gt; 25.442, -14.578, -36.214, 15.216, -6.393, -20.849, -28.665, -… #&gt; $ Y2 &lt;dbl&gt; 16.9, 38.8, 31.2, -31.2, 93.3, 11.7, 59.7, -103.5, -49.8, 50.… #&gt; $ X1 &lt;dbl&gt; 3.138, -0.705, -4.373, 0.837, 0.787, 1.923, -1.419, 1.121, -0… #&gt; $ X2 &lt;dbl&gt; 0.195, -0.302, 0.773, 1.311, 3.506, 1.245, 3.800, -0.165, 0.3… #&gt; $ X3 &lt;dbl&gt; -1.795, -2.596, 2.308, 4.081, -3.921, 1.473, -0.926, 7.101, 2… #&gt; $ X4 &lt;dbl&gt; -2.7216, 3.0589, 1.2455, 3.4607, 2.3775, -2.9833, 2.6669, -0.… #&gt; $ X5 &lt;dbl&gt; 0.0407, 0.7602, -3.0217, -4.2799, 2.0859, 1.4765, 0.0561, 2.8… #&gt; $ X6 &lt;dbl&gt; -1.4820, -0.5014, 0.0603, -1.8551, 2.2817, 1.7386, 1.7450, -2… #&gt; $ X7 &lt;dbl&gt; -0.7169, -0.3618, -1.5283, 4.2026, -6.1548, -0.3545, -6.0284,… #&gt; $ X8 &lt;dbl&gt; 1.152, 1.810, -1.357, 0.598, -1.425, -1.210, -1.004, 2.494, -… The various neural network packages are used to create separate models for plotting. # first model with nnet #nnet function from nnet package library(nnet) set.seed(seed.val) tic() mod1 &lt;- nnet(rand.vars, resp, data = dat.in, size = 10, linout = T) #&gt; # weights: 112 #&gt; initial value 4784162.893260 #&gt; iter 10 value 1794537.980652 #&gt; iter 20 value 1577753.498759 #&gt; iter 30 value 1485254.945755 #&gt; iter 40 value 1449238.248788 #&gt; iter 50 value 1427720.291804 #&gt; iter 60 value 1416977.236373 #&gt; iter 70 value 1405167.753521 #&gt; iter 80 value 1395046.792257 #&gt; iter 90 value 1370522.267277 #&gt; iter 100 value 1363709.540981 #&gt; final value 1363709.540981 #&gt; stopped after 100 iterations toc() #&gt; 0.182 sec elapsed # nn &lt;- neuralnet(form.in, # data = dat.sc, # # hidden = c(13, 10, 3), # hidden = c(5), # act.fct = &quot;tanh&quot;, # linear.output = FALSE, # lifesign = &quot;minimal&quot;) # 2nd model with neuralnet # neuralnet function from neuralnet package, notice use of only one response library(neuralnet) softplus &lt;- function(x) log(1 + exp(x)) sigmoid &lt;- function(x) log(1 + exp(-x)) dat.sc &lt;- scale(dat.in) form.in &lt;- as.formula(&#39;Y1 ~ X1+X2+X3+X4+X5+X6+X7+X8&#39;) set.seed(seed.val) tic() mod2 &lt;- neuralnet(form.in, data = dat.sc, hidden = 10, lifesign = &quot;minimal&quot;, linear.output = FALSE, act.fct = &quot;tanh&quot;) #&gt; hidden: 10 thresh: 0.01 rep: 1/1 steps: 26361 error: 160.06372 time: 54.35 secs toc() #&gt; 54.361 sec elapsed # third model with RSNNS # mlp function from RSNNS package library(RSNNS) #&gt; Loading required package: Rcpp set.seed(seed.val) tic() mod3 &lt;- mlp(rand.vars, resp, size = 10, linOut = T) toc() #&gt; 0.407 sec elapsed I’ve noticed some differences between the functions that could lead to some confusion. For simplicity, the above code represents my interpretation of the most direct way to create a neural network in each package. Be very aware that direct comparison of results is not advised given that the default arguments differ between the packages. A few key differences are as follows, although many others should be noted. First, the functions differ in the methods for passing the primary input variables. The nnet function can take separate (or combined) x and y inputs as data frames or as a formula, the neuralnet function can only use a formula as input, and the mlp function can only take a data frame as combined or separate variables as input. As far as I know, the neuralnet function is not capable of modelling multiple response variables, unless the response is a categorical variable that uses one node for each outcome. Additionally, the default output for the neuralnet function is linear, whereas the opposite is true for the other two functions. Specifics aside, here’s how to use the updated plot function. Note that the same syntax is used to plot each model # import the function from Github library(devtools) source_url(&#39;https://gist.githubusercontent.com/fawda123/7471137/raw/466c1474d0a505ff044412703516c34f1a4684a5/nnet_plot_update.r&#39;) #&gt; SHA-1 hash of file is 74c80bd5ddbc17ab3ae5ece9c0ed9beb612e87ef # plot each model plot.nnet(mod1) #&gt; Loading required package: scales #&gt; Loading required package: reshape plot.nnet(mod2) plot.nnet(mod3) #&gt; Warning in plot.nnet(mod3): Bias layer not applicable for rsnns object The plotting function can also now be used with an arbitrary weight vector, rather than a specific model object. The struct argument must also be included if this option is used. I thought the easiest way to use the plotting function with your own weights was to have the input weights as a numeric vector, including bias layers. I’ve shown how this can be done using the weights directly from mod1 for simplicity. wts.in &lt;- mod1$wts struct &lt;- mod1$n plot.nnet(wts.in,struct=struct) Note that wts.in is a numeric vector with length equal to the expected given the architecture (i.e., for 8 10 2 network, 100 connection weights plus 12 bias weights). The plot should look the same as the plot for the neural network from nnet. The weights in the input vector need to be in a specific order for correct plotting. I realize this is not clear by looking directly at wt.in but this was the simplest approach I could think of. The weight vector shows the weights for each hidden node in sequence, starting with the bias input for each node, then the weights for each output node in sequence, starting with the bias input for each output node. Note that the bias layer has to be included even if the network was not created with biases. If this is the case, simply input a random number where the bias values should go and use the argument bias=F. I’ll show the correct order of the weights using an example with plot.nn from the neuralnet package since the weights are included directly on the plot. If we pretend that the above figure wasn’t created in R, we would input the mod.in argument for the updated plotting function as follows. Also note that struct must be included if using this approach. mod.in&lt;-c(13.12,1.49,0.16,-0.11,-0.19,-0.16,0.56,-0.52,0.81) struct&lt;-c(2,2,1) #two inputs, two hidden, one output plot.nnet(mod.in, struct=struct) Note the comparability with the figure created using the neuralnet package. That is, larger weights have thicker lines and color indicates sign (+ black, – grey). One of these days I’ll actually put these functions in a package. In the meantime, please let me know if any bugs are encountered. 11.1 caret and plot NN I’ve changed the function to work with neural networks created using the train function from the caret package. The link above is updated but you can also grab it here. library(caret) #&gt; Loading required package: lattice #&gt; Loading required package: ggplot2 #&gt; Registered S3 methods overwritten by &#39;ggplot2&#39;: #&gt; method from #&gt; [.quosures rlang #&gt; c.quosures rlang #&gt; print.quosures rlang #&gt; #&gt; Attaching package: &#39;caret&#39; #&gt; The following objects are masked from &#39;package:RSNNS&#39;: #&gt; #&gt; confusionMatrix, train mod4 &lt;- train(Y1 ~., method=&#39;nnet&#39;, data=dat.in, linout=T) plot.nnet(mod4,nid=T) #&gt; Warning in plot.nnet(mod4, nid = T): Using best nnet model from train #&gt; output fact&lt;-factor(sample(c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;),size=num.obs,replace=T)) form.in&lt;-formula(&#39;cbind(Y2,Y1)~X1+X2+X3+fact&#39;) mod5&lt;-nnet(form.in,data=cbind(dat.in,fact),size=10,linout=T) #&gt; # weights: 82 #&gt; initial value 4799569.423556 #&gt; iter 10 value 2864553.218126 #&gt; iter 20 value 2595828.194160 #&gt; iter 30 value 2517965.483941 #&gt; iter 40 value 2464882.178217 #&gt; iter 50 value 2444238.700834 #&gt; iter 60 value 2424302.290643 #&gt; iter 70 value 2395226.949866 #&gt; iter 80 value 2375558.751266 #&gt; iter 90 value 2343011.050867 #&gt; iter 100 value 2298860.593948 #&gt; final value 2298860.593948 #&gt; stopped after 100 iterations plot.nnet(mod5,nid=T) 11.2 Multiple hidden layers More updates… I’ve now modified the function to plot multiple hidden layers for networks created using the mlp function in the RSNNS package and neuralnet in the neuralnet package. As far as I know, these are the only neural network functions in R that can create multiple hidden layers. All others use a single hidden layer. I have not tested the plotting function using manual input for the weight vectors with multiple hidden layers. My guess is it won’t work but I can’t be bothered to change the function unless it’s specifically requested. The updated function can be grabbed here (all above links to the function have also been changed). library(RSNNS) # neural net with three hidden layers, 9, 11, and 8 nodes in each tic() mod &lt;-mlp(rand.vars, resp, size = c(9,11,8), linOut = T) toc() #&gt; 0.392 sec elapsed par(mar=numeric(4),family=&#39;serif&#39;) plot.nnet(mod) #&gt; Warning in plot.nnet(mod): Bias layer not applicable for rsnns object 11.3 Binary predictors Here’s an example using the neuralnet function with binary predictors and categorical outputs (credit to Tao Ma for the model code). library(neuralnet) #response AND&lt;-c(rep(0,7),1) OR&lt;-c(0,rep(1,7)) # response with predictors binary.data &lt;- data.frame(expand.grid(c(0,1), c(0,1), c(0,1)), AND, OR) #model tic() net &lt;- neuralnet(AND+OR ~ Var1+Var2+Var3, binary.data, hidden =c(6,12,8), rep = 10, err.fct=&quot;ce&quot;, linear.output=FALSE) toc() #&gt; 0.143 sec elapsed #plot ouput par(mar=numeric(4),family=&#39;serif&#39;) plot.nnet(net) 11.4 color coding the input layer The color vector argument (circle.col) for the nodes was changed to allow a separate color vector for the input layer. The following example shows how this can be done using relative importance of the input variables to color-code the first layer. # example showing use of separate colors for input layer # color based on relative importance using &#39;gar.fun&#39; ## #create input data seed.val&lt;-3 set.seed(seed.val) num.vars&lt;-8 num.obs&lt;-1000 #input variables library(clusterGeneration) cov.mat&lt;-genPositiveDefMat(num.vars,covMethod=c(&quot;unifcorrmat&quot;))$Sigma rand.vars&lt;-mvrnorm(num.obs,rep(0,num.vars),Sigma=cov.mat) # output variables parms&lt;-runif(num.vars,-10,10) y1&lt;-rand.vars %*% matrix(parms) + rnorm(num.obs,sd=20) # final datasets rand.vars&lt;-data.frame(rand.vars) resp&lt;-data.frame(y1) names(resp)&lt;-&#39;Y1&#39; dat.in &lt;- data.frame(resp,rand.vars) ## # create model library(nnet) mod1 &lt;- nnet(rand.vars,resp,data=dat.in,size=10,linout=T) #&gt; # weights: 101 #&gt; initial value 844959.580478 #&gt; iter 10 value 543616.101824 #&gt; iter 20 value 479986.887846 #&gt; iter 30 value 465607.784054 #&gt; iter 40 value 454237.073298 #&gt; iter 50 value 445032.412421 #&gt; iter 60 value 433191.158624 #&gt; iter 70 value 426321.161292 #&gt; iter 80 value 424900.966883 #&gt; iter 90 value 423816.437605 #&gt; iter 100 value 422064.114812 #&gt; final value 422064.114812 #&gt; stopped after 100 iterations ## # relative importance function library(devtools) source_url(&#39;https://gist.github.com/fawda123/6206737/raw/2e1bc9cbc48d1a56d2a79dd1d33f414213f5f1b1/gar_fun.r&#39;) #&gt; SHA-1 hash of file is 9faa58824c46956c3ff78081696290d9b32d845f # relative importance of input variables for Y1 rel.imp &lt;- gar.fun(&#39;Y1&#39;,mod1,bar.plot=F)$rel.imp #color vector based on relative importance of input values cols&lt;-colorRampPalette(c(&#39;green&#39;,&#39;red&#39;))(num.vars)[rank(rel.imp)] ## #plotting function source_url(&#39;https://gist.githubusercontent.com/fawda123/7471137/raw/466c1474d0a505ff044412703516c34f1a4684a5/nnet_plot_update.r&#39;) #&gt; SHA-1 hash of file is 74c80bd5ddbc17ab3ae5ece9c0ed9beb612e87ef #plot model with new color vector #separate colors for input vectors using a list for &#39;circle.col&#39; plot(mod1,circle.col=list(cols,&#39;lightblue&#39;)) "]
]
